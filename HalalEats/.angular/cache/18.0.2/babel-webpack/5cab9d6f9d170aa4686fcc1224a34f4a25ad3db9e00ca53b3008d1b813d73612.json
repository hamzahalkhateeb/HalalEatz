{"ast":null,"code":"/**\r\n * @license Angular v18.0.1\r\n * (c) 2010-2024 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\n\n/**\r\n * The jsaction attribute defines a mapping of a DOM event to a\r\n * generic event (aka jsaction), to which the actual event handlers\r\n * that implement the behavior of the application are bound. The\r\n * value is a semicolon separated list of colon separated pairs of\r\n * an optional DOM event name and a jsaction name. If the optional\r\n * DOM event name is omitted, 'click' is assumed. The jsaction names\r\n * are dot separated pairs of a namespace and a simple jsaction\r\n * name.\r\n *\r\n * See grammar in README.md for expected syntax in the attribute value.\r\n */\nconst JSACTION$1 = 'jsaction';\n/**\r\n * The oi attribute is a log impression tag for impression logging\r\n * and action tracking. For an element that carries a jsaction\r\n * attribute, the element is identified for the purpose of\r\n * impression logging and click tracking by the dot separated path\r\n * of all oi attributes in the chain of ancestors of the element.\r\n *\r\n * Used by ActionFlow.\r\n */\nconst OI$1 = 'oi';\n/**\r\n * The ved attribute is an encoded ClickTrackingCGI proto to track\r\n * visual elements.\r\n *\r\n * Used by ActionFlow.\r\n */\nconst VED = 'ved';\n/**\r\n * The vet attribute is the visual element type used to identify tracked\r\n * visual elements.\r\n */\nconst VET = 'vet';\n/**\r\n * Support for iteration on reprocessing.\r\n *\r\n * Used by ActionFlow.\r\n */\nconst JSINSTANCE = 'jsinstance';\n/**\r\n * All click jsactions that happen on the element that carries this\r\n * attribute or its descendants are automatically logged.\r\n * Impressions of jsactions on these elements are tracked too, if\r\n * requested by the impression() method of ActionFlow.\r\n *\r\n * Used by ActionFlow.\r\n */\nconst JSTRACK = 'jstrack';\nconst Attribute = {\n  JSACTION: JSACTION$1,\n  OI: OI$1,\n  VED,\n  VET,\n  JSINSTANCE,\n  JSTRACK\n};\nconst Char = {\n  /**\r\n   * The separator between the namespace and the action name in the\r\n   * jsaction attribute value.\r\n   */\n  NAMESPACE_ACTION_SEPARATOR: '.',\n  /**\r\n   * The separator between the event name and action in the jsaction\r\n   * attribute value.\r\n   */\n  EVENT_ACTION_SEPARATOR: ':',\n  /**\r\n   * The separator between the logged oi attribute values in the &oi=\r\n   * URL parameter value.\r\n   */\n  OI_SEPARATOR: '.',\n  /**\r\n   * The separator between the key and the value pairs in the &cad=\r\n   * URL parameter value.\r\n   */\n  CAD_KEY_VALUE_SEPARATOR: ':',\n  /**\r\n   * The separator between the key-value pairs in the &cad= URL\r\n   * parameter value.\r\n   */\n  CAD_SEPARATOR: ','\n};\n\n/*\r\n * Names of events that are special to jsaction. These are not all\r\n * event types that are legal to use in either HTML or the addEvent()\r\n * API, but these are the ones that are treated specially. All other\r\n * DOM events can be used in either addEvent() or in the value of the\r\n * jsaction attribute. Beware of browser specific events or events\r\n * that don't bubble though: If they are not mentioned here, then\r\n * event contract doesn't work around their peculiarities.\r\n */\nconst EventType = {\n  /**\r\n   * Mouse middle click, introduced in Chrome 55 and not yet supported on\r\n   * other browsers.\r\n   */\n  AUXCLICK: 'auxclick',\n  /**\r\n   * The change event fired by browsers when the `value` attribute of input,\r\n   * select, and textarea elements are changed.\r\n   */\n  CHANGE: 'change',\n  /**\r\n   * The click event. In addEvent() refers to all click events, in the\r\n   * jsaction attribute it refers to the unmodified click and Enter/Space\r\n   * keypress events.  In the latter case, a jsaction click will be triggered,\r\n   * for accessibility reasons.  See clickmod and clickonly, below.\r\n   */\n  CLICK: 'click',\n  /**\r\n   * Specifies the jsaction for a modified click event (i.e. a mouse\r\n   * click with the modifier key Cmd/Ctrl pressed). This event isn't\r\n   * separately enabled in addEvent(), because in the DOM, it's just a\r\n   * click event.\r\n   */\n  CLICKMOD: 'clickmod',\n  /**\r\n   * Specifies the jsaction for a click-only event.  Click-only doesn't take\r\n   * into account the case where an element with focus receives an Enter/Space\r\n   * keypress.  This event isn't separately enabled in addEvent().\r\n   */\n  CLICKONLY: 'clickonly',\n  /**\r\n   * The dblclick event.\r\n   */\n  DBLCLICK: 'dblclick',\n  /**\r\n   * Focus doesn't bubble, but you can use it in addEvent() and\r\n   * jsaction anyway. EventContract does the right thing under the\r\n   * hood.\r\n   */\n  FOCUS: 'focus',\n  /**\r\n   * This event only exists in IE. For addEvent() and jsaction, use\r\n   * focus instead; EventContract does the right thing even though\r\n   * focus doesn't bubble.\r\n   */\n  FOCUSIN: 'focusin',\n  /**\r\n   * Analog to focus.\r\n   */\n  BLUR: 'blur',\n  /**\r\n   * Analog to focusin.\r\n   */\n  FOCUSOUT: 'focusout',\n  /**\r\n   * Submit doesn't bubble, so it cannot be used with event\r\n   * contract. However, the browser helpfully fires a click event on\r\n   * the submit button of a form (even if the form is not submitted by\r\n   * a click on the submit button). So you should handle click on the\r\n   * submit button instead.\r\n   */\n  SUBMIT: 'submit',\n  /**\r\n   * The keydown event. In addEvent() and non-click jsaction it represents the\r\n   * regular DOM keydown event. It represents click actions in non-Gecko\r\n   * browsers.\r\n   */\n  KEYDOWN: 'keydown',\n  /**\r\n   * The keypress event. In addEvent() and non-click jsaction it represents the\r\n   * regular DOM keypress event. It represents click actions in Gecko browsers.\r\n   */\n  KEYPRESS: 'keypress',\n  /**\r\n   * The keyup event. In addEvent() and non-click jsaction it represents the\r\n   * regular DOM keyup event. It represents click actions in non-Gecko\r\n   * browsers.\r\n   */\n  KEYUP: 'keyup',\n  /**\r\n   * The mouseup event. Can either be used directly or used implicitly to\r\n   * capture mouseup events. In addEvent(), it represents a regular DOM\r\n   * mouseup event.\r\n   */\n  MOUSEUP: 'mouseup',\n  /**\r\n   * The mousedown event. Can either be used directly or used implicitly to\r\n   * capture mouseenter events. In addEvent(), it represents a regular DOM\r\n   * mouseover event.\r\n   */\n  MOUSEDOWN: 'mousedown',\n  /**\r\n   * The mouseover event. Can either be used directly or used implicitly to\r\n   * capture mouseenter events. In addEvent(), it represents a regular DOM\r\n   * mouseover event.\r\n   */\n  MOUSEOVER: 'mouseover',\n  /**\r\n   * The mouseout event. Can either be used directly or used implicitly to\r\n   * capture mouseover events. In addEvent(), it represents a regular DOM\r\n   * mouseout event.\r\n   */\n  MOUSEOUT: 'mouseout',\n  /**\r\n   * The mouseenter event. Does not bubble and fires individually on each\r\n   * element being entered within a DOM tree.\r\n   */\n  MOUSEENTER: 'mouseenter',\n  /**\r\n   * The mouseleave event. Does not bubble and fires individually on each\r\n   * element being entered within a DOM tree.\r\n   */\n  MOUSELEAVE: 'mouseleave',\n  /**\r\n   * The mousemove event.\r\n   */\n  MOUSEMOVE: 'mousemove',\n  /**\r\n   * The pointerup event. Can either be used directly or used implicitly to\r\n   * capture pointerup events. In addEvent(), it represents a regular DOM\r\n   * pointerup event.\r\n   */\n  POINTERUP: 'pointerup',\n  /**\r\n   * The pointerdown event. Can either be used directly or used implicitly to\r\n   * capture pointerenter events. In addEvent(), it represents a regular DOM\r\n   * mouseover event.\r\n   */\n  POINTERDOWN: 'pointerdown',\n  /**\r\n   * The pointerover event. Can either be used directly or used implicitly to\r\n   * capture pointerenter events. In addEvent(), it represents a regular DOM\r\n   * pointerover event.\r\n   */\n  POINTEROVER: 'pointerover',\n  /**\r\n   * The pointerout event. Can either be used directly or used implicitly to\r\n   * capture pointerover events. In addEvent(), it represents a regular DOM\r\n   * pointerout event.\r\n   */\n  POINTEROUT: 'pointerout',\n  /**\r\n   * The pointerenter event. Does not bubble and fires individually on each\r\n   * element being entered within a DOM tree.\r\n   */\n  POINTERENTER: 'pointerenter',\n  /**\r\n   * The pointerleave event. Does not bubble and fires individually on each\r\n   * element being entered within a DOM tree.\r\n   */\n  POINTERLEAVE: 'pointerleave',\n  /**\r\n   * The pointermove event.\r\n   */\n  POINTERMOVE: 'pointermove',\n  /**\r\n   * The pointercancel event.\r\n   */\n  POINTERCANCEL: 'pointercancel',\n  /**\r\n   * The gotpointercapture event is fired when\r\n   * Element.setPointerCapture(pointerId) is called on a mouse input, or\r\n   * implicitly when a touch input begins.\r\n   */\n  GOTPOINTERCAPTURE: 'gotpointercapture',\n  /**\r\n   * The lostpointercapture event is fired when\r\n   * Element.releasePointerCapture(pointerId) is called, or implicitly after a\r\n   * touch input ends.\r\n   */\n  LOSTPOINTERCAPTURE: 'lostpointercapture',\n  /**\r\n   * The error event. The error event doesn't bubble, but you can use it in\r\n   * addEvent() and jsaction anyway. EventContract does the right thing under\r\n   * the hood (except in IE8 which does not use error events).\r\n   */\n  ERROR: 'error',\n  /**\r\n   * The load event. The load event doesn't bubble, but you can use it in\r\n   * addEvent() and jsaction anyway. EventContract does the right thing\r\n   * under the hood.\r\n   */\n  LOAD: 'load',\n  /**\r\n   * The unload event.\r\n   */\n  UNLOAD: 'unload',\n  /**\r\n   * The touchstart event. Bubbles, will only ever fire in browsers with\r\n   * touch support.\r\n   */\n  TOUCHSTART: 'touchstart',\n  /**\r\n   * The touchend event. Bubbles, will only ever fire in browsers with\r\n   * touch support.\r\n   */\n  TOUCHEND: 'touchend',\n  /**\r\n   * The touchmove event. Bubbles, will only ever fire in browsers with\r\n   * touch support.\r\n   */\n  TOUCHMOVE: 'touchmove',\n  /**\r\n   * The input event.\r\n   */\n  INPUT: 'input',\n  /**\r\n   * The scroll event.\r\n   */\n  SCROLL: 'scroll',\n  /**\r\n   * The toggle event. The toggle event doesn't bubble, but you can use it in\r\n   * addEvent() and jsaction anyway. EventContract does the right thing\r\n   * under the hood.\r\n   */\n  TOGGLE: 'toggle',\n  /**\r\n   * A custom event. The actual custom event type is declared as the 'type'\r\n   * field in the event details. Supported in Firefox 6+, IE 9+, and all Chrome\r\n   * versions.\r\n   *\r\n   * This is an internal name. Users should use jsaction's fireCustomEvent to\r\n   * fire custom events instead of relying on this type to create them.\r\n   */\n  CUSTOM: '_custom'\n};\nconst NON_BUBBLING_MOUSE_EVENTS = [EventType.MOUSEENTER, EventType.MOUSELEAVE, 'pointerenter', 'pointerleave'];\n/**\r\n * Detects whether a given event type is supported by JSAction.\r\n */\nconst isSupportedEvent = eventType => SUPPORTED_EVENTS.includes(eventType);\nconst SUPPORTED_EVENTS = [EventType.CLICK, EventType.DBLCLICK, EventType.FOCUS, EventType.FOCUSIN, EventType.BLUR, EventType.ERROR, EventType.FOCUSOUT, EventType.KEYDOWN, EventType.KEYUP, EventType.KEYPRESS, EventType.LOAD, EventType.MOUSEOVER, EventType.MOUSEOUT, EventType.SUBMIT, EventType.TOGGLE, EventType.TOUCHSTART, EventType.TOUCHEND, EventType.TOUCHMOVE, 'touchcancel', 'auxclick', 'change', 'compositionstart', 'compositionupdate', 'compositionend', 'beforeinput', 'input', 'select', 'copy', 'cut', 'paste', 'mousedown', 'mouseup', 'wheel', 'contextmenu', 'dragover', 'dragenter', 'dragleave', 'drop', 'dragstart', 'dragend', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerover', 'pointerout', 'gotpointercapture', 'lostpointercapture',\n// Video events.\n'ended', 'loadedmetadata',\n// Page visibility events.\n'pagehide', 'pageshow', 'visibilitychange',\n// Content visibility events.\n'beforematch'];\n/**\r\n *\r\n * Decides whether or not an event type is an event that only has a capture phase.\r\n *\r\n * @param eventType\r\n * @returns bool\r\n */\nconst isCaptureEvent = eventType => CAPTURE_EVENTS.indexOf(eventType) >= 0;\nconst CAPTURE_EVENTS = [EventType.FOCUS, EventType.BLUR, EventType.ERROR, EventType.LOAD, EventType.TOGGLE];\n\n/**\r\n * The parsed value of the jsaction attribute is stored in this\r\n * property on the DOM node. The parsed value is an Object. The\r\n * property names of the object are the events; the values are the\r\n * names of the actions. This property is attached even on nodes\r\n * that don't have a jsaction attribute as an optimization, because\r\n * property lookup is faster than attribute access.\r\n */\nconst JSACTION = '__jsaction';\n/** The value of the oi attribute as a property, for faster access. */\nconst OI = '__oi';\n/**\r\n * The owner property references an a logical owner for a DOM node. JSAction\r\n * will follow this reference instead of parentNode when traversing the DOM\r\n * to find jsaction attributes. This allows overlaying a logical structure\r\n * over a document where the DOM structure can't reflect that structure.\r\n */\nconst OWNER = '__owner';\n/** All properties that are used by jsaction. */\nconst Property = {\n  JSACTION,\n  OI,\n  OWNER\n};\n\n/**\r\n * Map from jsaction annotation to a parsed map from event name to action name.\r\n */\nconst parseCache = {};\n/**\r\n * Reads the jsaction parser cache from the given DOM Element.\r\n *\r\n * @param element .\r\n * @return Map from event to qualified name of the jsaction bound to it.\r\n */\nfunction get(element) {\n  // @ts-ignore\n  return element[JSACTION];\n}\n/**\r\n * Writes the jsaction parser cache to the given DOM Element.\r\n *\r\n * @param element .\r\n * @param actionMap Map from event to qualified name of the jsaction bound to\r\n *     it.\r\n */\nfunction set(element, actionMap) {\n  // @ts-ignore\n  element[JSACTION] = actionMap;\n}\n/**\r\n * Looks up the parsed action map from the source jsaction attribute value.\r\n *\r\n * @param text Unparsed jsaction attribute value.\r\n * @return Parsed jsaction attribute value, if already present in the cache.\r\n */\nfunction getParsed(text) {\n  return parseCache[text];\n}\n/**\r\n * Inserts the parse result for the given source jsaction value into the cache.\r\n *\r\n * @param text Unparsed jsaction attribute value.\r\n * @param parsed Attribute value parsed into the action map.\r\n */\nfunction setParsed(text, parsed) {\n  parseCache[text] = parsed;\n}\n/**\r\n * Clears the jsaction parser cache from the given DOM Element.\r\n *\r\n * @param element .\r\n */\nfunction clear(element) {\n  if (JSACTION in element) {\n    delete element[JSACTION];\n  }\n}\n\n/** Added for readability when accessing stable property names. */\nfunction getEventType(eventInfo) {\n  return eventInfo.eventType;\n}\n/** Added for readability when accessing stable property names. */\nfunction setEventType(eventInfo, eventType) {\n  eventInfo.eventType = eventType;\n}\n/** Added for readability when accessing stable property names. */\nfunction getEvent(eventInfo) {\n  return eventInfo.event;\n}\n/** Added for readability when accessing stable property names. */\nfunction setEvent(eventInfo, event) {\n  eventInfo.event = event;\n}\n/** Added for readability when accessing stable property names. */\nfunction getTargetElement(eventInfo) {\n  return eventInfo.targetElement;\n}\n/** Added for readability when accessing stable property names. */\nfunction setTargetElement(eventInfo, targetElement) {\n  eventInfo.targetElement = targetElement;\n}\n/** Added for readability when accessing stable property names. */\nfunction getContainer(eventInfo) {\n  return eventInfo.eic;\n}\n/** Added for readability when accessing stable property names. */\nfunction setContainer(eventInfo, container) {\n  eventInfo.eic = container;\n}\n/** Added for readability when accessing stable property names. */\nfunction getTimestamp(eventInfo) {\n  return eventInfo.timeStamp;\n}\n/** Added for readability when accessing stable property names. */\nfunction setTimestamp(eventInfo, timestamp) {\n  eventInfo.timeStamp = timestamp;\n}\n/** Added for readability when accessing stable property names. */\nfunction getAction(eventInfo) {\n  return eventInfo.eia;\n}\n/** Added for readability when accessing stable property names. */\nfunction setAction(eventInfo, actionName, actionElement) {\n  eventInfo.eia = [actionName, actionElement];\n}\n/** Added for readability when accessing stable property names. */\nfunction unsetAction(eventInfo) {\n  eventInfo.eia = undefined;\n}\n/** Added for readability when accessing stable property names. */\nfunction getActionName(actionInfo) {\n  return actionInfo[0];\n}\n/** Added for readability when accessing stable property names. */\nfunction getActionElement(actionInfo) {\n  return actionInfo[1];\n}\n/** Added for readability when accessing stable property names. */\nfunction getIsReplay(eventInfo) {\n  return eventInfo.eirp;\n}\n/** Added for readability when accessing stable property names. */\nfunction setIsReplay(eventInfo, replay) {\n  eventInfo.eirp = replay;\n}\n/** Added for readability when accessing stable property names. */\nfunction getA11yClickKey(eventInfo) {\n  return eventInfo.eiack;\n}\n/** Added for readability when accessing stable property names. */\nfunction setA11yClickKey(eventInfo, a11yClickKey) {\n  eventInfo.eiack = a11yClickKey;\n}\n/** Added for readability when accessing stable property names. */\nfunction getResolved(eventInfo) {\n  return eventInfo.eir;\n}\n/** Added for readability when accessing stable property names. */\nfunction setResolved(eventInfo, resolved) {\n  eventInfo.eir = resolved;\n}\n/** Clones an `EventInfo` */\nfunction cloneEventInfo(eventInfo) {\n  return {\n    eventType: eventInfo.eventType,\n    event: eventInfo.event,\n    targetElement: eventInfo.targetElement,\n    eic: eventInfo.eic,\n    eia: eventInfo.eia,\n    timeStamp: eventInfo.timeStamp,\n    eirp: eventInfo.eirp,\n    eiack: eventInfo.eiack,\n    eir: eventInfo.eir\n  };\n}\n/**\r\n * Utility function for creating an `EventInfo`.\r\n *\r\n * This can be used from code-size sensitive compilation units, as taking\r\n * parameters vs. an `Object` literal reduces code size.\r\n */\nfunction createEventInfoFromParameters(eventType, event, targetElement, container, timestamp, action, isReplay, a11yClickKey) {\n  return {\n    eventType,\n    event,\n    targetElement,\n    eic: container,\n    timeStamp: timestamp,\n    eia: action,\n    eirp: isReplay,\n    eiack: a11yClickKey\n  };\n}\n/**\r\n * Utility function for creating an `EventInfo`.\r\n *\r\n * This should be used in compilation units that are less sensitive to code\r\n * size.\r\n */\nfunction createEventInfo({\n  eventType,\n  event,\n  targetElement,\n  container,\n  timestamp,\n  action,\n  isReplay,\n  a11yClickKey\n}) {\n  return {\n    eventType,\n    event,\n    targetElement,\n    eic: container,\n    timeStamp: timestamp,\n    eia: action ? [action.name, action.element] : undefined,\n    eirp: isReplay,\n    eiack: a11yClickKey\n  };\n}\n/**\r\n * Utility class around an `EventInfo`.\r\n *\r\n * This should be used in compilation units that are less sensitive to code\r\n * size.\r\n */\nclass EventInfoWrapper {\n  constructor(eventInfo) {\n    this.eventInfo = eventInfo;\n  }\n  getEventType() {\n    return getEventType(this.eventInfo);\n  }\n  setEventType(eventType) {\n    setEventType(this.eventInfo, eventType);\n  }\n  getEvent() {\n    return getEvent(this.eventInfo);\n  }\n  setEvent(event) {\n    setEvent(this.eventInfo, event);\n  }\n  getTargetElement() {\n    return getTargetElement(this.eventInfo);\n  }\n  setTargetElement(targetElement) {\n    setTargetElement(this.eventInfo, targetElement);\n  }\n  getContainer() {\n    return getContainer(this.eventInfo);\n  }\n  setContainer(container) {\n    setContainer(this.eventInfo, container);\n  }\n  getTimestamp() {\n    return getTimestamp(this.eventInfo);\n  }\n  setTimestamp(timestamp) {\n    setTimestamp(this.eventInfo, timestamp);\n  }\n  getAction() {\n    const action = getAction(this.eventInfo);\n    if (!action) return undefined;\n    return {\n      name: action[0],\n      element: action[1]\n    };\n  }\n  setAction(action) {\n    if (!action) {\n      unsetAction(this.eventInfo);\n      return;\n    }\n    setAction(this.eventInfo, action.name, action.element);\n  }\n  getIsReplay() {\n    return getIsReplay(this.eventInfo);\n  }\n  setIsReplay(replay) {\n    setIsReplay(this.eventInfo, replay);\n  }\n  getResolved() {\n    return getResolved(this.eventInfo);\n  }\n  setResolved(resolved) {\n    setResolved(this.eventInfo, resolved);\n  }\n  clone() {\n    return new EventInfoWrapper(cloneEventInfo(this.eventInfo));\n  }\n}\n\n/**\r\n * Determines if one node is contained within another. Adapted from\r\n * {@see goog.dom.contains}.\r\n * @param node Node that should contain otherNode.\r\n * @param otherNode Node being contained.\r\n * @return True if otherNode is contained within node.\r\n */\nfunction contains(node, otherNode) {\n  if (otherNode === null) {\n    return false;\n  }\n  // We use browser specific methods for this if available since it is faster\n  // that way.\n  // IE DOM\n  if ('contains' in node && otherNode.nodeType === 1) {\n    return node.contains(otherNode);\n  }\n  // W3C DOM Level 3\n  if ('compareDocumentPosition' in node) {\n    return node === otherNode || Boolean(node.compareDocumentPosition(otherNode) & 16);\n  }\n  // W3C DOM Level 1\n  while (otherNode && node !== otherNode) {\n    otherNode = otherNode.parentNode;\n  }\n  return otherNode === node;\n}\n/**\r\n * Helper method for broadcastCustomEvent. Returns true if any member of\r\n * the set is an ancestor of element.\r\n */\nfunction hasAncestorInNodeList(element, nodeList) {\n  for (let idx = 0; idx < nodeList.length; ++idx) {\n    const member = nodeList[idx];\n    if (member !== element && contains(member, element)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\r\n * If on a Macintosh with an extended keyboard, the Enter key located in the\r\n * numeric pad has a different ASCII code.\r\n */\nconst MAC_ENTER = 3;\n/** The Enter key. */\nconst ENTER = 13;\n/** The Space key. */\nconst SPACE = 32;\n/** Special keycodes used by jsaction for the generic click action. */\nconst KeyCode = {\n  MAC_ENTER,\n  ENTER,\n  SPACE\n};\n\n/**\r\n * Gets a browser event type, if it would differ from the JSAction event type.\r\n */\nfunction getBrowserEventType(eventType) {\n  // Mouseenter and mouseleave events are not handled directly because they\n  // are not available everywhere. In browsers where they are available, they\n  // don't bubble and aren't visible at the container boundary. Instead, we\n  // synthesize the mouseenter and mouseleave events from mouseover and\n  // mouseout events, respectively. Cf. eventcontract.js.\n  if (eventType === EventType.MOUSEENTER) {\n    return EventType.MOUSEOVER;\n  } else if (eventType === EventType.MOUSELEAVE) {\n    return EventType.MOUSEOUT;\n  } else if (eventType === EventType.POINTERENTER) {\n    return EventType.POINTEROVER;\n  } else if (eventType === EventType.POINTERLEAVE) {\n    return EventType.POINTEROUT;\n  }\n  return eventType;\n}\n/**\r\n * Registers the event handler function with the given DOM element for\r\n * the given event type.\r\n *\r\n * @param element The element.\r\n * @param eventType The event type.\r\n * @param handler The handler function to install.\r\n * @return Information needed to uninstall the event handler eventually.\r\n */\nfunction addEventListener(element, eventType, handler) {\n  // All event handlers are registered in the bubbling\n  // phase.\n  //\n  // All browsers support focus and blur, but these events only are propagated\n  // in the capture phase. Very legacy browsers do not support focusin or\n  // focusout.\n  //\n  // It would be a bad idea to register all event handlers in the\n  // capture phase because then regular onclick handlers would not be\n  // executed at all on events that trigger a jsaction. That's not\n  // entirely what we want, at least for now.\n  //\n  // Error and load events (i.e. on images) do not bubble so they are also\n  // handled in the capture phase.\n  let capture = false;\n  if (isCaptureEvent(eventType)) {\n    capture = true;\n  }\n  element.addEventListener(eventType, handler, capture);\n  return {\n    eventType,\n    handler,\n    capture\n  };\n}\n/**\r\n * Removes the event handler for the given event from the element.\r\n * the given event type.\r\n *\r\n * @param element The element.\r\n * @param info The information needed to deregister the handler, as returned by\r\n *     addEventListener(), above.\r\n */\nfunction removeEventListener(element, info) {\n  if (element.removeEventListener) {\n    element.removeEventListener(info.eventType, info.handler, info.capture);\n    // `detachEvent` is an old DOM API.\n    // tslint:disable-next-line:no-any\n  } else if (element.detachEvent) {\n    // `detachEvent` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    element.detachEvent(`on${info.eventType}`, info.handler);\n  }\n}\n/**\r\n * Cancels propagation of an event.\r\n * @param e The event to cancel propagation for.\r\n */\nfunction stopPropagation(e) {\n  e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;\n}\n/**\r\n * Prevents the default action of an event.\r\n * @param e The event to prevent the default action for.\r\n */\nfunction preventDefault(e) {\n  e.preventDefault ? e.preventDefault() : e.returnValue = false;\n}\n/**\r\n * Gets the target Element of the event. In Firefox, a text node may appear as\r\n * the target of the event, in which case we return the parent element of the\r\n * text node.\r\n * @param e The event to get the target of.\r\n * @return The target element.\r\n */\nfunction getTarget(e) {\n  let el = e.target;\n  // In Firefox, the event may have a text node as its target. We always\n  // want the parent Element the text node belongs to, however.\n  if (!el.getAttribute && el.parentNode) {\n    el = el.parentNode;\n  }\n  return el;\n}\n/**\r\n * Whether we are on a Mac. Not pulling in useragent just for this.\r\n */\nlet isMac = typeof navigator !== 'undefined' && /Macintosh/.test(navigator.userAgent);\n/**\r\n * Determines and returns whether the given event (which is assumed to be a\r\n * click event) is a middle click.\r\n * NOTE: There is not a consistent way to identify middle click\r\n * http://www.unixpapa.com/js/mouse.html\r\n */\nfunction isMiddleClick(e) {\n  return (\n    // `which` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.which === 2 ||\n    // `which` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.which == null &&\n    // `button` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.button === 4 // middle click for IE\n  );\n}\n/**\r\n * Determines and returns whether the given event (which is assumed\r\n * to be a click event) is modified. A middle click is considered a modified\r\n * click to retain the default browser action, which opens a link in a new tab.\r\n * @param e The event.\r\n * @return Whether the given event is modified.\r\n */\nfunction isModifiedClickEvent(e) {\n  return (\n    // `metaKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    isMac && e.metaKey ||\n    // `ctrlKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    !isMac && e.ctrlKey || isMiddleClick(e) ||\n    // `shiftKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.shiftKey\n  );\n}\n/** Whether we are on WebKit (e.g., Chrome). */\nconst isWebKit = typeof navigator !== 'undefined' && !/Opera/.test(navigator.userAgent) && /WebKit/.test(navigator.userAgent);\n/** Whether we are on IE. */\nconst isIe = typeof navigator !== 'undefined' && (/MSIE/.test(navigator.userAgent) || /Trident/.test(navigator.userAgent));\n/** Whether we are on Gecko (e.g., Firefox). */\nconst isGecko = typeof navigator !== 'undefined' && !/Opera|WebKit/.test(navigator.userAgent) && /Gecko/.test(navigator.product);\n/**\r\n * Determines and returns whether the given element is a valid target for\r\n * keypress/keydown DOM events that act like regular DOM clicks.\r\n * @param el The element.\r\n * @return Whether the given element is a valid action key target.\r\n */\nfunction isValidActionKeyTarget(el) {\n  if (!('getAttribute' in el)) {\n    return false;\n  }\n  if (isTextControl(el)) {\n    return false;\n  }\n  if (isNativelyActivatable(el)) {\n    return false;\n  }\n  // `isContentEditable` is an old DOM API.\n  // tslint:disable-next-line:no-any\n  if (el.isContentEditable) {\n    return false;\n  }\n  return true;\n}\n/**\r\n * Whether an event has a modifier key activated.\r\n * @param e The event.\r\n * @return True, if a modifier key is activated.\r\n */\nfunction hasModifierKey(e) {\n  return (\n    // `ctrlKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.ctrlKey ||\n    // `shiftKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.shiftKey ||\n    // `altKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.altKey ||\n    // `metaKey` is an old DOM API.\n    // tslint:disable-next-line:no-any\n    e.metaKey\n  );\n}\n/**\r\n * Determines and returns whether the given event has a target that already\r\n * has event handlers attached because it is a native HTML control. Used to\r\n * determine if preventDefault should be called when isActionKeyEvent is true.\r\n * @param e The event.\r\n * @return If preventDefault should be called.\r\n */\nfunction shouldCallPreventDefaultOnNativeHtmlControl(e) {\n  const el = getTarget(e);\n  const tagName = el.tagName.toUpperCase();\n  const role = (el.getAttribute('role') || '').toUpperCase();\n  if (tagName === 'BUTTON' || role === 'BUTTON') {\n    return true;\n  }\n  if (!isNativeHTMLControl(el)) {\n    return false;\n  }\n  if (tagName === 'A') {\n    return false;\n  }\n  /**\r\n   * Fix for physical d-pads on feature phone platforms; the native event\r\n   * (ie. isTrusted: true) needs to fire to show the OPTION list. See\r\n   * b/135288469 for more info.\r\n   */\n  if (tagName === 'SELECT') {\n    return false;\n  }\n  if (processSpace(el)) {\n    return false;\n  }\n  if (isTextControl(el)) {\n    return false;\n  }\n  return true;\n}\n/**\r\n * Determines and returns whether the given event acts like a regular DOM click,\r\n * and should be handled instead of the click.  If this returns true, the caller\r\n * will call preventDefault() to prevent a possible duplicate event.\r\n * This is represented by a keypress (keydown on Gecko browsers) on Enter or\r\n * Space key.\r\n * @param e The event.\r\n * @return True, if the event emulates a DOM click.\r\n */\nfunction isActionKeyEvent(e) {\n  let key =\n  // `which` is an old DOM API.\n  // tslint:disable-next-line:no-any\n  e.which ||\n  // `keyCode` is an old DOM API.\n  // tslint:disable-next-line:no-any\n  e.keyCode;\n  if (!key && e.key) {\n    key = ACTION_KEY_TO_KEYCODE[e.key];\n  }\n  if (isWebKit && key === KeyCode.MAC_ENTER) {\n    key = KeyCode.ENTER;\n  }\n  if (key !== KeyCode.ENTER && key !== KeyCode.SPACE) {\n    return false;\n  }\n  const el = getTarget(e);\n  if (e.type !== EventType.KEYDOWN || !isValidActionKeyTarget(el) || hasModifierKey(e)) {\n    return false;\n  }\n  // For <input type=\"checkbox\">, we must only handle the browser's native click\n  // event, so that the browser can toggle the checkbox.\n  if (processSpace(el) && key === KeyCode.SPACE) {\n    return false;\n  }\n  // If this element is non-focusable, ignore stray keystrokes (b/18337209)\n  // Sscreen readers can move without tab focus, so any tabIndex is focusable.\n  // See B/21809604\n  if (!isFocusable(el)) {\n    return false;\n  }\n  const type = (el.getAttribute('role') || el.type || el.tagName).toUpperCase();\n  const isSpecificTriggerKey = IDENTIFIER_TO_KEY_TRIGGER_MAPPING[type] % key === 0;\n  const isDefaultTriggerKey = !(type in IDENTIFIER_TO_KEY_TRIGGER_MAPPING) && key === KeyCode.ENTER;\n  const hasType = el.tagName.toUpperCase() !== 'INPUT' || !!el.type;\n  return (isSpecificTriggerKey || isDefaultTriggerKey) && hasType;\n}\n/**\r\n * Checks whether a DOM element can receive keyboard focus.\r\n * This code is based on goog.dom.isFocusable, but simplified since we shouldn't\r\n * care about visibility if we're already handling a keyboard event.\r\n */\nfunction isFocusable(el) {\n  return (el.tagName in NATIVELY_FOCUSABLE_ELEMENTS || hasSpecifiedTabIndex(el)) && !el.disabled;\n}\n/**\r\n * @param element Element to check.\r\n * @return Whether the element has a specified tab index.\r\n */\nfunction hasSpecifiedTabIndex(element) {\n  // IE returns 0 for an unset tabIndex, so we must use getAttributeNode(),\n  // which returns an object with a 'specified' property if tabIndex is\n  // specified.  This works on other browsers, too.\n  const attrNode = element.getAttributeNode('tabindex'); // Must be lowercase!\n  return attrNode != null && attrNode.specified;\n}\n/** Element tagnames that are focusable by default. */\nconst NATIVELY_FOCUSABLE_ELEMENTS = {\n  'A': 1,\n  'INPUT': 1,\n  'TEXTAREA': 1,\n  'SELECT': 1,\n  'BUTTON': 1\n};\n/** @return True, if the Space key was pressed. */\nfunction isSpaceKeyEvent(e) {\n  const key =\n  // `which` is an old DOM API.\n  // tslint:disable-next-line:no-any\n  e.which ||\n  // `keyCode` is an old DOM API.\n  // tslint:disable-next-line:no-any\n  e.keyCode;\n  const el = getTarget(e);\n  const elementName = (el.type || el.tagName).toUpperCase();\n  return key === KeyCode.SPACE && elementName !== 'CHECKBOX';\n}\n/**\r\n * Determines whether the event corresponds to a non-bubbling mouse\r\n * event type (mouseenter, mouseleave, pointerenter, and pointerleave).\r\n *\r\n * During mouseover (mouseenter) and pointerover (pointerenter), the\r\n * relatedTarget is the element being entered from. During mouseout (mouseleave)\r\n * and pointerout (pointerleave), the relatedTarget is the element being exited\r\n * to.\r\n *\r\n * In both cases, if relatedTarget is outside target, then the corresponding\r\n * special event has occurred, otherwise it hasn't.\r\n *\r\n * @param e The mouseover/mouseout event.\r\n * @param type The type of the mouse special event.\r\n * @param element The element on which the jsaction for the\r\n *     mouseenter/mouseleave event is defined.\r\n * @return True if the event is a mouseenter/mouseleave event.\r\n */\nfunction isMouseSpecialEvent(e, type, element) {\n  // `relatedTarget` is an old DOM API.\n  // tslint:disable-next-line:no-any\n  const related = e.relatedTarget;\n  return (e.type === EventType.MOUSEOVER && type === EventType.MOUSEENTER || e.type === EventType.MOUSEOUT && type === EventType.MOUSELEAVE || e.type === EventType.POINTEROVER && type === EventType.POINTERENTER || e.type === EventType.POINTEROUT && type === EventType.POINTERLEAVE) && (!related || related !== element && !contains(element, related));\n}\n/**\r\n * Creates a new EventLike object for a mouseenter/mouseleave event that's\r\n * derived from the original corresponding mouseover/mouseout event.\r\n * @param e The event.\r\n * @param target The element on which the jsaction for the mouseenter/mouseleave\r\n *     event is defined.\r\n * @return A modified event-like object copied from the event object passed into\r\n *     this function.\r\n */\nfunction createMouseSpecialEvent(e, target) {\n  // We have to create a copy of the event object because we need to mutate\n  // its fields. We do this for the special mouse events because the event\n  // target needs to be retargeted to the action element rather than the real\n  // element (since we are simulating the special mouse events with mouseover/\n  // mouseout).\n  //\n  // Since we're making a copy anyways, we might as well attempt to convert\n  // this event into a pseudo-real mouseenter/mouseleave event by adjusting\n  // its type.\n  //\n  // tslint:disable-next-line:no-any\n  const copy = {};\n  for (const property in e) {\n    if (property === 'srcElement' || property === 'target') {\n      continue;\n    }\n    const key = property;\n    // Making a copy requires iterating through all properties of `Event`.\n    // tslint:disable-next-line:no-dict-access-on-struct-type\n    const value = e[key];\n    if (typeof value === 'function') {\n      continue;\n    }\n    // Value should be the expected type, but the value of `key` is not known\n    // statically.\n    // tslint:disable-next-line:no-any\n    copy[key] = value;\n  }\n  if (e.type === EventType.MOUSEOVER) {\n    copy['type'] = EventType.MOUSEENTER;\n  } else if (e.type === EventType.MOUSEOUT) {\n    copy['type'] = EventType.MOUSELEAVE;\n  } else if (e.type === EventType.POINTEROVER) {\n    copy['type'] = EventType.POINTERENTER;\n  } else {\n    copy['type'] = EventType.POINTERLEAVE;\n  }\n  copy['target'] = copy['srcElement'] = target;\n  copy['bubbles'] = false;\n  return copy;\n}\n/**\r\n * Returns touch data extracted from the touch event: clientX, clientY, screenX\r\n * and screenY. If the event has no touch information at all, the returned\r\n * value is null.\r\n *\r\n * The fields of this Object are unquoted.\r\n *\r\n * @param event A touch event.\r\n */\nfunction getTouchData(event) {\n  const touch = event.changedTouches && event.changedTouches[0] || event.touches && event.touches[0];\n  if (!touch) {\n    return null;\n  }\n  return {\n    clientX: touch.clientX,\n    clientY: touch.clientY,\n    screenX: touch.screenX,\n    screenY: touch.screenY\n  };\n}\n/**\r\n * Creates a new EventLike object for a \"click\" event that's derived from the\r\n * original corresponding \"touchend\" event for a fast-click implementation.\r\n *\r\n * It takes a touch event, adds common fields found in a click event and\r\n * changes the type to 'click', so that the resulting event looks more like\r\n * a real click event.\r\n *\r\n * @param event A touch event.\r\n * @return A modified event-like object copied from the event object passed into\r\n *     this function.\r\n */\nfunction recreateTouchEventAsClick(event) {\n  const click = {};\n  click['originalEventType'] = event.type;\n  click['type'] = EventType.CLICK;\n  for (const property in event) {\n    if (property === 'type' || property === 'srcElement') {\n      continue;\n    }\n    const key = property;\n    // Making a copy requires iterating through all properties of `TouchEvent`.\n    // tslint:disable-next-line:no-dict-access-on-struct-type\n    const value = event[key];\n    if (typeof value === 'function') {\n      continue;\n    }\n    // Value should be the expected type, but the value of `key` is not known\n    // statically.\n    // tslint:disable-next-line:no-any\n    click[key] = value;\n  }\n  // Ensure that the event has the most recent timestamp. This timestamp\n  // may be used in the future to validate or cancel subsequent click events.\n  click['timeStamp'] = Date.now();\n  // Emulate preventDefault and stopPropagation behavior\n  click['defaultPrevented'] = false;\n  click['preventDefault'] = syntheticPreventDefault;\n  click['_propagationStopped'] = false;\n  click['stopPropagation'] = syntheticStopPropagation;\n  // Emulate click coordinates using touch info\n  const touch = getTouchData(event);\n  if (touch) {\n    click['clientX'] = touch.clientX;\n    click['clientY'] = touch.clientY;\n    click['screenX'] = touch.screenX;\n    click['screenY'] = touch.screenY;\n  }\n  return click;\n}\n/**\r\n * An implementation of \"preventDefault\" for a synthesized event. Simply\r\n * sets \"defaultPrevented\" property to true.\r\n */\nfunction syntheticPreventDefault() {\n  this.defaultPrevented = true;\n}\n/**\r\n * An implementation of \"stopPropagation\" for a synthesized event. It simply\r\n * sets a synthetic non-standard \"_propagationStopped\" property to true.\r\n */\nfunction syntheticStopPropagation() {\n  this._propagationStopped = true;\n}\n/**\r\n * Mapping of KeyboardEvent.key values to\r\n * KeyCode values.\r\n */\nconst ACTION_KEY_TO_KEYCODE = {\n  'Enter': KeyCode.ENTER,\n  ' ': KeyCode.SPACE\n};\n/**\r\n * Mapping of HTML element identifiers (ARIA role, type, or tagName) to the\r\n * keys (enter and/or space) that should activate them. A value of zero means\r\n * that both should activate them.\r\n */\nconst IDENTIFIER_TO_KEY_TRIGGER_MAPPING = {\n  'A': KeyCode.ENTER,\n  'BUTTON': 0,\n  'CHECKBOX': KeyCode.SPACE,\n  'COMBOBOX': KeyCode.ENTER,\n  'FILE': 0,\n  'GRIDCELL': KeyCode.ENTER,\n  'LINK': KeyCode.ENTER,\n  'LISTBOX': KeyCode.ENTER,\n  'MENU': 0,\n  'MENUBAR': 0,\n  'MENUITEM': 0,\n  'MENUITEMCHECKBOX': 0,\n  'MENUITEMRADIO': 0,\n  'OPTION': 0,\n  'RADIO': KeyCode.SPACE,\n  'RADIOGROUP': KeyCode.SPACE,\n  'RESET': 0,\n  'SUBMIT': 0,\n  'SWITCH': KeyCode.SPACE,\n  'TAB': 0,\n  'TREE': KeyCode.ENTER,\n  'TREEITEM': KeyCode.ENTER\n};\n/**\r\n * Returns whether or not to process space based on the type of the element;\r\n * checks to make sure that type is not null.\r\n * @param element The element.\r\n * @return Whether or not to process space based on type.\r\n */\nfunction processSpace(element) {\n  const type = (element.getAttribute('type') || element.tagName).toUpperCase();\n  return type in PROCESS_SPACE;\n}\n/**\r\n * Returns whether or not the given element is a text control.\r\n * @param el The element.\r\n * @return Whether or not the given element is a text control.\r\n */\nfunction isTextControl(el) {\n  const type = (el.getAttribute('type') || el.tagName).toUpperCase();\n  return type in TEXT_CONTROLS;\n}\n/**\r\n * Returns if the given element is a native HTML control.\r\n * @param el The element.\r\n * @return If the given element is a native HTML control.\r\n */\nfunction isNativeHTMLControl(el) {\n  return el.tagName.toUpperCase() in NATIVE_HTML_CONTROLS;\n}\n/**\r\n * Returns if the given element is natively activatable. Browsers emit click\r\n * events for natively activatable elements, even when activated via keyboard.\r\n * For these elements, we don't need to raise a11y click events.\r\n * @param el The element.\r\n * @return If the given element is a native HTML control.\r\n */\nfunction isNativelyActivatable(el) {\n  return el.tagName.toUpperCase() === 'BUTTON' || !!el.type && el.type.toUpperCase() === 'FILE';\n}\n/**\r\n * HTML <input> types (not ARIA roles) which will auto-trigger a click event for\r\n * the Space key, with side-effects. We will not call preventDefault if space is\r\n * pressed, nor will we raise a11y click events.  For all other elements, we can\r\n * suppress the default event (which has no desired side-effects) and handle the\r\n * keydown ourselves.\r\n */\nconst PROCESS_SPACE = {\n  'CHECKBOX': true,\n  'FILE': true,\n  'OPTION': true,\n  'RADIO': true\n};\n/** TagNames and Input types for which to not process enter/space as click. */\nconst TEXT_CONTROLS = {\n  'COLOR': true,\n  'DATE': true,\n  'DATETIME': true,\n  'DATETIME-LOCAL': true,\n  'EMAIL': true,\n  'MONTH': true,\n  'NUMBER': true,\n  'PASSWORD': true,\n  'RANGE': true,\n  'SEARCH': true,\n  'TEL': true,\n  'TEXT': true,\n  'TEXTAREA': true,\n  'TIME': true,\n  'URL': true,\n  'WEEK': true\n};\n/** TagNames that are native HTML controls. */\nconst NATIVE_HTML_CONTROLS = {\n  'A': true,\n  'AREA': true,\n  'BUTTON': true,\n  'DIALOG': true,\n  'IMG': true,\n  'INPUT': true,\n  'LINK': true,\n  'MENU': true,\n  'OPTGROUP': true,\n  'OPTION': true,\n  'PROGRESS': true,\n  'SELECT': true,\n  'TEXTAREA': true\n};\n/** Exported for testing. */\nconst testing = {\n  setIsMac(value) {\n    isMac = value;\n  }\n};\n\n/**\r\n * Since maps from event to action are immutable we can use a single map\r\n * to represent the empty map.\r\n */\nconst EMPTY_ACTION_MAP = {};\n/**\r\n * This regular expression matches a semicolon.\r\n */\nconst REGEXP_SEMICOLON = /\\s*;\\s*/;\n/** If no event type is defined, defaults to `click`. */\nconst DEFAULT_EVENT_TYPE = EventType.CLICK;\n/** Resolves actions for Events. */\nclass ActionResolver {\n  constructor({\n    syntheticMouseEventSupport = false\n  } = {}) {\n    this.a11yClickSupport = false;\n    this.updateEventInfoForA11yClick = undefined;\n    this.preventDefaultForA11yClick = undefined;\n    this.populateClickOnlyAction = undefined;\n    this.syntheticMouseEventSupport = syntheticMouseEventSupport;\n  }\n  resolveEventType(eventInfo) {\n    // We distinguish modified and plain clicks in order to support the\n    // default browser behavior of modified clicks on links; usually to\n    // open the URL of the link in new tab or new window on ctrl/cmd\n    // click. A DOM 'click' event is mapped to the jsaction 'click'\n    // event iff there is no modifier present on the event. If there is\n    // a modifier, it's mapped to 'clickmod' instead.\n    //\n    // It's allowed to omit the event in the jsaction attribute. In that\n    // case, 'click' is assumed. Thus the following two are equivalent:\n    //\n    //   <a href=\"someurl\" jsaction=\"gna.fu\">\n    //   <a href=\"someurl\" jsaction=\"click:gna.fu\">\n    //\n    // For unmodified clicks, EventContract invokes the jsaction\n    // 'gna.fu'. For modified clicks, EventContract won't find a\n    // suitable action and leave the event to be handled by the\n    // browser.\n    //\n    // In order to also invoke a jsaction handler for a modifier click,\n    // 'clickmod' needs to be used:\n    //\n    //   <a href=\"someurl\" jsaction=\"clickmod:gna.fu\">\n    //\n    // EventContract invokes the jsaction 'gna.fu' for modified\n    // clicks. Unmodified clicks are left to the browser.\n    //\n    // In order to set up the event contract to handle both clickonly and\n    // clickmod, only addEvent(EventType.CLICK) is necessary.\n    //\n    // In order to set up the event contract to handle click,\n    // addEvent() is necessary for CLICK, KEYDOWN, and KEYPRESS event types.  If\n    // a11y click support is enabled, addEvent() will set up the appropriate key\n    // event handler automatically.\n    if (getEventType(eventInfo) === EventType.CLICK && isModifiedClickEvent(getEvent(eventInfo))) {\n      setEventType(eventInfo, EventType.CLICKMOD);\n    } else if (this.a11yClickSupport) {\n      this.updateEventInfoForA11yClick(eventInfo);\n    }\n  }\n  resolveAction(eventInfo) {\n    if (getResolved(eventInfo)) {\n      return;\n    }\n    this.populateAction(eventInfo, getTargetElement(eventInfo));\n    setResolved(eventInfo, true);\n  }\n  resolveParentAction(eventInfo) {\n    const action = getAction(eventInfo);\n    const actionElement = action && getActionElement(action);\n    unsetAction(eventInfo);\n    const parentNode = actionElement && this.getParentNode(actionElement);\n    if (!parentNode) {\n      return;\n    }\n    this.populateAction(eventInfo, parentNode);\n  }\n  /**\r\n   * Searches for a jsaction that the DOM event maps to and creates an\r\n   * object containing event information used for dispatching by\r\n   * jsaction.Dispatcher. This method populates the `action` and `actionElement`\r\n   * fields of the EventInfo object passed in by finding the first\r\n   * jsaction attribute above the target Node of the event, and below\r\n   * the container Node, that specifies a jsaction for the event\r\n   * type. If no such jsaction is found, then action is undefined.\r\n   *\r\n   * @param eventInfo `EventInfo` to set `action` and `actionElement` if an\r\n   *    action is found on any `Element` in the path of the `Event`.\r\n   */\n  populateAction(eventInfo, currentTarget) {\n    let actionElement = currentTarget;\n    while (actionElement && actionElement !== getContainer(eventInfo)) {\n      if (actionElement.nodeType === Node.ELEMENT_NODE) {\n        this.populateActionOnElement(actionElement, eventInfo);\n      }\n      if (getAction(eventInfo)) {\n        // An event is handled by at most one jsaction. Thus we stop at the\n        // first matching jsaction specified in a jsaction attribute up the\n        // ancestor chain of the event target node.\n        break;\n      }\n      actionElement = this.getParentNode(actionElement);\n    }\n    const action = getAction(eventInfo);\n    if (!action) {\n      // No action found.\n      return;\n    }\n    if (this.a11yClickSupport) {\n      this.preventDefaultForA11yClick(eventInfo);\n    }\n    // We attempt to handle the mouseenter/mouseleave events here by\n    // detecting whether the mouseover/mouseout events correspond to\n    // entering/leaving an element.\n    if (this.syntheticMouseEventSupport) {\n      if (getEventType(eventInfo) === EventType.MOUSEENTER || getEventType(eventInfo) === EventType.MOUSELEAVE || getEventType(eventInfo) === EventType.POINTERENTER || getEventType(eventInfo) === EventType.POINTERLEAVE) {\n        // We attempt to handle the mouseenter/mouseleave events here by\n        // detecting whether the mouseover/mouseout events correspond to\n        // entering/leaving an element.\n        if (isMouseSpecialEvent(getEvent(eventInfo), getEventType(eventInfo), getActionElement(action))) {\n          // If both mouseover/mouseout and mouseenter/mouseleave events are\n          // enabled, two separate handlers for mouseover/mouseout are\n          // registered. Both handlers will see the same event instance\n          // so we create a copy to avoid interfering with the dispatching of\n          // the mouseover/mouseout event.\n          const copiedEvent = createMouseSpecialEvent(getEvent(eventInfo), getActionElement(action));\n          setEvent(eventInfo, copiedEvent);\n          // Since the mouseenter/mouseleave events do not bubble, the target\n          // of the event is technically the `actionElement` (the node with the\n          // `jsaction` attribute)\n          setTargetElement(eventInfo, getActionElement(action));\n        } else {\n          unsetAction(eventInfo);\n        }\n      }\n    }\n  }\n  /**\r\n   * Walk to the parent node, unless the node has a different owner in\r\n   * which case we walk to the owner. Attempt to walk to host of a\r\n   * shadow root if needed.\r\n   */\n  getParentNode(element) {\n    const owner = element[OWNER];\n    if (owner) {\n      return owner;\n    }\n    const parentNode = element.parentNode;\n    if (parentNode?.nodeName === '#document-fragment') {\n      return parentNode?.host ?? null;\n    }\n    return parentNode;\n  }\n  /**\r\n   * Accesses the jsaction map on a node and retrieves the name of the\r\n   * action the given event is mapped to, if any. It parses the\r\n   * attribute value and stores it in a property on the node for\r\n   * subsequent retrieval without re-parsing and re-accessing the\r\n   * attribute.\r\n   *\r\n   * @param actionElement The DOM node to retrieve the jsaction map from.\r\n   * @param eventInfo `EventInfo` to set `action` and `actionElement` if an\r\n   *    action is found on the `actionElement`.\r\n   */\n  populateActionOnElement(actionElement, eventInfo) {\n    const actionMap = this.parseActions(actionElement);\n    const actionName = actionMap[getEventType(eventInfo)];\n    if (actionName !== undefined) {\n      setAction(eventInfo, actionName, actionElement);\n    }\n    if (this.a11yClickSupport) {\n      this.populateClickOnlyAction(actionElement, eventInfo, actionMap);\n    }\n  }\n  /**\r\n   * Parses and caches an element's jsaction element into a map.\r\n   *\r\n   * This is primarily for internal use.\r\n   *\r\n   * @param actionElement The DOM node to retrieve the jsaction map from.\r\n   * @return Map from event to qualified name of the jsaction bound to it.\r\n   */\n  parseActions(actionElement) {\n    let actionMap = get(actionElement);\n    if (!actionMap) {\n      const jsactionAttribute = actionElement.getAttribute(Attribute.JSACTION);\n      if (!jsactionAttribute) {\n        actionMap = EMPTY_ACTION_MAP;\n        set(actionElement, actionMap);\n      } else {\n        actionMap = getParsed(jsactionAttribute);\n        if (!actionMap) {\n          actionMap = {};\n          const values = jsactionAttribute.split(REGEXP_SEMICOLON);\n          for (let idx = 0; idx < values.length; idx++) {\n            const value = values[idx];\n            if (!value) {\n              continue;\n            }\n            const colon = value.indexOf(Char.EVENT_ACTION_SEPARATOR);\n            const hasColon = colon !== -1;\n            const type = hasColon ? value.substr(0, colon).trim() : DEFAULT_EVENT_TYPE;\n            const action = hasColon ? value.substr(colon + 1).trim() : value;\n            actionMap[type] = action;\n          }\n          setParsed(jsactionAttribute, actionMap);\n        }\n        set(actionElement, actionMap);\n      }\n    }\n    return actionMap;\n  }\n  addA11yClickSupport(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction) {\n    this.a11yClickSupport = true;\n    this.updateEventInfoForA11yClick = updateEventInfoForA11yClick;\n    this.preventDefaultForA11yClick = preventDefaultForA11yClick;\n    this.populateClickOnlyAction = populateClickOnlyAction;\n  }\n}\n\n/**\r\n * @fileoverview An enum to control who can call certain jsaction APIs.\r\n */\nvar Restriction;\n(function (Restriction) {\n  Restriction[Restriction[\"I_AM_THE_JSACTION_FRAMEWORK\"] = 0] = \"I_AM_THE_JSACTION_FRAMEWORK\";\n})(Restriction || (Restriction = {}));\n\n/**\r\n * Receives a DOM event, determines the jsaction associated with the source\r\n * element of the DOM event, and invokes the handler associated with the\r\n * jsaction.\r\n */\nclass Dispatcher {\n  /**\r\n   * Options are:\r\n   *   - `eventReplayer`: When the event contract dispatches replay events\r\n   *      to the Dispatcher, the Dispatcher collects them and in the next tick\r\n   *      dispatches them to the `eventReplayer`. Defaults to dispatching to `dispatchDelegate`.\r\n   * @param dispatchDelegate A function that should handle dispatching an `EventInfoWrapper` to handlers.\r\n   */\n  constructor(dispatchDelegate, {\n    actionResolver,\n    eventReplayer\n  } = {}) {\n    this.dispatchDelegate = dispatchDelegate;\n    /** Whether the event replay is scheduled. */\n    this.eventReplayScheduled = false;\n    /** The queue of events. */\n    this.replayEventInfoWrappers = [];\n    this.actionResolver = actionResolver;\n    this.eventReplayer = eventReplayer;\n  }\n  /**\r\n   * Receives an event or the event queue from the EventContract. The event\r\n   * queue is copied and it attempts to replay.\r\n   * If event info is passed in it looks for an action handler that can handle\r\n   * the given event.  If there is no handler registered queues the event and\r\n   * checks if a loader is registered for the given namespace. If so, calls it.\r\n   *\r\n   * Alternatively, if in global dispatch mode, calls all registered global\r\n   * handlers for the appropriate event type.\r\n   *\r\n   * The three functionalities of this call are deliberately not split into\r\n   * three methods (and then declared as an abstract interface), because the\r\n   * interface is used by EventContract, which lives in a different jsbinary.\r\n   * Therefore the interface between the three is defined entirely in terms that\r\n   * are invariant under jscompiler processing (Function and Array, as opposed\r\n   * to a custom type with method names).\r\n   *\r\n   * @param eventInfo The info for the event that triggered this call or the\r\n   *     queue of events from EventContract.\r\n   */\n  dispatch(eventInfo) {\n    const eventInfoWrapper = new EventInfoWrapper(eventInfo);\n    this.actionResolver?.resolveEventType(eventInfo);\n    this.actionResolver?.resolveAction(eventInfo);\n    const action = eventInfoWrapper.getAction();\n    if (action && shouldPreventDefaultBeforeDispatching(action.element, eventInfoWrapper)) {\n      preventDefault(eventInfoWrapper.getEvent());\n    }\n    if (this.eventReplayer && eventInfoWrapper.getIsReplay()) {\n      this.scheduleEventInfoWrapperReplay(eventInfoWrapper);\n      return;\n    }\n    this.dispatchDelegate(eventInfoWrapper);\n  }\n  /**\r\n   * Schedules an `EventInfoWrapper` for replay. The replaying will happen in its own\r\n   * stack once the current flow cedes control. This is done to mimic\r\n   * browser event handling.\r\n   */\n  scheduleEventInfoWrapperReplay(eventInfoWrapper) {\n    this.replayEventInfoWrappers.push(eventInfoWrapper);\n    if (this.eventReplayScheduled) {\n      return;\n    }\n    this.eventReplayScheduled = true;\n    Promise.resolve().then(() => {\n      this.eventReplayScheduled = false;\n      this.eventReplayer(this.replayEventInfoWrappers);\n    });\n  }\n}\n/**\r\n * Creates an `EventReplayer` that calls the `replay` function for every `eventInfoWrapper` in\r\n * the queue.\r\n */\nfunction createEventReplayer(replay) {\n  return eventInfoWrappers => {\n    for (const eventInfoWrapper of eventInfoWrappers) {\n      replay(eventInfoWrapper);\n    }\n  };\n}\n/**\r\n * Returns true if the default action of this event should be prevented before\r\n * this event is dispatched.\r\n */\nfunction shouldPreventDefaultBeforeDispatching(actionElement, eventInfoWrapper) {\n  // Prevent browser from following <a> node links if a jsaction is present\n  // and we are dispatching the action now. Note that the targetElement may be\n  // a child of an anchor that has a jsaction attached. For that reason, we\n  // need to check the actionElement rather than the targetElement.\n  return actionElement.tagName === 'A' && eventInfoWrapper.getEventType() === EventType.CLICK || eventInfoWrapper.getEventType() === EventType.CLICKMOD;\n}\n/**\r\n * Registers deferred functionality for an EventContract and a Jsaction\r\n * Dispatcher.\r\n */\nfunction registerDispatcher$1(eventContract, dispatcher) {\n  eventContract.ecrd(eventInfo => {\n    dispatcher.dispatch(eventInfo);\n  }, Restriction.I_AM_THE_JSACTION_FRAMEWORK);\n}\n\n/** An internal symbol used to indicate whether propagation should be stopped or not. */\nconst PROPAGATION_STOPPED_SYMBOL = Symbol.for('propagationStopped');\n/** Extra event phases beyond what the browser provides. */\nconst EventPhase = {\n  REPLAY: 101\n};\nconst PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser dispatch, `preventDefault` would have no ' + 'effect. You can check whether an event is being replayed by accessing the event phase: ' + '`event.eventPhase === EventPhase.REPLAY`.';\nconst PREVENT_DEFAULT_ERROR_MESSAGE = `\\`preventDefault\\` called during event replay.`;\nconst COMPOSED_PATH_ERROR_MESSAGE_DETAILS = () => ngDevMode ? ' Because event replay occurs after browser ' + 'dispatch, `composedPath()` will be empty. Iterate parent nodes from `event.target` or ' + '`event.currentTarget` if you need to check elements in the event path.' : '';\nconst COMPOSED_PATH_ERROR_MESSAGE = `\\`composedPath\\` called during event replay.`;\n/**\r\n * A dispatcher that uses browser-based `Event` semantics, for example bubbling, `stopPropagation`,\r\n * `currentTarget`, etc.\r\n */\nclass EventDispatcher {\n  constructor(dispatchDelegate) {\n    this.dispatchDelegate = dispatchDelegate;\n    this.actionResolver = new ActionResolver();\n    this.dispatcher = new Dispatcher(eventInfoWrapper => {\n      this.dispatchToDelegate(eventInfoWrapper);\n    }, {\n      actionResolver: this.actionResolver\n    });\n  }\n  /**\r\n   * The entrypoint for the `EventContract` dispatch.\r\n   */\n  dispatch(eventInfo) {\n    this.dispatcher.dispatch(eventInfo);\n  }\n  /** Internal method that does basic disaptching. */\n  dispatchToDelegate(eventInfoWrapper) {\n    if (eventInfoWrapper.getIsReplay()) {\n      prepareEventForReplay(eventInfoWrapper);\n    }\n    prepareEventForBubbling(eventInfoWrapper);\n    while (eventInfoWrapper.getAction()) {\n      prepareEventForDispatch(eventInfoWrapper);\n      this.dispatchDelegate(eventInfoWrapper.getEvent(), eventInfoWrapper.getAction().name);\n      if (propagationStopped(eventInfoWrapper)) {\n        return;\n      }\n      this.actionResolver.resolveParentAction(eventInfoWrapper.eventInfo);\n    }\n  }\n}\nfunction prepareEventForBubbling(eventInfoWrapper) {\n  const event = eventInfoWrapper.getEvent();\n  const stopPropagation = () => {\n    event[PROPAGATION_STOPPED_SYMBOL] = true;\n  };\n  patchEventInstance(event, 'stopPropagation', stopPropagation);\n  patchEventInstance(event, 'stopImmediatePropagation', stopPropagation);\n}\nfunction propagationStopped(eventInfoWrapper) {\n  const event = eventInfoWrapper.getEvent();\n  return !!event[PROPAGATION_STOPPED_SYMBOL];\n}\nfunction prepareEventForReplay(eventInfoWrapper) {\n  const event = eventInfoWrapper.getEvent();\n  const target = eventInfoWrapper.getTargetElement();\n  patchEventInstance(event, 'target', target);\n  patchEventInstance(event, 'eventPhase', EventPhase.REPLAY);\n  patchEventInstance(event, 'preventDefault', () => {\n    throw new Error(PREVENT_DEFAULT_ERROR_MESSAGE + (ngDevMode ? PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS : ''));\n  });\n  patchEventInstance(event, 'composedPath', () => {\n    throw new Error(COMPOSED_PATH_ERROR_MESSAGE + (ngDevMode ? COMPOSED_PATH_ERROR_MESSAGE_DETAILS : ''));\n  });\n}\nfunction prepareEventForDispatch(eventInfoWrapper) {\n  const event = eventInfoWrapper.getEvent();\n  const currentTarget = eventInfoWrapper.getAction()?.element;\n  if (currentTarget) {\n    patchEventInstance(event, 'currentTarget', currentTarget, {\n      // `currentTarget` is going to get reassigned every dispatch.\n      configurable: true\n    });\n  }\n}\n/**\r\n * Patch `Event` instance during non-standard `Event` dispatch. This patches just the `Event`\r\n * instance that the browser created, it does not patch global properties or methods.\r\n *\r\n * This is necessary because dispatching an `Event` outside of browser dispatch results in\r\n * incorrect properties and methods that need to be polyfilled or do not work.\r\n *\r\n * JSAction dispatch adds two extra \"phases\" to event dispatch:\r\n * 1. Event delegation - the event is being dispatched by a delegating event handler on a container\r\n *    (typically `window.document.documentElement`), to a delegated event handler on some child\r\n *    element. Certain `Event` properties will be unintuitive, such as `currentTarget`, which would\r\n *    be the container rather than the child element. Bubbling would also not work. In order to\r\n *    emulate the browser, these properties and methods on the `Event` are patched.\r\n * 2. Event replay - the event is being dispatched by the framework once the handlers have been\r\n *    loaded (during hydration, or late-loaded). Certain `Event` properties can be unset by the\r\n *    browser because the `Event` is no longer actively being dispatched, such as `target`. Other\r\n *    methods have no effect because the `Event` has already been dispatched, such as\r\n *    `preventDefault`. Bubbling would also not work. These properties and methods are patched,\r\n *    either to fill in information that the browser may have removed, or to throw errors in methods\r\n *    that no longer behave as expected.\r\n */\nfunction patchEventInstance(event, property, value, {\n  configurable = false\n} = {}) {\n  Object.defineProperty(event, property, {\n    value,\n    configurable\n  });\n}\n/**\r\n * Registers deferred functionality for an EventContract and a Jsaction\r\n * Dispatcher.\r\n */\nfunction registerDispatcher(eventContract, dispatcher) {\n  eventContract.ecrd(eventInfo => {\n    dispatcher.dispatch(eventInfo);\n  }, Restriction.I_AM_THE_JSACTION_FRAMEWORK);\n}\n\n/**\r\n * Whether the user agent is running on iOS.\r\n */\nconst isIos = typeof navigator !== 'undefined' && /iPhone|iPad|iPod/.test(navigator.userAgent);\n/**\r\n * A class representing a container node and all the event handlers\r\n * installed on it. Used so that handlers can be cleaned up if the\r\n * container is removed from the contract.\r\n */\nclass EventContractContainer {\n  /**\r\n   * @param element The container Element.\r\n   */\n  constructor(element) {\n    this.element = element;\n    /**\r\n     * Array of event handlers and their corresponding event types that are\r\n     * installed on this container.\r\n     *\r\n     */\n    this.handlerInfos = [];\n  }\n  /**\r\n   * Installs the provided installer on the element owned by this container,\r\n   * and maintains a reference to resulting handler in order to remove it\r\n   * later if desired.\r\n   */\n  addEventListener(eventType, getHandler) {\n    // In iOS, event bubbling doesn't happen automatically in any DOM element,\n    // unless it has an onclick attribute or DOM event handler attached to it.\n    // This breaks JsAction in some cases. See \"Making Elements Clickable\"\n    // section at http://goo.gl/2VoGnB.\n    //\n    // A workaround for this issue is to change the CSS cursor style to 'pointer'\n    // for the container element, which magically turns on event bubbling. This\n    // solution is described in the comments section at http://goo.gl/6pEO1z.\n    //\n    // We use a navigator.userAgent check here as this problem is present both\n    // on Mobile Safari and thin WebKit wrappers, such as Chrome for iOS.\n    if (isIos) {\n      this.element.style.cursor = 'pointer';\n    }\n    this.handlerInfos.push(addEventListener(this.element, eventType, getHandler(this.element)));\n  }\n  /**\r\n   * Removes all the handlers installed on this container.\r\n   */\n  cleanUp() {\n    for (let i = 0; i < this.handlerInfos.length; i++) {\n      removeEventListener(this.element, this.handlerInfos[i]);\n    }\n    this.handlerInfos = [];\n  }\n}\n\n/**\r\n * Update `EventInfo` to be `eventType = 'click'` and sets `a11yClickKey` if it\r\n * is a a11y click.\r\n */\nfunction updateEventInfoForA11yClick(eventInfo) {\n  if (!isActionKeyEvent(getEvent(eventInfo))) {\n    return;\n  }\n  setA11yClickKey(eventInfo, true);\n  // A 'click' triggered by a DOM keypress should be mapped to the 'click'\n  // jsaction.\n  setEventType(eventInfo, EventType.CLICK);\n}\n/**\r\n * Call `preventDefault` on an a11y click if it is space key or to prevent the\r\n * browser's default action for native HTML controls.\r\n */\nfunction preventDefaultForA11yClick(eventInfo) {\n  if (!getA11yClickKey(eventInfo) || !isSpaceKeyEvent(getEvent(eventInfo)) && !shouldCallPreventDefaultOnNativeHtmlControl(getEvent(eventInfo))) {\n    return;\n  }\n  preventDefault(getEvent(eventInfo));\n}\n/**\r\n * Sets the `action` to `clickonly` for a click event that is not an a11y click\r\n * and if there is not already a click action.\r\n */\nfunction populateClickOnlyAction(actionElement, eventInfo, actionMap) {\n  if (\n  // If there's already an action, don't attempt to set a CLICKONLY\n  getAction(eventInfo) ||\n  // Only attempt CLICKONLY if the type is CLICK\n  getEventType(eventInfo) !== EventType.CLICK ||\n  // a11y clicks are never CLICKONLY\n  getA11yClickKey(eventInfo) || actionMap[EventType.CLICKONLY] === undefined) {\n    return;\n  }\n  setEventType(eventInfo, EventType.CLICKONLY);\n  setAction(eventInfo, actionMap[EventType.CLICKONLY], actionElement);\n}\n\n/**\r\n * @define Support for accessible click actions.  This flag can be overridden in\r\n * a build rule.\r\n */\nconst A11Y_CLICK_SUPPORT = false;\n/**\r\n * @define Support for the non-bubbling mouseenter and mouseleave events.  This\r\n * flag can be overridden in a build rule.\r\n */\nconst MOUSE_SPECIAL_SUPPORT = false;\n\n/**\r\n * @fileoverview Implements the local event handling contract. This\r\n * allows DOM objects in a container that enters into this contract to\r\n * define event handlers which are executed in a local context.\r\n *\r\n * One EventContract instance can manage the contract for multiple\r\n * containers, which are added using the addContainer() method.\r\n *\r\n * Events can be registered using the addEvent() method.\r\n *\r\n * A Dispatcher is added using the registerDispatcher() method. Until there is\r\n * a dispatcher, events are queued. The idea is that the EventContract\r\n * class is inlined in the HTML of the top level page and instantiated\r\n * right after the start of <body>. The Dispatcher class is contained\r\n * in the external deferred js, and instantiated and registered with\r\n * EventContract when the external javascript in the page loads. The\r\n * external javascript will also register the jsaction handlers, which\r\n * then pick up the queued events at the time of registration.\r\n *\r\n * Since this class is meant to be inlined in the main page HTML, the\r\n * size of the binary compiled from this file MUST be kept as small as\r\n * possible and thus its dependencies to a minimum.\r\n */\n/**\r\n * EventContract intercepts events in the bubbling phase at the\r\n * boundary of a container element, and maps them to generic actions\r\n * which are specified using the custom jsaction attribute in\r\n * HTML. Behavior of the application is then specified in terms of\r\n * handler for such actions, cf. jsaction.Dispatcher in dispatcher.js.\r\n *\r\n * This has several benefits: (1) No DOM event handlers need to be\r\n * registered on the specific elements in the UI. (2) The set of\r\n * events that the application has to handle can be specified in terms\r\n * of the semantics of the application, rather than in terms of DOM\r\n * events. (3) Invocation of handlers can be delayed and handlers can\r\n * be delay loaded in a generic way.\r\n */\nclass EventContract {\n  static #_ = this.A11Y_CLICK_SUPPORT = A11Y_CLICK_SUPPORT;\n  static #_2 = this.MOUSE_SPECIAL_SUPPORT = MOUSE_SPECIAL_SUPPORT;\n  constructor(containerManager, useActionResolver = true) {\n    this.useActionResolver = useActionResolver;\n    /**\r\n     * The DOM events which this contract covers. Used to prevent double\r\n     * registration of event types. The value of the map is the\r\n     * internally created DOM event handler function that handles the\r\n     * DOM events. See addEvent().\r\n     *\r\n     */\n    this.eventHandlers = {};\n    this.browserEventTypeToExtraEventTypes = {};\n    /**\r\n     * The dispatcher function. Events are passed to this function for\r\n     * handling once it was set using the registerDispatcher() method. This is\r\n     * done because the function is passed from another jsbinary, so passing the\r\n     * instance and invoking the method here would require to leave the method\r\n     * unobfuscated.\r\n     */\n    this.dispatcher = null;\n    /**\r\n     * The list of suspended `EventInfo` that will be dispatched\r\n     * as soon as the `Dispatcher` is registered.\r\n     */\n    this.queuedEventInfos = [];\n    /** Whether to add an a11y click listener. */\n    this.addA11yClickListener = false;\n    this.containerManager = containerManager;\n    if (this.useActionResolver) {\n      this.actionResolver = new ActionResolver({\n        syntheticMouseEventSupport: EventContract.MOUSE_SPECIAL_SUPPORT\n      });\n    }\n    if (EventContract.A11Y_CLICK_SUPPORT) {\n      // Add a11y click support to the `EventContract`.\n      this.addA11yClickSupport();\n    }\n  }\n  handleEvent(eventType, event, container) {\n    const eventInfo = createEventInfoFromParameters( /* eventType= */eventType, /* event= */event, /* targetElement= */event.target, /* container= */container, /* timestamp= */Date.now());\n    this.handleEventInfo(eventInfo);\n  }\n  /**\r\n   * Handle an `EventInfo`.\r\n   */\n  handleEventInfo(eventInfo) {\n    if (!this.dispatcher) {\n      // All events are queued when the dispatcher isn't yet loaded.\n      setIsReplay(eventInfo, true);\n      this.queuedEventInfos?.push(eventInfo);\n      return;\n    }\n    if (this.useActionResolver) {\n      this.actionResolver.resolveEventType(eventInfo);\n      this.actionResolver.resolveAction(eventInfo);\n    }\n    this.dispatcher(eventInfo);\n  }\n  /**\r\n   * Enables jsaction handlers to be called for the event type given by\r\n   * name.\r\n   *\r\n   * If the event is already registered, this does nothing.\r\n   *\r\n   * @param prefixedEventType If supplied, this event is used in\r\n   *     the actual browser event registration instead of the name that is\r\n   *     exposed to jsaction. Use this if you e.g. want users to be able\r\n   *     to subscribe to jsaction=\"transitionEnd:foo\" while the underlying\r\n   *     event is webkitTransitionEnd in one browser and mozTransitionEnd\r\n   *     in another.\r\n   */\n  addEvent(eventType, prefixedEventType) {\n    if (eventType in this.eventHandlers || !this.containerManager) {\n      return;\n    }\n    if (!EventContract.MOUSE_SPECIAL_SUPPORT && NON_BUBBLING_MOUSE_EVENTS.indexOf(eventType) >= 0) {\n      return;\n    }\n    const eventHandler = (eventType, event, container) => {\n      this.handleEvent(eventType, event, container);\n    };\n    // Store the callback to allow us to replay events.\n    this.eventHandlers[eventType] = eventHandler;\n    const browserEventType = getBrowserEventType(prefixedEventType || eventType);\n    if (browserEventType !== eventType) {\n      const eventTypes = this.browserEventTypeToExtraEventTypes[browserEventType] || [];\n      eventTypes.push(eventType);\n      this.browserEventTypeToExtraEventTypes[browserEventType] = eventTypes;\n    }\n    this.containerManager.addEventListener(browserEventType, element => {\n      return event => {\n        eventHandler(eventType, event, element);\n      };\n    });\n    // Automatically install a keypress/keydown event handler if support for\n    // accessible clicks is turned on.\n    if (this.addA11yClickListener && eventType === EventType.CLICK) {\n      this.addEvent(EventType.KEYDOWN);\n    }\n  }\n  /**\r\n   * Gets the queued early events and replay them using the appropriate handler\r\n   * in the provided event contract. Once all the events are replayed, it cleans\r\n   * up the early contract.\r\n   */\n  replayEarlyEvents(earlyJsactionContainer = window) {\n    // Check if the early contract is present and prevent calling this function\n    // more than once.\n    const earlyJsactionData = earlyJsactionContainer._ejsa;\n    if (!earlyJsactionData) {\n      return;\n    }\n    // Replay the early contract events.\n    const earlyEventInfos = earlyJsactionData.q;\n    for (let idx = 0; idx < earlyEventInfos.length; idx++) {\n      const earlyEventInfo = earlyEventInfos[idx];\n      const eventTypes = this.getEventTypesForBrowserEventType(earlyEventInfo.eventType);\n      for (let i = 0; i < eventTypes.length; i++) {\n        const eventInfo = cloneEventInfo(earlyEventInfo);\n        // EventInfo eventType maps to JSAction's internal event type,\n        // rather than the browser event type.\n        setEventType(eventInfo, eventTypes[i]);\n        this.handleEventInfo(eventInfo);\n      }\n    }\n    // Clean up the early contract.\n    const earlyEventHandler = earlyJsactionData.h;\n    removeEventListeners(earlyJsactionData.c, earlyJsactionData.et, earlyEventHandler);\n    removeEventListeners(earlyJsactionData.c, earlyJsactionData.etc, earlyEventHandler, true);\n    delete earlyJsactionContainer._ejsa;\n  }\n  /**\r\n   * Returns all JSAction event types that have been registered for a given\r\n   * browser event type.\r\n   */\n  getEventTypesForBrowserEventType(browserEventType) {\n    const eventTypes = [];\n    if (this.eventHandlers[browserEventType]) {\n      eventTypes.push(browserEventType);\n    }\n    if (this.browserEventTypeToExtraEventTypes[browserEventType]) {\n      eventTypes.push(...this.browserEventTypeToExtraEventTypes[browserEventType]);\n    }\n    return eventTypes;\n  }\n  /**\r\n   * Returns the event handler function for a given event type.\r\n   */\n  handler(eventType) {\n    return this.eventHandlers[eventType];\n  }\n  /**\r\n   * Cleans up the event contract. This resets all of the `EventContract`'s\r\n   * internal state. Users are responsible for not using this `EventContract`\r\n   * after it has been cleaned up.\r\n   */\n  cleanUp() {\n    this.containerManager.cleanUp();\n    this.containerManager = null;\n    this.eventHandlers = {};\n    this.browserEventTypeToExtraEventTypes = {};\n    this.dispatcher = null;\n    this.queuedEventInfos = [];\n  }\n  /**\r\n   * Register a dispatcher function. Event info of each event mapped to\r\n   * a jsaction is passed for handling to this callback. The queued\r\n   * events are passed as well to the dispatcher for later replaying\r\n   * once the dispatcher is registered. Clears the event queue to null.\r\n   *\r\n   * @param dispatcher The dispatcher function.\r\n   * @param restriction\r\n   */\n  registerDispatcher(dispatcher, restriction) {\n    this.ecrd(dispatcher, restriction);\n  }\n  /**\r\n   * Unrenamed alias for registerDispatcher. Necessary for any codebases that\r\n   * split the `EventContract` and `Dispatcher` code into different compilation\r\n   * units.\r\n   */\n  ecrd(dispatcher, restriction) {\n    this.dispatcher = dispatcher;\n    if (this.queuedEventInfos?.length) {\n      for (let i = 0; i < this.queuedEventInfos.length; i++) {\n        this.handleEventInfo(this.queuedEventInfos[i]);\n      }\n      this.queuedEventInfos = null;\n    }\n  }\n  /**\r\n   * Adds a11y click support to the given `EventContract`. Meant to be called in\r\n   * the same compilation unit as the `EventContract`.\r\n   */\n  addA11yClickSupport() {\n    this.addA11yClickSupportImpl(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction);\n  }\n  /**\r\n   * Enables a11y click support to be deferred. Meant to be called in the same\r\n   * compilation unit as the `EventContract`.\r\n   */\n  exportAddA11yClickSupport() {\n    this.addA11yClickListener = true;\n    this.ecaacs = this.addA11yClickSupportImpl.bind(this);\n  }\n  /**\r\n   * Unrenamed function that loads a11yClickSupport.\r\n   */\n  addA11yClickSupportImpl(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction) {\n    this.addA11yClickListener = true;\n    if (this.useActionResolver) {\n      this.actionResolver.addA11yClickSupport(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction);\n    }\n  }\n}\nfunction removeEventListeners(container, eventTypes, earlyEventHandler, capture) {\n  for (let idx = 0; idx < eventTypes.length; idx++) {\n    container.removeEventListener(eventTypes[idx], earlyEventHandler, /* useCapture */capture);\n  }\n}\n/**\r\n * Adds a11y click support to the given `EventContract`. Meant to be called\r\n * in a different compilation unit from the `EventContract`. The `EventContract`\r\n * must have called `exportAddA11yClickSupport` in its compilation unit for this\r\n * to have any effect.\r\n */\nfunction addDeferredA11yClickSupport(eventContract) {\n  eventContract.ecaacs?.(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction);\n}\n\n/**\r\n * EarlyEventContract intercepts events in the bubbling phase at the\r\n * boundary of the document body. This mapping will be passed to the\r\n * late-loaded EventContract.\r\n */\nclass EarlyEventContract {\n  constructor(replaySink = window, container = window.document.documentElement) {\n    this.replaySink = replaySink;\n    this.container = container;\n    replaySink._ejsa = {\n      c: container,\n      q: [],\n      et: [],\n      etc: [],\n      h: event => {\n        const eventInfo = createEventInfoFromParameters(event.type, event, event.target, container, Date.now());\n        replaySink._ejsa.q.push(eventInfo);\n      }\n    };\n  }\n  /**\r\n   * Installs a list of event types for container .\r\n   */\n  addEvents(types, capture) {\n    const replaySink = this.replaySink._ejsa;\n    for (let idx = 0; idx < types.length; idx++) {\n      const eventType = types[idx];\n      const eventTypes = capture ? replaySink.etc : replaySink.et;\n      eventTypes.push(eventType);\n      this.container.addEventListener(eventType, replaySink.h, capture);\n    }\n  }\n}\n\n/**\r\n * Provides a factory function for bootstrapping an event contract on a\r\n * specified object (by default, exposed on the `window`).\r\n * @param field The property on the object that the event contract will be placed on.\r\n * @param container The container that listens to events\r\n * @param appId A given identifier for an application. If there are multiple apps on the page\r\n *              then this is how contracts can be initialized for each one.\r\n * @param eventTypes An array of event names that should be listened to.\r\n * @param captureEventTypes An array of event names that should be listened to with capture.\r\n * @param earlyJsactionTracker The object that should receive the event contract.\r\n */\nfunction bootstrapEarlyEventContract(field, container, appId, eventTypes, captureEventTypes, earlyJsactionTracker = window) {\n  if (!earlyJsactionTracker[field]) {\n    earlyJsactionTracker[field] = {};\n  }\n  earlyJsactionTracker[field][appId] = {};\n  const eventContract = new EarlyEventContract(earlyJsactionTracker[field][appId], container);\n  if (eventTypes) eventContract.addEvents(eventTypes);\n  if (captureEventTypes) eventContract.addEvents(captureEventTypes, true);\n}\nexport { EventContract, EventContractContainer, EventDispatcher, EventInfoWrapper, EventPhase, bootstrapEarlyEventContract, isCaptureEvent, isSupportedEvent, registerDispatcher };","map":{"version":3,"names":["JSACTION$1","OI$1","VED","VET","JSINSTANCE","JSTRACK","Attribute","JSACTION","OI","Char","NAMESPACE_ACTION_SEPARATOR","EVENT_ACTION_SEPARATOR","OI_SEPARATOR","CAD_KEY_VALUE_SEPARATOR","CAD_SEPARATOR","EventType","AUXCLICK","CHANGE","CLICK","CLICKMOD","CLICKONLY","DBLCLICK","FOCUS","FOCUSIN","BLUR","FOCUSOUT","SUBMIT","KEYDOWN","KEYPRESS","KEYUP","MOUSEUP","MOUSEDOWN","MOUSEOVER","MOUSEOUT","MOUSEENTER","MOUSELEAVE","MOUSEMOVE","POINTERUP","POINTERDOWN","POINTEROVER","POINTEROUT","POINTERENTER","POINTERLEAVE","POINTERMOVE","POINTERCANCEL","GOTPOINTERCAPTURE","LOSTPOINTERCAPTURE","ERROR","LOAD","UNLOAD","TOUCHSTART","TOUCHEND","TOUCHMOVE","INPUT","SCROLL","TOGGLE","CUSTOM","NON_BUBBLING_MOUSE_EVENTS","isSupportedEvent","eventType","SUPPORTED_EVENTS","includes","isCaptureEvent","CAPTURE_EVENTS","indexOf","OWNER","Property","parseCache","get","element","set","actionMap","getParsed","text","setParsed","parsed","clear","getEventType","eventInfo","setEventType","getEvent","event","setEvent","getTargetElement","targetElement","setTargetElement","getContainer","eic","setContainer","container","getTimestamp","timeStamp","setTimestamp","timestamp","getAction","eia","setAction","actionName","actionElement","unsetAction","undefined","getActionName","actionInfo","getActionElement","getIsReplay","eirp","setIsReplay","replay","getA11yClickKey","eiack","setA11yClickKey","a11yClickKey","getResolved","eir","setResolved","resolved","cloneEventInfo","createEventInfoFromParameters","action","isReplay","createEventInfo","name","EventInfoWrapper","constructor","clone","contains","node","otherNode","nodeType","Boolean","compareDocumentPosition","parentNode","hasAncestorInNodeList","nodeList","idx","length","member","MAC_ENTER","ENTER","SPACE","KeyCode","getBrowserEventType","addEventListener","handler","capture","removeEventListener","info","detachEvent","stopPropagation","e","cancelBubble","preventDefault","returnValue","getTarget","el","target","getAttribute","isMac","navigator","test","userAgent","isMiddleClick","which","button","isModifiedClickEvent","metaKey","ctrlKey","shiftKey","isWebKit","isIe","isGecko","product","isValidActionKeyTarget","isTextControl","isNativelyActivatable","isContentEditable","hasModifierKey","altKey","shouldCallPreventDefaultOnNativeHtmlControl","tagName","toUpperCase","role","isNativeHTMLControl","processSpace","isActionKeyEvent","key","keyCode","ACTION_KEY_TO_KEYCODE","type","isFocusable","isSpecificTriggerKey","IDENTIFIER_TO_KEY_TRIGGER_MAPPING","isDefaultTriggerKey","hasType","NATIVELY_FOCUSABLE_ELEMENTS","hasSpecifiedTabIndex","disabled","attrNode","getAttributeNode","specified","isSpaceKeyEvent","elementName","isMouseSpecialEvent","related","relatedTarget","createMouseSpecialEvent","copy","property","value","getTouchData","touch","changedTouches","touches","clientX","clientY","screenX","screenY","recreateTouchEventAsClick","click","Date","now","syntheticPreventDefault","syntheticStopPropagation","defaultPrevented","_propagationStopped","PROCESS_SPACE","TEXT_CONTROLS","NATIVE_HTML_CONTROLS","testing","setIsMac","EMPTY_ACTION_MAP","REGEXP_SEMICOLON","DEFAULT_EVENT_TYPE","ActionResolver","syntheticMouseEventSupport","a11yClickSupport","updateEventInfoForA11yClick","preventDefaultForA11yClick","populateClickOnlyAction","resolveEventType","resolveAction","populateAction","resolveParentAction","getParentNode","currentTarget","Node","ELEMENT_NODE","populateActionOnElement","copiedEvent","owner","nodeName","host","parseActions","jsactionAttribute","values","split","colon","hasColon","substr","trim","addA11yClickSupport","Restriction","Dispatcher","dispatchDelegate","actionResolver","eventReplayer","eventReplayScheduled","replayEventInfoWrappers","dispatch","eventInfoWrapper","shouldPreventDefaultBeforeDispatching","scheduleEventInfoWrapperReplay","push","Promise","resolve","then","createEventReplayer","eventInfoWrappers","registerDispatcher$1","eventContract","dispatcher","ecrd","I_AM_THE_JSACTION_FRAMEWORK","PROPAGATION_STOPPED_SYMBOL","Symbol","for","EventPhase","REPLAY","PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS","PREVENT_DEFAULT_ERROR_MESSAGE","COMPOSED_PATH_ERROR_MESSAGE_DETAILS","ngDevMode","COMPOSED_PATH_ERROR_MESSAGE","EventDispatcher","dispatchToDelegate","prepareEventForReplay","prepareEventForBubbling","prepareEventForDispatch","propagationStopped","patchEventInstance","Error","configurable","Object","defineProperty","registerDispatcher","isIos","EventContractContainer","handlerInfos","getHandler","style","cursor","cleanUp","i","A11Y_CLICK_SUPPORT","MOUSE_SPECIAL_SUPPORT","EventContract","_","_2","containerManager","useActionResolver","eventHandlers","browserEventTypeToExtraEventTypes","queuedEventInfos","addA11yClickListener","handleEvent","handleEventInfo","addEvent","prefixedEventType","eventHandler","browserEventType","eventTypes","replayEarlyEvents","earlyJsactionContainer","window","earlyJsactionData","_ejsa","earlyEventInfos","q","earlyEventInfo","getEventTypesForBrowserEventType","earlyEventHandler","h","removeEventListeners","c","et","etc","restriction","addA11yClickSupportImpl","exportAddA11yClickSupport","ecaacs","bind","addDeferredA11yClickSupport","EarlyEventContract","replaySink","document","documentElement","addEvents","types","bootstrapEarlyEventContract","field","appId","captureEventTypes","earlyJsactionTracker"],"sources":["C:/Users/Hamzah Alkhateeb/Desktop/Halal Eatz/HalalEats/node_modules/@angular/core/fesm2022/primitives/event-dispatch.mjs"],"sourcesContent":["/**\r\n * @license Angular v18.0.1\r\n * (c) 2010-2024 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\n/**\r\n * The jsaction attribute defines a mapping of a DOM event to a\r\n * generic event (aka jsaction), to which the actual event handlers\r\n * that implement the behavior of the application are bound. The\r\n * value is a semicolon separated list of colon separated pairs of\r\n * an optional DOM event name and a jsaction name. If the optional\r\n * DOM event name is omitted, 'click' is assumed. The jsaction names\r\n * are dot separated pairs of a namespace and a simple jsaction\r\n * name.\r\n *\r\n * See grammar in README.md for expected syntax in the attribute value.\r\n */\r\nconst JSACTION$1 = 'jsaction';\r\n/**\r\n * The oi attribute is a log impression tag for impression logging\r\n * and action tracking. For an element that carries a jsaction\r\n * attribute, the element is identified for the purpose of\r\n * impression logging and click tracking by the dot separated path\r\n * of all oi attributes in the chain of ancestors of the element.\r\n *\r\n * Used by ActionFlow.\r\n */\r\nconst OI$1 = 'oi';\r\n/**\r\n * The ved attribute is an encoded ClickTrackingCGI proto to track\r\n * visual elements.\r\n *\r\n * Used by ActionFlow.\r\n */\r\nconst VED = 'ved';\r\n/**\r\n * The vet attribute is the visual element type used to identify tracked\r\n * visual elements.\r\n */\r\nconst VET = 'vet';\r\n/**\r\n * Support for iteration on reprocessing.\r\n *\r\n * Used by ActionFlow.\r\n */\r\nconst JSINSTANCE = 'jsinstance';\r\n/**\r\n * All click jsactions that happen on the element that carries this\r\n * attribute or its descendants are automatically logged.\r\n * Impressions of jsactions on these elements are tracked too, if\r\n * requested by the impression() method of ActionFlow.\r\n *\r\n * Used by ActionFlow.\r\n */\r\nconst JSTRACK = 'jstrack';\r\nconst Attribute = { JSACTION: JSACTION$1, OI: OI$1, VED, VET, JSINSTANCE, JSTRACK };\r\n\r\nconst Char = {\r\n    /**\r\n     * The separator between the namespace and the action name in the\r\n     * jsaction attribute value.\r\n     */\r\n    NAMESPACE_ACTION_SEPARATOR: '.',\r\n    /**\r\n     * The separator between the event name and action in the jsaction\r\n     * attribute value.\r\n     */\r\n    EVENT_ACTION_SEPARATOR: ':',\r\n    /**\r\n     * The separator between the logged oi attribute values in the &oi=\r\n     * URL parameter value.\r\n     */\r\n    OI_SEPARATOR: '.',\r\n    /**\r\n     * The separator between the key and the value pairs in the &cad=\r\n     * URL parameter value.\r\n     */\r\n    CAD_KEY_VALUE_SEPARATOR: ':',\r\n    /**\r\n     * The separator between the key-value pairs in the &cad= URL\r\n     * parameter value.\r\n     */\r\n    CAD_SEPARATOR: ',',\r\n};\r\n\r\n/*\r\n * Names of events that are special to jsaction. These are not all\r\n * event types that are legal to use in either HTML or the addEvent()\r\n * API, but these are the ones that are treated specially. All other\r\n * DOM events can be used in either addEvent() or in the value of the\r\n * jsaction attribute. Beware of browser specific events or events\r\n * that don't bubble though: If they are not mentioned here, then\r\n * event contract doesn't work around their peculiarities.\r\n */\r\nconst EventType = {\r\n    /**\r\n     * Mouse middle click, introduced in Chrome 55 and not yet supported on\r\n     * other browsers.\r\n     */\r\n    AUXCLICK: 'auxclick',\r\n    /**\r\n     * The change event fired by browsers when the `value` attribute of input,\r\n     * select, and textarea elements are changed.\r\n     */\r\n    CHANGE: 'change',\r\n    /**\r\n     * The click event. In addEvent() refers to all click events, in the\r\n     * jsaction attribute it refers to the unmodified click and Enter/Space\r\n     * keypress events.  In the latter case, a jsaction click will be triggered,\r\n     * for accessibility reasons.  See clickmod and clickonly, below.\r\n     */\r\n    CLICK: 'click',\r\n    /**\r\n     * Specifies the jsaction for a modified click event (i.e. a mouse\r\n     * click with the modifier key Cmd/Ctrl pressed). This event isn't\r\n     * separately enabled in addEvent(), because in the DOM, it's just a\r\n     * click event.\r\n     */\r\n    CLICKMOD: 'clickmod',\r\n    /**\r\n     * Specifies the jsaction for a click-only event.  Click-only doesn't take\r\n     * into account the case where an element with focus receives an Enter/Space\r\n     * keypress.  This event isn't separately enabled in addEvent().\r\n     */\r\n    CLICKONLY: 'clickonly',\r\n    /**\r\n     * The dblclick event.\r\n     */\r\n    DBLCLICK: 'dblclick',\r\n    /**\r\n     * Focus doesn't bubble, but you can use it in addEvent() and\r\n     * jsaction anyway. EventContract does the right thing under the\r\n     * hood.\r\n     */\r\n    FOCUS: 'focus',\r\n    /**\r\n     * This event only exists in IE. For addEvent() and jsaction, use\r\n     * focus instead; EventContract does the right thing even though\r\n     * focus doesn't bubble.\r\n     */\r\n    FOCUSIN: 'focusin',\r\n    /**\r\n     * Analog to focus.\r\n     */\r\n    BLUR: 'blur',\r\n    /**\r\n     * Analog to focusin.\r\n     */\r\n    FOCUSOUT: 'focusout',\r\n    /**\r\n     * Submit doesn't bubble, so it cannot be used with event\r\n     * contract. However, the browser helpfully fires a click event on\r\n     * the submit button of a form (even if the form is not submitted by\r\n     * a click on the submit button). So you should handle click on the\r\n     * submit button instead.\r\n     */\r\n    SUBMIT: 'submit',\r\n    /**\r\n     * The keydown event. In addEvent() and non-click jsaction it represents the\r\n     * regular DOM keydown event. It represents click actions in non-Gecko\r\n     * browsers.\r\n     */\r\n    KEYDOWN: 'keydown',\r\n    /**\r\n     * The keypress event. In addEvent() and non-click jsaction it represents the\r\n     * regular DOM keypress event. It represents click actions in Gecko browsers.\r\n     */\r\n    KEYPRESS: 'keypress',\r\n    /**\r\n     * The keyup event. In addEvent() and non-click jsaction it represents the\r\n     * regular DOM keyup event. It represents click actions in non-Gecko\r\n     * browsers.\r\n     */\r\n    KEYUP: 'keyup',\r\n    /**\r\n     * The mouseup event. Can either be used directly or used implicitly to\r\n     * capture mouseup events. In addEvent(), it represents a regular DOM\r\n     * mouseup event.\r\n     */\r\n    MOUSEUP: 'mouseup',\r\n    /**\r\n     * The mousedown event. Can either be used directly or used implicitly to\r\n     * capture mouseenter events. In addEvent(), it represents a regular DOM\r\n     * mouseover event.\r\n     */\r\n    MOUSEDOWN: 'mousedown',\r\n    /**\r\n     * The mouseover event. Can either be used directly or used implicitly to\r\n     * capture mouseenter events. In addEvent(), it represents a regular DOM\r\n     * mouseover event.\r\n     */\r\n    MOUSEOVER: 'mouseover',\r\n    /**\r\n     * The mouseout event. Can either be used directly or used implicitly to\r\n     * capture mouseover events. In addEvent(), it represents a regular DOM\r\n     * mouseout event.\r\n     */\r\n    MOUSEOUT: 'mouseout',\r\n    /**\r\n     * The mouseenter event. Does not bubble and fires individually on each\r\n     * element being entered within a DOM tree.\r\n     */\r\n    MOUSEENTER: 'mouseenter',\r\n    /**\r\n     * The mouseleave event. Does not bubble and fires individually on each\r\n     * element being entered within a DOM tree.\r\n     */\r\n    MOUSELEAVE: 'mouseleave',\r\n    /**\r\n     * The mousemove event.\r\n     */\r\n    MOUSEMOVE: 'mousemove',\r\n    /**\r\n     * The pointerup event. Can either be used directly or used implicitly to\r\n     * capture pointerup events. In addEvent(), it represents a regular DOM\r\n     * pointerup event.\r\n     */\r\n    POINTERUP: 'pointerup',\r\n    /**\r\n     * The pointerdown event. Can either be used directly or used implicitly to\r\n     * capture pointerenter events. In addEvent(), it represents a regular DOM\r\n     * mouseover event.\r\n     */\r\n    POINTERDOWN: 'pointerdown',\r\n    /**\r\n     * The pointerover event. Can either be used directly or used implicitly to\r\n     * capture pointerenter events. In addEvent(), it represents a regular DOM\r\n     * pointerover event.\r\n     */\r\n    POINTEROVER: 'pointerover',\r\n    /**\r\n     * The pointerout event. Can either be used directly or used implicitly to\r\n     * capture pointerover events. In addEvent(), it represents a regular DOM\r\n     * pointerout event.\r\n     */\r\n    POINTEROUT: 'pointerout',\r\n    /**\r\n     * The pointerenter event. Does not bubble and fires individually on each\r\n     * element being entered within a DOM tree.\r\n     */\r\n    POINTERENTER: 'pointerenter',\r\n    /**\r\n     * The pointerleave event. Does not bubble and fires individually on each\r\n     * element being entered within a DOM tree.\r\n     */\r\n    POINTERLEAVE: 'pointerleave',\r\n    /**\r\n     * The pointermove event.\r\n     */\r\n    POINTERMOVE: 'pointermove',\r\n    /**\r\n     * The pointercancel event.\r\n     */\r\n    POINTERCANCEL: 'pointercancel',\r\n    /**\r\n     * The gotpointercapture event is fired when\r\n     * Element.setPointerCapture(pointerId) is called on a mouse input, or\r\n     * implicitly when a touch input begins.\r\n     */\r\n    GOTPOINTERCAPTURE: 'gotpointercapture',\r\n    /**\r\n     * The lostpointercapture event is fired when\r\n     * Element.releasePointerCapture(pointerId) is called, or implicitly after a\r\n     * touch input ends.\r\n     */\r\n    LOSTPOINTERCAPTURE: 'lostpointercapture',\r\n    /**\r\n     * The error event. The error event doesn't bubble, but you can use it in\r\n     * addEvent() and jsaction anyway. EventContract does the right thing under\r\n     * the hood (except in IE8 which does not use error events).\r\n     */\r\n    ERROR: 'error',\r\n    /**\r\n     * The load event. The load event doesn't bubble, but you can use it in\r\n     * addEvent() and jsaction anyway. EventContract does the right thing\r\n     * under the hood.\r\n     */\r\n    LOAD: 'load',\r\n    /**\r\n     * The unload event.\r\n     */\r\n    UNLOAD: 'unload',\r\n    /**\r\n     * The touchstart event. Bubbles, will only ever fire in browsers with\r\n     * touch support.\r\n     */\r\n    TOUCHSTART: 'touchstart',\r\n    /**\r\n     * The touchend event. Bubbles, will only ever fire in browsers with\r\n     * touch support.\r\n     */\r\n    TOUCHEND: 'touchend',\r\n    /**\r\n     * The touchmove event. Bubbles, will only ever fire in browsers with\r\n     * touch support.\r\n     */\r\n    TOUCHMOVE: 'touchmove',\r\n    /**\r\n     * The input event.\r\n     */\r\n    INPUT: 'input',\r\n    /**\r\n     * The scroll event.\r\n     */\r\n    SCROLL: 'scroll',\r\n    /**\r\n     * The toggle event. The toggle event doesn't bubble, but you can use it in\r\n     * addEvent() and jsaction anyway. EventContract does the right thing\r\n     * under the hood.\r\n     */\r\n    TOGGLE: 'toggle',\r\n    /**\r\n     * A custom event. The actual custom event type is declared as the 'type'\r\n     * field in the event details. Supported in Firefox 6+, IE 9+, and all Chrome\r\n     * versions.\r\n     *\r\n     * This is an internal name. Users should use jsaction's fireCustomEvent to\r\n     * fire custom events instead of relying on this type to create them.\r\n     */\r\n    CUSTOM: '_custom',\r\n};\r\nconst NON_BUBBLING_MOUSE_EVENTS = [\r\n    EventType.MOUSEENTER,\r\n    EventType.MOUSELEAVE,\r\n    'pointerenter',\r\n    'pointerleave',\r\n];\r\n/**\r\n * Detects whether a given event type is supported by JSAction.\r\n */\r\nconst isSupportedEvent = (eventType) => SUPPORTED_EVENTS.includes(eventType);\r\nconst SUPPORTED_EVENTS = [\r\n    EventType.CLICK,\r\n    EventType.DBLCLICK,\r\n    EventType.FOCUS,\r\n    EventType.FOCUSIN,\r\n    EventType.BLUR,\r\n    EventType.ERROR,\r\n    EventType.FOCUSOUT,\r\n    EventType.KEYDOWN,\r\n    EventType.KEYUP,\r\n    EventType.KEYPRESS,\r\n    EventType.LOAD,\r\n    EventType.MOUSEOVER,\r\n    EventType.MOUSEOUT,\r\n    EventType.SUBMIT,\r\n    EventType.TOGGLE,\r\n    EventType.TOUCHSTART,\r\n    EventType.TOUCHEND,\r\n    EventType.TOUCHMOVE,\r\n    'touchcancel',\r\n    'auxclick',\r\n    'change',\r\n    'compositionstart',\r\n    'compositionupdate',\r\n    'compositionend',\r\n    'beforeinput',\r\n    'input',\r\n    'select',\r\n    'copy',\r\n    'cut',\r\n    'paste',\r\n    'mousedown',\r\n    'mouseup',\r\n    'wheel',\r\n    'contextmenu',\r\n    'dragover',\r\n    'dragenter',\r\n    'dragleave',\r\n    'drop',\r\n    'dragstart',\r\n    'dragend',\r\n    'pointerdown',\r\n    'pointermove',\r\n    'pointerup',\r\n    'pointercancel',\r\n    'pointerover',\r\n    'pointerout',\r\n    'gotpointercapture',\r\n    'lostpointercapture',\r\n    // Video events.\r\n    'ended',\r\n    'loadedmetadata',\r\n    // Page visibility events.\r\n    'pagehide',\r\n    'pageshow',\r\n    'visibilitychange',\r\n    // Content visibility events.\r\n    'beforematch',\r\n];\r\n/**\r\n *\r\n * Decides whether or not an event type is an event that only has a capture phase.\r\n *\r\n * @param eventType\r\n * @returns bool\r\n */\r\nconst isCaptureEvent = (eventType) => CAPTURE_EVENTS.indexOf(eventType) >= 0;\r\nconst CAPTURE_EVENTS = [\r\n    EventType.FOCUS,\r\n    EventType.BLUR,\r\n    EventType.ERROR,\r\n    EventType.LOAD,\r\n    EventType.TOGGLE,\r\n];\r\n\r\n/**\r\n * The parsed value of the jsaction attribute is stored in this\r\n * property on the DOM node. The parsed value is an Object. The\r\n * property names of the object are the events; the values are the\r\n * names of the actions. This property is attached even on nodes\r\n * that don't have a jsaction attribute as an optimization, because\r\n * property lookup is faster than attribute access.\r\n */\r\nconst JSACTION = '__jsaction';\r\n/** The value of the oi attribute as a property, for faster access. */\r\nconst OI = '__oi';\r\n/**\r\n * The owner property references an a logical owner for a DOM node. JSAction\r\n * will follow this reference instead of parentNode when traversing the DOM\r\n * to find jsaction attributes. This allows overlaying a logical structure\r\n * over a document where the DOM structure can't reflect that structure.\r\n */\r\nconst OWNER = '__owner';\r\n/** All properties that are used by jsaction. */\r\nconst Property = {\r\n    JSACTION,\r\n    OI,\r\n    OWNER,\r\n};\r\n\r\n/**\r\n * Map from jsaction annotation to a parsed map from event name to action name.\r\n */\r\nconst parseCache = {};\r\n/**\r\n * Reads the jsaction parser cache from the given DOM Element.\r\n *\r\n * @param element .\r\n * @return Map from event to qualified name of the jsaction bound to it.\r\n */\r\nfunction get(element) {\r\n    // @ts-ignore\r\n    return element[JSACTION];\r\n}\r\n/**\r\n * Writes the jsaction parser cache to the given DOM Element.\r\n *\r\n * @param element .\r\n * @param actionMap Map from event to qualified name of the jsaction bound to\r\n *     it.\r\n */\r\nfunction set(element, actionMap) {\r\n    // @ts-ignore\r\n    element[JSACTION] = actionMap;\r\n}\r\n/**\r\n * Looks up the parsed action map from the source jsaction attribute value.\r\n *\r\n * @param text Unparsed jsaction attribute value.\r\n * @return Parsed jsaction attribute value, if already present in the cache.\r\n */\r\nfunction getParsed(text) {\r\n    return parseCache[text];\r\n}\r\n/**\r\n * Inserts the parse result for the given source jsaction value into the cache.\r\n *\r\n * @param text Unparsed jsaction attribute value.\r\n * @param parsed Attribute value parsed into the action map.\r\n */\r\nfunction setParsed(text, parsed) {\r\n    parseCache[text] = parsed;\r\n}\r\n/**\r\n * Clears the jsaction parser cache from the given DOM Element.\r\n *\r\n * @param element .\r\n */\r\nfunction clear(element) {\r\n    if (JSACTION in element) {\r\n        delete element[JSACTION];\r\n    }\r\n}\r\n\r\n/** Added for readability when accessing stable property names. */\r\nfunction getEventType(eventInfo) {\r\n    return eventInfo.eventType;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction setEventType(eventInfo, eventType) {\r\n    eventInfo.eventType = eventType;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction getEvent(eventInfo) {\r\n    return eventInfo.event;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction setEvent(eventInfo, event) {\r\n    eventInfo.event = event;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction getTargetElement(eventInfo) {\r\n    return eventInfo.targetElement;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction setTargetElement(eventInfo, targetElement) {\r\n    eventInfo.targetElement = targetElement;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction getContainer(eventInfo) {\r\n    return eventInfo.eic;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction setContainer(eventInfo, container) {\r\n    eventInfo.eic = container;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction getTimestamp(eventInfo) {\r\n    return eventInfo.timeStamp;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction setTimestamp(eventInfo, timestamp) {\r\n    eventInfo.timeStamp = timestamp;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction getAction(eventInfo) {\r\n    return eventInfo.eia;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction setAction(eventInfo, actionName, actionElement) {\r\n    eventInfo.eia = [actionName, actionElement];\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction unsetAction(eventInfo) {\r\n    eventInfo.eia = undefined;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction getActionName(actionInfo) {\r\n    return actionInfo[0];\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction getActionElement(actionInfo) {\r\n    return actionInfo[1];\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction getIsReplay(eventInfo) {\r\n    return eventInfo.eirp;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction setIsReplay(eventInfo, replay) {\r\n    eventInfo.eirp = replay;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction getA11yClickKey(eventInfo) {\r\n    return eventInfo.eiack;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction setA11yClickKey(eventInfo, a11yClickKey) {\r\n    eventInfo.eiack = a11yClickKey;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction getResolved(eventInfo) {\r\n    return eventInfo.eir;\r\n}\r\n/** Added for readability when accessing stable property names. */\r\nfunction setResolved(eventInfo, resolved) {\r\n    eventInfo.eir = resolved;\r\n}\r\n/** Clones an `EventInfo` */\r\nfunction cloneEventInfo(eventInfo) {\r\n    return {\r\n        eventType: eventInfo.eventType,\r\n        event: eventInfo.event,\r\n        targetElement: eventInfo.targetElement,\r\n        eic: eventInfo.eic,\r\n        eia: eventInfo.eia,\r\n        timeStamp: eventInfo.timeStamp,\r\n        eirp: eventInfo.eirp,\r\n        eiack: eventInfo.eiack,\r\n        eir: eventInfo.eir,\r\n    };\r\n}\r\n/**\r\n * Utility function for creating an `EventInfo`.\r\n *\r\n * This can be used from code-size sensitive compilation units, as taking\r\n * parameters vs. an `Object` literal reduces code size.\r\n */\r\nfunction createEventInfoFromParameters(eventType, event, targetElement, container, timestamp, action, isReplay, a11yClickKey) {\r\n    return {\r\n        eventType,\r\n        event,\r\n        targetElement,\r\n        eic: container,\r\n        timeStamp: timestamp,\r\n        eia: action,\r\n        eirp: isReplay,\r\n        eiack: a11yClickKey,\r\n    };\r\n}\r\n/**\r\n * Utility function for creating an `EventInfo`.\r\n *\r\n * This should be used in compilation units that are less sensitive to code\r\n * size.\r\n */\r\nfunction createEventInfo({ eventType, event, targetElement, container, timestamp, action, isReplay, a11yClickKey, }) {\r\n    return {\r\n        eventType,\r\n        event,\r\n        targetElement,\r\n        eic: container,\r\n        timeStamp: timestamp,\r\n        eia: action ? [action.name, action.element] : undefined,\r\n        eirp: isReplay,\r\n        eiack: a11yClickKey,\r\n    };\r\n}\r\n/**\r\n * Utility class around an `EventInfo`.\r\n *\r\n * This should be used in compilation units that are less sensitive to code\r\n * size.\r\n */\r\nclass EventInfoWrapper {\r\n    constructor(eventInfo) {\r\n        this.eventInfo = eventInfo;\r\n    }\r\n    getEventType() {\r\n        return getEventType(this.eventInfo);\r\n    }\r\n    setEventType(eventType) {\r\n        setEventType(this.eventInfo, eventType);\r\n    }\r\n    getEvent() {\r\n        return getEvent(this.eventInfo);\r\n    }\r\n    setEvent(event) {\r\n        setEvent(this.eventInfo, event);\r\n    }\r\n    getTargetElement() {\r\n        return getTargetElement(this.eventInfo);\r\n    }\r\n    setTargetElement(targetElement) {\r\n        setTargetElement(this.eventInfo, targetElement);\r\n    }\r\n    getContainer() {\r\n        return getContainer(this.eventInfo);\r\n    }\r\n    setContainer(container) {\r\n        setContainer(this.eventInfo, container);\r\n    }\r\n    getTimestamp() {\r\n        return getTimestamp(this.eventInfo);\r\n    }\r\n    setTimestamp(timestamp) {\r\n        setTimestamp(this.eventInfo, timestamp);\r\n    }\r\n    getAction() {\r\n        const action = getAction(this.eventInfo);\r\n        if (!action)\r\n            return undefined;\r\n        return {\r\n            name: action[0],\r\n            element: action[1],\r\n        };\r\n    }\r\n    setAction(action) {\r\n        if (!action) {\r\n            unsetAction(this.eventInfo);\r\n            return;\r\n        }\r\n        setAction(this.eventInfo, action.name, action.element);\r\n    }\r\n    getIsReplay() {\r\n        return getIsReplay(this.eventInfo);\r\n    }\r\n    setIsReplay(replay) {\r\n        setIsReplay(this.eventInfo, replay);\r\n    }\r\n    getResolved() {\r\n        return getResolved(this.eventInfo);\r\n    }\r\n    setResolved(resolved) {\r\n        setResolved(this.eventInfo, resolved);\r\n    }\r\n    clone() {\r\n        return new EventInfoWrapper(cloneEventInfo(this.eventInfo));\r\n    }\r\n}\r\n\r\n/**\r\n * Determines if one node is contained within another. Adapted from\r\n * {@see goog.dom.contains}.\r\n * @param node Node that should contain otherNode.\r\n * @param otherNode Node being contained.\r\n * @return True if otherNode is contained within node.\r\n */\r\nfunction contains(node, otherNode) {\r\n    if (otherNode === null) {\r\n        return false;\r\n    }\r\n    // We use browser specific methods for this if available since it is faster\r\n    // that way.\r\n    // IE DOM\r\n    if ('contains' in node && otherNode.nodeType === 1) {\r\n        return node.contains(otherNode);\r\n    }\r\n    // W3C DOM Level 3\r\n    if ('compareDocumentPosition' in node) {\r\n        return node === otherNode || Boolean(node.compareDocumentPosition(otherNode) & 16);\r\n    }\r\n    // W3C DOM Level 1\r\n    while (otherNode && node !== otherNode) {\r\n        otherNode = otherNode.parentNode;\r\n    }\r\n    return otherNode === node;\r\n}\r\n/**\r\n * Helper method for broadcastCustomEvent. Returns true if any member of\r\n * the set is an ancestor of element.\r\n */\r\nfunction hasAncestorInNodeList(element, nodeList) {\r\n    for (let idx = 0; idx < nodeList.length; ++idx) {\r\n        const member = nodeList[idx];\r\n        if (member !== element && contains(member, element)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * If on a Macintosh with an extended keyboard, the Enter key located in the\r\n * numeric pad has a different ASCII code.\r\n */\r\nconst MAC_ENTER = 3;\r\n/** The Enter key. */\r\nconst ENTER = 13;\r\n/** The Space key. */\r\nconst SPACE = 32;\r\n/** Special keycodes used by jsaction for the generic click action. */\r\nconst KeyCode = { MAC_ENTER, ENTER, SPACE };\r\n\r\n/**\r\n * Gets a browser event type, if it would differ from the JSAction event type.\r\n */\r\nfunction getBrowserEventType(eventType) {\r\n    // Mouseenter and mouseleave events are not handled directly because they\r\n    // are not available everywhere. In browsers where they are available, they\r\n    // don't bubble and aren't visible at the container boundary. Instead, we\r\n    // synthesize the mouseenter and mouseleave events from mouseover and\r\n    // mouseout events, respectively. Cf. eventcontract.js.\r\n    if (eventType === EventType.MOUSEENTER) {\r\n        return EventType.MOUSEOVER;\r\n    }\r\n    else if (eventType === EventType.MOUSELEAVE) {\r\n        return EventType.MOUSEOUT;\r\n    }\r\n    else if (eventType === EventType.POINTERENTER) {\r\n        return EventType.POINTEROVER;\r\n    }\r\n    else if (eventType === EventType.POINTERLEAVE) {\r\n        return EventType.POINTEROUT;\r\n    }\r\n    return eventType;\r\n}\r\n/**\r\n * Registers the event handler function with the given DOM element for\r\n * the given event type.\r\n *\r\n * @param element The element.\r\n * @param eventType The event type.\r\n * @param handler The handler function to install.\r\n * @return Information needed to uninstall the event handler eventually.\r\n */\r\nfunction addEventListener(element, eventType, handler) {\r\n    // All event handlers are registered in the bubbling\r\n    // phase.\r\n    //\r\n    // All browsers support focus and blur, but these events only are propagated\r\n    // in the capture phase. Very legacy browsers do not support focusin or\r\n    // focusout.\r\n    //\r\n    // It would be a bad idea to register all event handlers in the\r\n    // capture phase because then regular onclick handlers would not be\r\n    // executed at all on events that trigger a jsaction. That's not\r\n    // entirely what we want, at least for now.\r\n    //\r\n    // Error and load events (i.e. on images) do not bubble so they are also\r\n    // handled in the capture phase.\r\n    let capture = false;\r\n    if (isCaptureEvent(eventType)) {\r\n        capture = true;\r\n    }\r\n    element.addEventListener(eventType, handler, capture);\r\n    return { eventType, handler, capture };\r\n}\r\n/**\r\n * Removes the event handler for the given event from the element.\r\n * the given event type.\r\n *\r\n * @param element The element.\r\n * @param info The information needed to deregister the handler, as returned by\r\n *     addEventListener(), above.\r\n */\r\nfunction removeEventListener(element, info) {\r\n    if (element.removeEventListener) {\r\n        element.removeEventListener(info.eventType, info.handler, info.capture);\r\n        // `detachEvent` is an old DOM API.\r\n        // tslint:disable-next-line:no-any\r\n    }\r\n    else if (element.detachEvent) {\r\n        // `detachEvent` is an old DOM API.\r\n        // tslint:disable-next-line:no-any\r\n        element.detachEvent(`on${info.eventType}`, info.handler);\r\n    }\r\n}\r\n/**\r\n * Cancels propagation of an event.\r\n * @param e The event to cancel propagation for.\r\n */\r\nfunction stopPropagation(e) {\r\n    e.stopPropagation ? e.stopPropagation() : (e.cancelBubble = true);\r\n}\r\n/**\r\n * Prevents the default action of an event.\r\n * @param e The event to prevent the default action for.\r\n */\r\nfunction preventDefault(e) {\r\n    e.preventDefault ? e.preventDefault() : (e.returnValue = false);\r\n}\r\n/**\r\n * Gets the target Element of the event. In Firefox, a text node may appear as\r\n * the target of the event, in which case we return the parent element of the\r\n * text node.\r\n * @param e The event to get the target of.\r\n * @return The target element.\r\n */\r\nfunction getTarget(e) {\r\n    let el = e.target;\r\n    // In Firefox, the event may have a text node as its target. We always\r\n    // want the parent Element the text node belongs to, however.\r\n    if (!el.getAttribute && el.parentNode) {\r\n        el = el.parentNode;\r\n    }\r\n    return el;\r\n}\r\n/**\r\n * Whether we are on a Mac. Not pulling in useragent just for this.\r\n */\r\nlet isMac = typeof navigator !== 'undefined' && /Macintosh/.test(navigator.userAgent);\r\n/**\r\n * Determines and returns whether the given event (which is assumed to be a\r\n * click event) is a middle click.\r\n * NOTE: There is not a consistent way to identify middle click\r\n * http://www.unixpapa.com/js/mouse.html\r\n */\r\nfunction isMiddleClick(e) {\r\n    return (\r\n    // `which` is an old DOM API.\r\n    // tslint:disable-next-line:no-any\r\n    e.which === 2 ||\r\n        // `which` is an old DOM API.\r\n        // tslint:disable-next-line:no-any\r\n        (e.which == null &&\r\n            // `button` is an old DOM API.\r\n            // tslint:disable-next-line:no-any\r\n            e.button === 4) // middle click for IE\r\n    );\r\n}\r\n/**\r\n * Determines and returns whether the given event (which is assumed\r\n * to be a click event) is modified. A middle click is considered a modified\r\n * click to retain the default browser action, which opens a link in a new tab.\r\n * @param e The event.\r\n * @return Whether the given event is modified.\r\n */\r\nfunction isModifiedClickEvent(e) {\r\n    return (\r\n    // `metaKey` is an old DOM API.\r\n    // tslint:disable-next-line:no-any\r\n    (isMac && e.metaKey) ||\r\n        // `ctrlKey` is an old DOM API.\r\n        // tslint:disable-next-line:no-any\r\n        (!isMac && e.ctrlKey) ||\r\n        isMiddleClick(e) ||\r\n        // `shiftKey` is an old DOM API.\r\n        // tslint:disable-next-line:no-any\r\n        e.shiftKey);\r\n}\r\n/** Whether we are on WebKit (e.g., Chrome). */\r\nconst isWebKit = typeof navigator !== 'undefined' &&\r\n    !/Opera/.test(navigator.userAgent) &&\r\n    /WebKit/.test(navigator.userAgent);\r\n/** Whether we are on IE. */\r\nconst isIe = typeof navigator !== 'undefined' &&\r\n    (/MSIE/.test(navigator.userAgent) || /Trident/.test(navigator.userAgent));\r\n/** Whether we are on Gecko (e.g., Firefox). */\r\nconst isGecko = typeof navigator !== 'undefined' &&\r\n    !/Opera|WebKit/.test(navigator.userAgent) &&\r\n    /Gecko/.test(navigator.product);\r\n/**\r\n * Determines and returns whether the given element is a valid target for\r\n * keypress/keydown DOM events that act like regular DOM clicks.\r\n * @param el The element.\r\n * @return Whether the given element is a valid action key target.\r\n */\r\nfunction isValidActionKeyTarget(el) {\r\n    if (!('getAttribute' in el)) {\r\n        return false;\r\n    }\r\n    if (isTextControl(el)) {\r\n        return false;\r\n    }\r\n    if (isNativelyActivatable(el)) {\r\n        return false;\r\n    }\r\n    // `isContentEditable` is an old DOM API.\r\n    // tslint:disable-next-line:no-any\r\n    if (el.isContentEditable) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Whether an event has a modifier key activated.\r\n * @param e The event.\r\n * @return True, if a modifier key is activated.\r\n */\r\nfunction hasModifierKey(e) {\r\n    return (\r\n    // `ctrlKey` is an old DOM API.\r\n    // tslint:disable-next-line:no-any\r\n    e.ctrlKey ||\r\n        // `shiftKey` is an old DOM API.\r\n        // tslint:disable-next-line:no-any\r\n        e.shiftKey ||\r\n        // `altKey` is an old DOM API.\r\n        // tslint:disable-next-line:no-any\r\n        e.altKey ||\r\n        // `metaKey` is an old DOM API.\r\n        // tslint:disable-next-line:no-any\r\n        e.metaKey);\r\n}\r\n/**\r\n * Determines and returns whether the given event has a target that already\r\n * has event handlers attached because it is a native HTML control. Used to\r\n * determine if preventDefault should be called when isActionKeyEvent is true.\r\n * @param e The event.\r\n * @return If preventDefault should be called.\r\n */\r\nfunction shouldCallPreventDefaultOnNativeHtmlControl(e) {\r\n    const el = getTarget(e);\r\n    const tagName = el.tagName.toUpperCase();\r\n    const role = (el.getAttribute('role') || '').toUpperCase();\r\n    if (tagName === 'BUTTON' || role === 'BUTTON') {\r\n        return true;\r\n    }\r\n    if (!isNativeHTMLControl(el)) {\r\n        return false;\r\n    }\r\n    if (tagName === 'A') {\r\n        return false;\r\n    }\r\n    /**\r\n     * Fix for physical d-pads on feature phone platforms; the native event\r\n     * (ie. isTrusted: true) needs to fire to show the OPTION list. See\r\n     * b/135288469 for more info.\r\n     */\r\n    if (tagName === 'SELECT') {\r\n        return false;\r\n    }\r\n    if (processSpace(el)) {\r\n        return false;\r\n    }\r\n    if (isTextControl(el)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Determines and returns whether the given event acts like a regular DOM click,\r\n * and should be handled instead of the click.  If this returns true, the caller\r\n * will call preventDefault() to prevent a possible duplicate event.\r\n * This is represented by a keypress (keydown on Gecko browsers) on Enter or\r\n * Space key.\r\n * @param e The event.\r\n * @return True, if the event emulates a DOM click.\r\n */\r\nfunction isActionKeyEvent(e) {\r\n    let key = \r\n    // `which` is an old DOM API.\r\n    // tslint:disable-next-line:no-any\r\n    e.which ||\r\n        // `keyCode` is an old DOM API.\r\n        // tslint:disable-next-line:no-any\r\n        e.keyCode;\r\n    if (!key && e.key) {\r\n        key = ACTION_KEY_TO_KEYCODE[e.key];\r\n    }\r\n    if (isWebKit && key === KeyCode.MAC_ENTER) {\r\n        key = KeyCode.ENTER;\r\n    }\r\n    if (key !== KeyCode.ENTER && key !== KeyCode.SPACE) {\r\n        return false;\r\n    }\r\n    const el = getTarget(e);\r\n    if (e.type !== EventType.KEYDOWN || !isValidActionKeyTarget(el) || hasModifierKey(e)) {\r\n        return false;\r\n    }\r\n    // For <input type=\"checkbox\">, we must only handle the browser's native click\r\n    // event, so that the browser can toggle the checkbox.\r\n    if (processSpace(el) && key === KeyCode.SPACE) {\r\n        return false;\r\n    }\r\n    // If this element is non-focusable, ignore stray keystrokes (b/18337209)\r\n    // Sscreen readers can move without tab focus, so any tabIndex is focusable.\r\n    // See B/21809604\r\n    if (!isFocusable(el)) {\r\n        return false;\r\n    }\r\n    const type = (el.getAttribute('role') ||\r\n        el.type ||\r\n        el.tagName).toUpperCase();\r\n    const isSpecificTriggerKey = IDENTIFIER_TO_KEY_TRIGGER_MAPPING[type] % key === 0;\r\n    const isDefaultTriggerKey = !(type in IDENTIFIER_TO_KEY_TRIGGER_MAPPING) && key === KeyCode.ENTER;\r\n    const hasType = el.tagName.toUpperCase() !== 'INPUT' || !!el.type;\r\n    return (isSpecificTriggerKey || isDefaultTriggerKey) && hasType;\r\n}\r\n/**\r\n * Checks whether a DOM element can receive keyboard focus.\r\n * This code is based on goog.dom.isFocusable, but simplified since we shouldn't\r\n * care about visibility if we're already handling a keyboard event.\r\n */\r\nfunction isFocusable(el) {\r\n    return ((el.tagName in NATIVELY_FOCUSABLE_ELEMENTS || hasSpecifiedTabIndex(el)) &&\r\n        !el.disabled);\r\n}\r\n/**\r\n * @param element Element to check.\r\n * @return Whether the element has a specified tab index.\r\n */\r\nfunction hasSpecifiedTabIndex(element) {\r\n    // IE returns 0 for an unset tabIndex, so we must use getAttributeNode(),\r\n    // which returns an object with a 'specified' property if tabIndex is\r\n    // specified.  This works on other browsers, too.\r\n    const attrNode = element.getAttributeNode('tabindex'); // Must be lowercase!\r\n    return attrNode != null && attrNode.specified;\r\n}\r\n/** Element tagnames that are focusable by default. */\r\nconst NATIVELY_FOCUSABLE_ELEMENTS = {\r\n    'A': 1,\r\n    'INPUT': 1,\r\n    'TEXTAREA': 1,\r\n    'SELECT': 1,\r\n    'BUTTON': 1,\r\n};\r\n/** @return True, if the Space key was pressed. */\r\nfunction isSpaceKeyEvent(e) {\r\n    const key = \r\n    // `which` is an old DOM API.\r\n    // tslint:disable-next-line:no-any\r\n    e.which ||\r\n        // `keyCode` is an old DOM API.\r\n        // tslint:disable-next-line:no-any\r\n        e.keyCode;\r\n    const el = getTarget(e);\r\n    const elementName = (el.type || el.tagName).toUpperCase();\r\n    return key === KeyCode.SPACE && elementName !== 'CHECKBOX';\r\n}\r\n/**\r\n * Determines whether the event corresponds to a non-bubbling mouse\r\n * event type (mouseenter, mouseleave, pointerenter, and pointerleave).\r\n *\r\n * During mouseover (mouseenter) and pointerover (pointerenter), the\r\n * relatedTarget is the element being entered from. During mouseout (mouseleave)\r\n * and pointerout (pointerleave), the relatedTarget is the element being exited\r\n * to.\r\n *\r\n * In both cases, if relatedTarget is outside target, then the corresponding\r\n * special event has occurred, otherwise it hasn't.\r\n *\r\n * @param e The mouseover/mouseout event.\r\n * @param type The type of the mouse special event.\r\n * @param element The element on which the jsaction for the\r\n *     mouseenter/mouseleave event is defined.\r\n * @return True if the event is a mouseenter/mouseleave event.\r\n */\r\nfunction isMouseSpecialEvent(e, type, element) {\r\n    // `relatedTarget` is an old DOM API.\r\n    // tslint:disable-next-line:no-any\r\n    const related = e.relatedTarget;\r\n    return (((e.type === EventType.MOUSEOVER && type === EventType.MOUSEENTER) ||\r\n        (e.type === EventType.MOUSEOUT && type === EventType.MOUSELEAVE) ||\r\n        (e.type === EventType.POINTEROVER && type === EventType.POINTERENTER) ||\r\n        (e.type === EventType.POINTEROUT && type === EventType.POINTERLEAVE)) &&\r\n        (!related || (related !== element && !contains(element, related))));\r\n}\r\n/**\r\n * Creates a new EventLike object for a mouseenter/mouseleave event that's\r\n * derived from the original corresponding mouseover/mouseout event.\r\n * @param e The event.\r\n * @param target The element on which the jsaction for the mouseenter/mouseleave\r\n *     event is defined.\r\n * @return A modified event-like object copied from the event object passed into\r\n *     this function.\r\n */\r\nfunction createMouseSpecialEvent(e, target) {\r\n    // We have to create a copy of the event object because we need to mutate\r\n    // its fields. We do this for the special mouse events because the event\r\n    // target needs to be retargeted to the action element rather than the real\r\n    // element (since we are simulating the special mouse events with mouseover/\r\n    // mouseout).\r\n    //\r\n    // Since we're making a copy anyways, we might as well attempt to convert\r\n    // this event into a pseudo-real mouseenter/mouseleave event by adjusting\r\n    // its type.\r\n    //\r\n    // tslint:disable-next-line:no-any\r\n    const copy = {};\r\n    for (const property in e) {\r\n        if (property === 'srcElement' || property === 'target') {\r\n            continue;\r\n        }\r\n        const key = property;\r\n        // Making a copy requires iterating through all properties of `Event`.\r\n        // tslint:disable-next-line:no-dict-access-on-struct-type\r\n        const value = e[key];\r\n        if (typeof value === 'function') {\r\n            continue;\r\n        }\r\n        // Value should be the expected type, but the value of `key` is not known\r\n        // statically.\r\n        // tslint:disable-next-line:no-any\r\n        copy[key] = value;\r\n    }\r\n    if (e.type === EventType.MOUSEOVER) {\r\n        copy['type'] = EventType.MOUSEENTER;\r\n    }\r\n    else if (e.type === EventType.MOUSEOUT) {\r\n        copy['type'] = EventType.MOUSELEAVE;\r\n    }\r\n    else if (e.type === EventType.POINTEROVER) {\r\n        copy['type'] = EventType.POINTERENTER;\r\n    }\r\n    else {\r\n        copy['type'] = EventType.POINTERLEAVE;\r\n    }\r\n    copy['target'] = copy['srcElement'] = target;\r\n    copy['bubbles'] = false;\r\n    return copy;\r\n}\r\n/**\r\n * Returns touch data extracted from the touch event: clientX, clientY, screenX\r\n * and screenY. If the event has no touch information at all, the returned\r\n * value is null.\r\n *\r\n * The fields of this Object are unquoted.\r\n *\r\n * @param event A touch event.\r\n */\r\nfunction getTouchData(event) {\r\n    const touch = (event.changedTouches && event.changedTouches[0]) || (event.touches && event.touches[0]);\r\n    if (!touch) {\r\n        return null;\r\n    }\r\n    return {\r\n        clientX: touch.clientX,\r\n        clientY: touch.clientY,\r\n        screenX: touch.screenX,\r\n        screenY: touch.screenY,\r\n    };\r\n}\r\n/**\r\n * Creates a new EventLike object for a \"click\" event that's derived from the\r\n * original corresponding \"touchend\" event for a fast-click implementation.\r\n *\r\n * It takes a touch event, adds common fields found in a click event and\r\n * changes the type to 'click', so that the resulting event looks more like\r\n * a real click event.\r\n *\r\n * @param event A touch event.\r\n * @return A modified event-like object copied from the event object passed into\r\n *     this function.\r\n */\r\nfunction recreateTouchEventAsClick(event) {\r\n    const click = {};\r\n    click['originalEventType'] = event.type;\r\n    click['type'] = EventType.CLICK;\r\n    for (const property in event) {\r\n        if (property === 'type' || property === 'srcElement') {\r\n            continue;\r\n        }\r\n        const key = property;\r\n        // Making a copy requires iterating through all properties of `TouchEvent`.\r\n        // tslint:disable-next-line:no-dict-access-on-struct-type\r\n        const value = event[key];\r\n        if (typeof value === 'function') {\r\n            continue;\r\n        }\r\n        // Value should be the expected type, but the value of `key` is not known\r\n        // statically.\r\n        // tslint:disable-next-line:no-any\r\n        click[key] = value;\r\n    }\r\n    // Ensure that the event has the most recent timestamp. This timestamp\r\n    // may be used in the future to validate or cancel subsequent click events.\r\n    click['timeStamp'] = Date.now();\r\n    // Emulate preventDefault and stopPropagation behavior\r\n    click['defaultPrevented'] = false;\r\n    click['preventDefault'] = syntheticPreventDefault;\r\n    click['_propagationStopped'] = false;\r\n    click['stopPropagation'] = syntheticStopPropagation;\r\n    // Emulate click coordinates using touch info\r\n    const touch = getTouchData(event);\r\n    if (touch) {\r\n        click['clientX'] = touch.clientX;\r\n        click['clientY'] = touch.clientY;\r\n        click['screenX'] = touch.screenX;\r\n        click['screenY'] = touch.screenY;\r\n    }\r\n    return click;\r\n}\r\n/**\r\n * An implementation of \"preventDefault\" for a synthesized event. Simply\r\n * sets \"defaultPrevented\" property to true.\r\n */\r\nfunction syntheticPreventDefault() {\r\n    this.defaultPrevented = true;\r\n}\r\n/**\r\n * An implementation of \"stopPropagation\" for a synthesized event. It simply\r\n * sets a synthetic non-standard \"_propagationStopped\" property to true.\r\n */\r\nfunction syntheticStopPropagation() {\r\n    this._propagationStopped = true;\r\n}\r\n/**\r\n * Mapping of KeyboardEvent.key values to\r\n * KeyCode values.\r\n */\r\nconst ACTION_KEY_TO_KEYCODE = {\r\n    'Enter': KeyCode.ENTER,\r\n    ' ': KeyCode.SPACE,\r\n};\r\n/**\r\n * Mapping of HTML element identifiers (ARIA role, type, or tagName) to the\r\n * keys (enter and/or space) that should activate them. A value of zero means\r\n * that both should activate them.\r\n */\r\nconst IDENTIFIER_TO_KEY_TRIGGER_MAPPING = {\r\n    'A': KeyCode.ENTER,\r\n    'BUTTON': 0,\r\n    'CHECKBOX': KeyCode.SPACE,\r\n    'COMBOBOX': KeyCode.ENTER,\r\n    'FILE': 0,\r\n    'GRIDCELL': KeyCode.ENTER,\r\n    'LINK': KeyCode.ENTER,\r\n    'LISTBOX': KeyCode.ENTER,\r\n    'MENU': 0,\r\n    'MENUBAR': 0,\r\n    'MENUITEM': 0,\r\n    'MENUITEMCHECKBOX': 0,\r\n    'MENUITEMRADIO': 0,\r\n    'OPTION': 0,\r\n    'RADIO': KeyCode.SPACE,\r\n    'RADIOGROUP': KeyCode.SPACE,\r\n    'RESET': 0,\r\n    'SUBMIT': 0,\r\n    'SWITCH': KeyCode.SPACE,\r\n    'TAB': 0,\r\n    'TREE': KeyCode.ENTER,\r\n    'TREEITEM': KeyCode.ENTER,\r\n};\r\n/**\r\n * Returns whether or not to process space based on the type of the element;\r\n * checks to make sure that type is not null.\r\n * @param element The element.\r\n * @return Whether or not to process space based on type.\r\n */\r\nfunction processSpace(element) {\r\n    const type = (element.getAttribute('type') || element.tagName).toUpperCase();\r\n    return type in PROCESS_SPACE;\r\n}\r\n/**\r\n * Returns whether or not the given element is a text control.\r\n * @param el The element.\r\n * @return Whether or not the given element is a text control.\r\n */\r\nfunction isTextControl(el) {\r\n    const type = (el.getAttribute('type') || el.tagName).toUpperCase();\r\n    return type in TEXT_CONTROLS;\r\n}\r\n/**\r\n * Returns if the given element is a native HTML control.\r\n * @param el The element.\r\n * @return If the given element is a native HTML control.\r\n */\r\nfunction isNativeHTMLControl(el) {\r\n    return el.tagName.toUpperCase() in NATIVE_HTML_CONTROLS;\r\n}\r\n/**\r\n * Returns if the given element is natively activatable. Browsers emit click\r\n * events for natively activatable elements, even when activated via keyboard.\r\n * For these elements, we don't need to raise a11y click events.\r\n * @param el The element.\r\n * @return If the given element is a native HTML control.\r\n */\r\nfunction isNativelyActivatable(el) {\r\n    return (el.tagName.toUpperCase() === 'BUTTON' ||\r\n        (!!el.type && el.type.toUpperCase() === 'FILE'));\r\n}\r\n/**\r\n * HTML <input> types (not ARIA roles) which will auto-trigger a click event for\r\n * the Space key, with side-effects. We will not call preventDefault if space is\r\n * pressed, nor will we raise a11y click events.  For all other elements, we can\r\n * suppress the default event (which has no desired side-effects) and handle the\r\n * keydown ourselves.\r\n */\r\nconst PROCESS_SPACE = {\r\n    'CHECKBOX': true,\r\n    'FILE': true,\r\n    'OPTION': true,\r\n    'RADIO': true,\r\n};\r\n/** TagNames and Input types for which to not process enter/space as click. */\r\nconst TEXT_CONTROLS = {\r\n    'COLOR': true,\r\n    'DATE': true,\r\n    'DATETIME': true,\r\n    'DATETIME-LOCAL': true,\r\n    'EMAIL': true,\r\n    'MONTH': true,\r\n    'NUMBER': true,\r\n    'PASSWORD': true,\r\n    'RANGE': true,\r\n    'SEARCH': true,\r\n    'TEL': true,\r\n    'TEXT': true,\r\n    'TEXTAREA': true,\r\n    'TIME': true,\r\n    'URL': true,\r\n    'WEEK': true,\r\n};\r\n/** TagNames that are native HTML controls. */\r\nconst NATIVE_HTML_CONTROLS = {\r\n    'A': true,\r\n    'AREA': true,\r\n    'BUTTON': true,\r\n    'DIALOG': true,\r\n    'IMG': true,\r\n    'INPUT': true,\r\n    'LINK': true,\r\n    'MENU': true,\r\n    'OPTGROUP': true,\r\n    'OPTION': true,\r\n    'PROGRESS': true,\r\n    'SELECT': true,\r\n    'TEXTAREA': true,\r\n};\r\n/** Exported for testing. */\r\nconst testing = {\r\n    setIsMac(value) {\r\n        isMac = value;\r\n    },\r\n};\r\n\r\n/**\r\n * Since maps from event to action are immutable we can use a single map\r\n * to represent the empty map.\r\n */\r\nconst EMPTY_ACTION_MAP = {};\r\n/**\r\n * This regular expression matches a semicolon.\r\n */\r\nconst REGEXP_SEMICOLON = /\\s*;\\s*/;\r\n/** If no event type is defined, defaults to `click`. */\r\nconst DEFAULT_EVENT_TYPE = EventType.CLICK;\r\n/** Resolves actions for Events. */\r\nclass ActionResolver {\r\n    constructor({ syntheticMouseEventSupport = false, } = {}) {\r\n        this.a11yClickSupport = false;\r\n        this.updateEventInfoForA11yClick = undefined;\r\n        this.preventDefaultForA11yClick = undefined;\r\n        this.populateClickOnlyAction = undefined;\r\n        this.syntheticMouseEventSupport = syntheticMouseEventSupport;\r\n    }\r\n    resolveEventType(eventInfo) {\r\n        // We distinguish modified and plain clicks in order to support the\r\n        // default browser behavior of modified clicks on links; usually to\r\n        // open the URL of the link in new tab or new window on ctrl/cmd\r\n        // click. A DOM 'click' event is mapped to the jsaction 'click'\r\n        // event iff there is no modifier present on the event. If there is\r\n        // a modifier, it's mapped to 'clickmod' instead.\r\n        //\r\n        // It's allowed to omit the event in the jsaction attribute. In that\r\n        // case, 'click' is assumed. Thus the following two are equivalent:\r\n        //\r\n        //   <a href=\"someurl\" jsaction=\"gna.fu\">\r\n        //   <a href=\"someurl\" jsaction=\"click:gna.fu\">\r\n        //\r\n        // For unmodified clicks, EventContract invokes the jsaction\r\n        // 'gna.fu'. For modified clicks, EventContract won't find a\r\n        // suitable action and leave the event to be handled by the\r\n        // browser.\r\n        //\r\n        // In order to also invoke a jsaction handler for a modifier click,\r\n        // 'clickmod' needs to be used:\r\n        //\r\n        //   <a href=\"someurl\" jsaction=\"clickmod:gna.fu\">\r\n        //\r\n        // EventContract invokes the jsaction 'gna.fu' for modified\r\n        // clicks. Unmodified clicks are left to the browser.\r\n        //\r\n        // In order to set up the event contract to handle both clickonly and\r\n        // clickmod, only addEvent(EventType.CLICK) is necessary.\r\n        //\r\n        // In order to set up the event contract to handle click,\r\n        // addEvent() is necessary for CLICK, KEYDOWN, and KEYPRESS event types.  If\r\n        // a11y click support is enabled, addEvent() will set up the appropriate key\r\n        // event handler automatically.\r\n        if (getEventType(eventInfo) === EventType.CLICK &&\r\n            isModifiedClickEvent(getEvent(eventInfo))) {\r\n            setEventType(eventInfo, EventType.CLICKMOD);\r\n        }\r\n        else if (this.a11yClickSupport) {\r\n            this.updateEventInfoForA11yClick(eventInfo);\r\n        }\r\n    }\r\n    resolveAction(eventInfo) {\r\n        if (getResolved(eventInfo)) {\r\n            return;\r\n        }\r\n        this.populateAction(eventInfo, getTargetElement(eventInfo));\r\n        setResolved(eventInfo, true);\r\n    }\r\n    resolveParentAction(eventInfo) {\r\n        const action = getAction(eventInfo);\r\n        const actionElement = action && getActionElement(action);\r\n        unsetAction(eventInfo);\r\n        const parentNode = actionElement && this.getParentNode(actionElement);\r\n        if (!parentNode) {\r\n            return;\r\n        }\r\n        this.populateAction(eventInfo, parentNode);\r\n    }\r\n    /**\r\n     * Searches for a jsaction that the DOM event maps to and creates an\r\n     * object containing event information used for dispatching by\r\n     * jsaction.Dispatcher. This method populates the `action` and `actionElement`\r\n     * fields of the EventInfo object passed in by finding the first\r\n     * jsaction attribute above the target Node of the event, and below\r\n     * the container Node, that specifies a jsaction for the event\r\n     * type. If no such jsaction is found, then action is undefined.\r\n     *\r\n     * @param eventInfo `EventInfo` to set `action` and `actionElement` if an\r\n     *    action is found on any `Element` in the path of the `Event`.\r\n     */\r\n    populateAction(eventInfo, currentTarget) {\r\n        let actionElement = currentTarget;\r\n        while (actionElement && actionElement !== getContainer(eventInfo)) {\r\n            if (actionElement.nodeType === Node.ELEMENT_NODE) {\r\n                this.populateActionOnElement(actionElement, eventInfo);\r\n            }\r\n            if (getAction(eventInfo)) {\r\n                // An event is handled by at most one jsaction. Thus we stop at the\r\n                // first matching jsaction specified in a jsaction attribute up the\r\n                // ancestor chain of the event target node.\r\n                break;\r\n            }\r\n            actionElement = this.getParentNode(actionElement);\r\n        }\r\n        const action = getAction(eventInfo);\r\n        if (!action) {\r\n            // No action found.\r\n            return;\r\n        }\r\n        if (this.a11yClickSupport) {\r\n            this.preventDefaultForA11yClick(eventInfo);\r\n        }\r\n        // We attempt to handle the mouseenter/mouseleave events here by\r\n        // detecting whether the mouseover/mouseout events correspond to\r\n        // entering/leaving an element.\r\n        if (this.syntheticMouseEventSupport) {\r\n            if (getEventType(eventInfo) === EventType.MOUSEENTER ||\r\n                getEventType(eventInfo) === EventType.MOUSELEAVE ||\r\n                getEventType(eventInfo) === EventType.POINTERENTER ||\r\n                getEventType(eventInfo) === EventType.POINTERLEAVE) {\r\n                // We attempt to handle the mouseenter/mouseleave events here by\r\n                // detecting whether the mouseover/mouseout events correspond to\r\n                // entering/leaving an element.\r\n                if (isMouseSpecialEvent(getEvent(eventInfo), getEventType(eventInfo), getActionElement(action))) {\r\n                    // If both mouseover/mouseout and mouseenter/mouseleave events are\r\n                    // enabled, two separate handlers for mouseover/mouseout are\r\n                    // registered. Both handlers will see the same event instance\r\n                    // so we create a copy to avoid interfering with the dispatching of\r\n                    // the mouseover/mouseout event.\r\n                    const copiedEvent = createMouseSpecialEvent(getEvent(eventInfo), getActionElement(action));\r\n                    setEvent(eventInfo, copiedEvent);\r\n                    // Since the mouseenter/mouseleave events do not bubble, the target\r\n                    // of the event is technically the `actionElement` (the node with the\r\n                    // `jsaction` attribute)\r\n                    setTargetElement(eventInfo, getActionElement(action));\r\n                }\r\n                else {\r\n                    unsetAction(eventInfo);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Walk to the parent node, unless the node has a different owner in\r\n     * which case we walk to the owner. Attempt to walk to host of a\r\n     * shadow root if needed.\r\n     */\r\n    getParentNode(element) {\r\n        const owner = element[OWNER];\r\n        if (owner) {\r\n            return owner;\r\n        }\r\n        const parentNode = element.parentNode;\r\n        if (parentNode?.nodeName === '#document-fragment') {\r\n            return parentNode?.host ?? null;\r\n        }\r\n        return parentNode;\r\n    }\r\n    /**\r\n     * Accesses the jsaction map on a node and retrieves the name of the\r\n     * action the given event is mapped to, if any. It parses the\r\n     * attribute value and stores it in a property on the node for\r\n     * subsequent retrieval without re-parsing and re-accessing the\r\n     * attribute.\r\n     *\r\n     * @param actionElement The DOM node to retrieve the jsaction map from.\r\n     * @param eventInfo `EventInfo` to set `action` and `actionElement` if an\r\n     *    action is found on the `actionElement`.\r\n     */\r\n    populateActionOnElement(actionElement, eventInfo) {\r\n        const actionMap = this.parseActions(actionElement);\r\n        const actionName = actionMap[getEventType(eventInfo)];\r\n        if (actionName !== undefined) {\r\n            setAction(eventInfo, actionName, actionElement);\r\n        }\r\n        if (this.a11yClickSupport) {\r\n            this.populateClickOnlyAction(actionElement, eventInfo, actionMap);\r\n        }\r\n    }\r\n    /**\r\n     * Parses and caches an element's jsaction element into a map.\r\n     *\r\n     * This is primarily for internal use.\r\n     *\r\n     * @param actionElement The DOM node to retrieve the jsaction map from.\r\n     * @return Map from event to qualified name of the jsaction bound to it.\r\n     */\r\n    parseActions(actionElement) {\r\n        let actionMap = get(actionElement);\r\n        if (!actionMap) {\r\n            const jsactionAttribute = actionElement.getAttribute(Attribute.JSACTION);\r\n            if (!jsactionAttribute) {\r\n                actionMap = EMPTY_ACTION_MAP;\r\n                set(actionElement, actionMap);\r\n            }\r\n            else {\r\n                actionMap = getParsed(jsactionAttribute);\r\n                if (!actionMap) {\r\n                    actionMap = {};\r\n                    const values = jsactionAttribute.split(REGEXP_SEMICOLON);\r\n                    for (let idx = 0; idx < values.length; idx++) {\r\n                        const value = values[idx];\r\n                        if (!value) {\r\n                            continue;\r\n                        }\r\n                        const colon = value.indexOf(Char.EVENT_ACTION_SEPARATOR);\r\n                        const hasColon = colon !== -1;\r\n                        const type = hasColon ? value.substr(0, colon).trim() : DEFAULT_EVENT_TYPE;\r\n                        const action = hasColon ? value.substr(colon + 1).trim() : value;\r\n                        actionMap[type] = action;\r\n                    }\r\n                    setParsed(jsactionAttribute, actionMap);\r\n                }\r\n                set(actionElement, actionMap);\r\n            }\r\n        }\r\n        return actionMap;\r\n    }\r\n    addA11yClickSupport(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction) {\r\n        this.a11yClickSupport = true;\r\n        this.updateEventInfoForA11yClick = updateEventInfoForA11yClick;\r\n        this.preventDefaultForA11yClick = preventDefaultForA11yClick;\r\n        this.populateClickOnlyAction = populateClickOnlyAction;\r\n    }\r\n}\r\n\r\n/**\r\n * @fileoverview An enum to control who can call certain jsaction APIs.\r\n */\r\nvar Restriction;\r\n(function (Restriction) {\r\n    Restriction[Restriction[\"I_AM_THE_JSACTION_FRAMEWORK\"] = 0] = \"I_AM_THE_JSACTION_FRAMEWORK\";\r\n})(Restriction || (Restriction = {}));\r\n\r\n/**\r\n * Receives a DOM event, determines the jsaction associated with the source\r\n * element of the DOM event, and invokes the handler associated with the\r\n * jsaction.\r\n */\r\nclass Dispatcher {\r\n    /**\r\n     * Options are:\r\n     *   - `eventReplayer`: When the event contract dispatches replay events\r\n     *      to the Dispatcher, the Dispatcher collects them and in the next tick\r\n     *      dispatches them to the `eventReplayer`. Defaults to dispatching to `dispatchDelegate`.\r\n     * @param dispatchDelegate A function that should handle dispatching an `EventInfoWrapper` to handlers.\r\n     */\r\n    constructor(dispatchDelegate, { actionResolver, eventReplayer, } = {}) {\r\n        this.dispatchDelegate = dispatchDelegate;\r\n        /** Whether the event replay is scheduled. */\r\n        this.eventReplayScheduled = false;\r\n        /** The queue of events. */\r\n        this.replayEventInfoWrappers = [];\r\n        this.actionResolver = actionResolver;\r\n        this.eventReplayer = eventReplayer;\r\n    }\r\n    /**\r\n     * Receives an event or the event queue from the EventContract. The event\r\n     * queue is copied and it attempts to replay.\r\n     * If event info is passed in it looks for an action handler that can handle\r\n     * the given event.  If there is no handler registered queues the event and\r\n     * checks if a loader is registered for the given namespace. If so, calls it.\r\n     *\r\n     * Alternatively, if in global dispatch mode, calls all registered global\r\n     * handlers for the appropriate event type.\r\n     *\r\n     * The three functionalities of this call are deliberately not split into\r\n     * three methods (and then declared as an abstract interface), because the\r\n     * interface is used by EventContract, which lives in a different jsbinary.\r\n     * Therefore the interface between the three is defined entirely in terms that\r\n     * are invariant under jscompiler processing (Function and Array, as opposed\r\n     * to a custom type with method names).\r\n     *\r\n     * @param eventInfo The info for the event that triggered this call or the\r\n     *     queue of events from EventContract.\r\n     */\r\n    dispatch(eventInfo) {\r\n        const eventInfoWrapper = new EventInfoWrapper(eventInfo);\r\n        this.actionResolver?.resolveEventType(eventInfo);\r\n        this.actionResolver?.resolveAction(eventInfo);\r\n        const action = eventInfoWrapper.getAction();\r\n        if (action && shouldPreventDefaultBeforeDispatching(action.element, eventInfoWrapper)) {\r\n            preventDefault(eventInfoWrapper.getEvent());\r\n        }\r\n        if (this.eventReplayer && eventInfoWrapper.getIsReplay()) {\r\n            this.scheduleEventInfoWrapperReplay(eventInfoWrapper);\r\n            return;\r\n        }\r\n        this.dispatchDelegate(eventInfoWrapper);\r\n    }\r\n    /**\r\n     * Schedules an `EventInfoWrapper` for replay. The replaying will happen in its own\r\n     * stack once the current flow cedes control. This is done to mimic\r\n     * browser event handling.\r\n     */\r\n    scheduleEventInfoWrapperReplay(eventInfoWrapper) {\r\n        this.replayEventInfoWrappers.push(eventInfoWrapper);\r\n        if (this.eventReplayScheduled) {\r\n            return;\r\n        }\r\n        this.eventReplayScheduled = true;\r\n        Promise.resolve().then(() => {\r\n            this.eventReplayScheduled = false;\r\n            this.eventReplayer(this.replayEventInfoWrappers);\r\n        });\r\n    }\r\n}\r\n/**\r\n * Creates an `EventReplayer` that calls the `replay` function for every `eventInfoWrapper` in\r\n * the queue.\r\n */\r\nfunction createEventReplayer(replay) {\r\n    return (eventInfoWrappers) => {\r\n        for (const eventInfoWrapper of eventInfoWrappers) {\r\n            replay(eventInfoWrapper);\r\n        }\r\n    };\r\n}\r\n/**\r\n * Returns true if the default action of this event should be prevented before\r\n * this event is dispatched.\r\n */\r\nfunction shouldPreventDefaultBeforeDispatching(actionElement, eventInfoWrapper) {\r\n    // Prevent browser from following <a> node links if a jsaction is present\r\n    // and we are dispatching the action now. Note that the targetElement may be\r\n    // a child of an anchor that has a jsaction attached. For that reason, we\r\n    // need to check the actionElement rather than the targetElement.\r\n    return ((actionElement.tagName === 'A' && eventInfoWrapper.getEventType() === EventType.CLICK) ||\r\n        eventInfoWrapper.getEventType() === EventType.CLICKMOD);\r\n}\r\n/**\r\n * Registers deferred functionality for an EventContract and a Jsaction\r\n * Dispatcher.\r\n */\r\nfunction registerDispatcher$1(eventContract, dispatcher) {\r\n    eventContract.ecrd((eventInfo) => {\r\n        dispatcher.dispatch(eventInfo);\r\n    }, Restriction.I_AM_THE_JSACTION_FRAMEWORK);\r\n}\r\n\r\n/** An internal symbol used to indicate whether propagation should be stopped or not. */\r\nconst PROPAGATION_STOPPED_SYMBOL = Symbol.for('propagationStopped');\r\n/** Extra event phases beyond what the browser provides. */\r\nconst EventPhase = {\r\n    REPLAY: 101,\r\n};\r\nconst PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser dispatch, `preventDefault` would have no ' +\r\n    'effect. You can check whether an event is being replayed by accessing the event phase: ' +\r\n    '`event.eventPhase === EventPhase.REPLAY`.';\r\nconst PREVENT_DEFAULT_ERROR_MESSAGE = `\\`preventDefault\\` called during event replay.`;\r\nconst COMPOSED_PATH_ERROR_MESSAGE_DETAILS = () => ngDevMode\r\n    ? ' Because event replay occurs after browser ' +\r\n        'dispatch, `composedPath()` will be empty. Iterate parent nodes from `event.target` or ' +\r\n        '`event.currentTarget` if you need to check elements in the event path.'\r\n    : '';\r\nconst COMPOSED_PATH_ERROR_MESSAGE = `\\`composedPath\\` called during event replay.`;\r\n/**\r\n * A dispatcher that uses browser-based `Event` semantics, for example bubbling, `stopPropagation`,\r\n * `currentTarget`, etc.\r\n */\r\nclass EventDispatcher {\r\n    constructor(dispatchDelegate) {\r\n        this.dispatchDelegate = dispatchDelegate;\r\n        this.actionResolver = new ActionResolver();\r\n        this.dispatcher = new Dispatcher((eventInfoWrapper) => {\r\n            this.dispatchToDelegate(eventInfoWrapper);\r\n        }, {\r\n            actionResolver: this.actionResolver,\r\n        });\r\n    }\r\n    /**\r\n     * The entrypoint for the `EventContract` dispatch.\r\n     */\r\n    dispatch(eventInfo) {\r\n        this.dispatcher.dispatch(eventInfo);\r\n    }\r\n    /** Internal method that does basic disaptching. */\r\n    dispatchToDelegate(eventInfoWrapper) {\r\n        if (eventInfoWrapper.getIsReplay()) {\r\n            prepareEventForReplay(eventInfoWrapper);\r\n        }\r\n        prepareEventForBubbling(eventInfoWrapper);\r\n        while (eventInfoWrapper.getAction()) {\r\n            prepareEventForDispatch(eventInfoWrapper);\r\n            this.dispatchDelegate(eventInfoWrapper.getEvent(), eventInfoWrapper.getAction().name);\r\n            if (propagationStopped(eventInfoWrapper)) {\r\n                return;\r\n            }\r\n            this.actionResolver.resolveParentAction(eventInfoWrapper.eventInfo);\r\n        }\r\n    }\r\n}\r\nfunction prepareEventForBubbling(eventInfoWrapper) {\r\n    const event = eventInfoWrapper.getEvent();\r\n    const stopPropagation = () => {\r\n        event[PROPAGATION_STOPPED_SYMBOL] = true;\r\n    };\r\n    patchEventInstance(event, 'stopPropagation', stopPropagation);\r\n    patchEventInstance(event, 'stopImmediatePropagation', stopPropagation);\r\n}\r\nfunction propagationStopped(eventInfoWrapper) {\r\n    const event = eventInfoWrapper.getEvent();\r\n    return !!event[PROPAGATION_STOPPED_SYMBOL];\r\n}\r\nfunction prepareEventForReplay(eventInfoWrapper) {\r\n    const event = eventInfoWrapper.getEvent();\r\n    const target = eventInfoWrapper.getTargetElement();\r\n    patchEventInstance(event, 'target', target);\r\n    patchEventInstance(event, 'eventPhase', EventPhase.REPLAY);\r\n    patchEventInstance(event, 'preventDefault', () => {\r\n        throw new Error(PREVENT_DEFAULT_ERROR_MESSAGE + (ngDevMode ? PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS : ''));\r\n    });\r\n    patchEventInstance(event, 'composedPath', () => {\r\n        throw new Error(COMPOSED_PATH_ERROR_MESSAGE + (ngDevMode ? COMPOSED_PATH_ERROR_MESSAGE_DETAILS : ''));\r\n    });\r\n}\r\nfunction prepareEventForDispatch(eventInfoWrapper) {\r\n    const event = eventInfoWrapper.getEvent();\r\n    const currentTarget = eventInfoWrapper.getAction()?.element;\r\n    if (currentTarget) {\r\n        patchEventInstance(event, 'currentTarget', currentTarget, {\r\n            // `currentTarget` is going to get reassigned every dispatch.\r\n            configurable: true,\r\n        });\r\n    }\r\n}\r\n/**\r\n * Patch `Event` instance during non-standard `Event` dispatch. This patches just the `Event`\r\n * instance that the browser created, it does not patch global properties or methods.\r\n *\r\n * This is necessary because dispatching an `Event` outside of browser dispatch results in\r\n * incorrect properties and methods that need to be polyfilled or do not work.\r\n *\r\n * JSAction dispatch adds two extra \"phases\" to event dispatch:\r\n * 1. Event delegation - the event is being dispatched by a delegating event handler on a container\r\n *    (typically `window.document.documentElement`), to a delegated event handler on some child\r\n *    element. Certain `Event` properties will be unintuitive, such as `currentTarget`, which would\r\n *    be the container rather than the child element. Bubbling would also not work. In order to\r\n *    emulate the browser, these properties and methods on the `Event` are patched.\r\n * 2. Event replay - the event is being dispatched by the framework once the handlers have been\r\n *    loaded (during hydration, or late-loaded). Certain `Event` properties can be unset by the\r\n *    browser because the `Event` is no longer actively being dispatched, such as `target`. Other\r\n *    methods have no effect because the `Event` has already been dispatched, such as\r\n *    `preventDefault`. Bubbling would also not work. These properties and methods are patched,\r\n *    either to fill in information that the browser may have removed, or to throw errors in methods\r\n *    that no longer behave as expected.\r\n */\r\nfunction patchEventInstance(event, property, value, { configurable = false } = {}) {\r\n    Object.defineProperty(event, property, { value, configurable });\r\n}\r\n/**\r\n * Registers deferred functionality for an EventContract and a Jsaction\r\n * Dispatcher.\r\n */\r\nfunction registerDispatcher(eventContract, dispatcher) {\r\n    eventContract.ecrd((eventInfo) => {\r\n        dispatcher.dispatch(eventInfo);\r\n    }, Restriction.I_AM_THE_JSACTION_FRAMEWORK);\r\n}\r\n\r\n/**\r\n * Whether the user agent is running on iOS.\r\n */\r\nconst isIos = typeof navigator !== 'undefined' && /iPhone|iPad|iPod/.test(navigator.userAgent);\r\n/**\r\n * A class representing a container node and all the event handlers\r\n * installed on it. Used so that handlers can be cleaned up if the\r\n * container is removed from the contract.\r\n */\r\nclass EventContractContainer {\r\n    /**\r\n     * @param element The container Element.\r\n     */\r\n    constructor(element) {\r\n        this.element = element;\r\n        /**\r\n         * Array of event handlers and their corresponding event types that are\r\n         * installed on this container.\r\n         *\r\n         */\r\n        this.handlerInfos = [];\r\n    }\r\n    /**\r\n     * Installs the provided installer on the element owned by this container,\r\n     * and maintains a reference to resulting handler in order to remove it\r\n     * later if desired.\r\n     */\r\n    addEventListener(eventType, getHandler) {\r\n        // In iOS, event bubbling doesn't happen automatically in any DOM element,\r\n        // unless it has an onclick attribute or DOM event handler attached to it.\r\n        // This breaks JsAction in some cases. See \"Making Elements Clickable\"\r\n        // section at http://goo.gl/2VoGnB.\r\n        //\r\n        // A workaround for this issue is to change the CSS cursor style to 'pointer'\r\n        // for the container element, which magically turns on event bubbling. This\r\n        // solution is described in the comments section at http://goo.gl/6pEO1z.\r\n        //\r\n        // We use a navigator.userAgent check here as this problem is present both\r\n        // on Mobile Safari and thin WebKit wrappers, such as Chrome for iOS.\r\n        if (isIos) {\r\n            this.element.style.cursor = 'pointer';\r\n        }\r\n        this.handlerInfos.push(addEventListener(this.element, eventType, getHandler(this.element)));\r\n    }\r\n    /**\r\n     * Removes all the handlers installed on this container.\r\n     */\r\n    cleanUp() {\r\n        for (let i = 0; i < this.handlerInfos.length; i++) {\r\n            removeEventListener(this.element, this.handlerInfos[i]);\r\n        }\r\n        this.handlerInfos = [];\r\n    }\r\n}\r\n\r\n/**\r\n * Update `EventInfo` to be `eventType = 'click'` and sets `a11yClickKey` if it\r\n * is a a11y click.\r\n */\r\nfunction updateEventInfoForA11yClick(eventInfo) {\r\n    if (!isActionKeyEvent(getEvent(eventInfo))) {\r\n        return;\r\n    }\r\n    setA11yClickKey(eventInfo, true);\r\n    // A 'click' triggered by a DOM keypress should be mapped to the 'click'\r\n    // jsaction.\r\n    setEventType(eventInfo, EventType.CLICK);\r\n}\r\n/**\r\n * Call `preventDefault` on an a11y click if it is space key or to prevent the\r\n * browser's default action for native HTML controls.\r\n */\r\nfunction preventDefaultForA11yClick(eventInfo) {\r\n    if (!getA11yClickKey(eventInfo) ||\r\n        (!isSpaceKeyEvent(getEvent(eventInfo)) &&\r\n            !shouldCallPreventDefaultOnNativeHtmlControl(getEvent(eventInfo)))) {\r\n        return;\r\n    }\r\n    preventDefault(getEvent(eventInfo));\r\n}\r\n/**\r\n * Sets the `action` to `clickonly` for a click event that is not an a11y click\r\n * and if there is not already a click action.\r\n */\r\nfunction populateClickOnlyAction(actionElement, eventInfo, actionMap) {\r\n    if (\r\n    // If there's already an action, don't attempt to set a CLICKONLY\r\n    getAction(eventInfo) ||\r\n        // Only attempt CLICKONLY if the type is CLICK\r\n        getEventType(eventInfo) !== EventType.CLICK ||\r\n        // a11y clicks are never CLICKONLY\r\n        getA11yClickKey(eventInfo) ||\r\n        actionMap[EventType.CLICKONLY] === undefined) {\r\n        return;\r\n    }\r\n    setEventType(eventInfo, EventType.CLICKONLY);\r\n    setAction(eventInfo, actionMap[EventType.CLICKONLY], actionElement);\r\n}\r\n\r\n/**\r\n * @define Support for accessible click actions.  This flag can be overridden in\r\n * a build rule.\r\n */\r\nconst A11Y_CLICK_SUPPORT = false;\r\n/**\r\n * @define Support for the non-bubbling mouseenter and mouseleave events.  This\r\n * flag can be overridden in a build rule.\r\n */\r\nconst MOUSE_SPECIAL_SUPPORT = false;\r\n\r\n/**\r\n * @fileoverview Implements the local event handling contract. This\r\n * allows DOM objects in a container that enters into this contract to\r\n * define event handlers which are executed in a local context.\r\n *\r\n * One EventContract instance can manage the contract for multiple\r\n * containers, which are added using the addContainer() method.\r\n *\r\n * Events can be registered using the addEvent() method.\r\n *\r\n * A Dispatcher is added using the registerDispatcher() method. Until there is\r\n * a dispatcher, events are queued. The idea is that the EventContract\r\n * class is inlined in the HTML of the top level page and instantiated\r\n * right after the start of <body>. The Dispatcher class is contained\r\n * in the external deferred js, and instantiated and registered with\r\n * EventContract when the external javascript in the page loads. The\r\n * external javascript will also register the jsaction handlers, which\r\n * then pick up the queued events at the time of registration.\r\n *\r\n * Since this class is meant to be inlined in the main page HTML, the\r\n * size of the binary compiled from this file MUST be kept as small as\r\n * possible and thus its dependencies to a minimum.\r\n */\r\n/**\r\n * EventContract intercepts events in the bubbling phase at the\r\n * boundary of a container element, and maps them to generic actions\r\n * which are specified using the custom jsaction attribute in\r\n * HTML. Behavior of the application is then specified in terms of\r\n * handler for such actions, cf. jsaction.Dispatcher in dispatcher.js.\r\n *\r\n * This has several benefits: (1) No DOM event handlers need to be\r\n * registered on the specific elements in the UI. (2) The set of\r\n * events that the application has to handle can be specified in terms\r\n * of the semantics of the application, rather than in terms of DOM\r\n * events. (3) Invocation of handlers can be delayed and handlers can\r\n * be delay loaded in a generic way.\r\n */\r\nclass EventContract {\r\n    static { this.A11Y_CLICK_SUPPORT = A11Y_CLICK_SUPPORT; }\r\n    static { this.MOUSE_SPECIAL_SUPPORT = MOUSE_SPECIAL_SUPPORT; }\r\n    constructor(containerManager, useActionResolver = true) {\r\n        this.useActionResolver = useActionResolver;\r\n        /**\r\n         * The DOM events which this contract covers. Used to prevent double\r\n         * registration of event types. The value of the map is the\r\n         * internally created DOM event handler function that handles the\r\n         * DOM events. See addEvent().\r\n         *\r\n         */\r\n        this.eventHandlers = {};\r\n        this.browserEventTypeToExtraEventTypes = {};\r\n        /**\r\n         * The dispatcher function. Events are passed to this function for\r\n         * handling once it was set using the registerDispatcher() method. This is\r\n         * done because the function is passed from another jsbinary, so passing the\r\n         * instance and invoking the method here would require to leave the method\r\n         * unobfuscated.\r\n         */\r\n        this.dispatcher = null;\r\n        /**\r\n         * The list of suspended `EventInfo` that will be dispatched\r\n         * as soon as the `Dispatcher` is registered.\r\n         */\r\n        this.queuedEventInfos = [];\r\n        /** Whether to add an a11y click listener. */\r\n        this.addA11yClickListener = false;\r\n        this.containerManager = containerManager;\r\n        if (this.useActionResolver) {\r\n            this.actionResolver = new ActionResolver({\r\n                syntheticMouseEventSupport: EventContract.MOUSE_SPECIAL_SUPPORT,\r\n            });\r\n        }\r\n        if (EventContract.A11Y_CLICK_SUPPORT) {\r\n            // Add a11y click support to the `EventContract`.\r\n            this.addA11yClickSupport();\r\n        }\r\n    }\r\n    handleEvent(eventType, event, container) {\r\n        const eventInfo = createEventInfoFromParameters(\r\n        /* eventType= */ eventType, \r\n        /* event= */ event, \r\n        /* targetElement= */ event.target, \r\n        /* container= */ container, \r\n        /* timestamp= */ Date.now());\r\n        this.handleEventInfo(eventInfo);\r\n    }\r\n    /**\r\n     * Handle an `EventInfo`.\r\n     */\r\n    handleEventInfo(eventInfo) {\r\n        if (!this.dispatcher) {\r\n            // All events are queued when the dispatcher isn't yet loaded.\r\n            setIsReplay(eventInfo, true);\r\n            this.queuedEventInfos?.push(eventInfo);\r\n            return;\r\n        }\r\n        if (this.useActionResolver) {\r\n            this.actionResolver.resolveEventType(eventInfo);\r\n            this.actionResolver.resolveAction(eventInfo);\r\n        }\r\n        this.dispatcher(eventInfo);\r\n    }\r\n    /**\r\n     * Enables jsaction handlers to be called for the event type given by\r\n     * name.\r\n     *\r\n     * If the event is already registered, this does nothing.\r\n     *\r\n     * @param prefixedEventType If supplied, this event is used in\r\n     *     the actual browser event registration instead of the name that is\r\n     *     exposed to jsaction. Use this if you e.g. want users to be able\r\n     *     to subscribe to jsaction=\"transitionEnd:foo\" while the underlying\r\n     *     event is webkitTransitionEnd in one browser and mozTransitionEnd\r\n     *     in another.\r\n     */\r\n    addEvent(eventType, prefixedEventType) {\r\n        if (eventType in this.eventHandlers || !this.containerManager) {\r\n            return;\r\n        }\r\n        if (!EventContract.MOUSE_SPECIAL_SUPPORT && NON_BUBBLING_MOUSE_EVENTS.indexOf(eventType) >= 0) {\r\n            return;\r\n        }\r\n        const eventHandler = (eventType, event, container) => {\r\n            this.handleEvent(eventType, event, container);\r\n        };\r\n        // Store the callback to allow us to replay events.\r\n        this.eventHandlers[eventType] = eventHandler;\r\n        const browserEventType = getBrowserEventType(prefixedEventType || eventType);\r\n        if (browserEventType !== eventType) {\r\n            const eventTypes = this.browserEventTypeToExtraEventTypes[browserEventType] || [];\r\n            eventTypes.push(eventType);\r\n            this.browserEventTypeToExtraEventTypes[browserEventType] = eventTypes;\r\n        }\r\n        this.containerManager.addEventListener(browserEventType, (element) => {\r\n            return (event) => {\r\n                eventHandler(eventType, event, element);\r\n            };\r\n        });\r\n        // Automatically install a keypress/keydown event handler if support for\r\n        // accessible clicks is turned on.\r\n        if (this.addA11yClickListener && eventType === EventType.CLICK) {\r\n            this.addEvent(EventType.KEYDOWN);\r\n        }\r\n    }\r\n    /**\r\n     * Gets the queued early events and replay them using the appropriate handler\r\n     * in the provided event contract. Once all the events are replayed, it cleans\r\n     * up the early contract.\r\n     */\r\n    replayEarlyEvents(earlyJsactionContainer = window) {\r\n        // Check if the early contract is present and prevent calling this function\r\n        // more than once.\r\n        const earlyJsactionData = earlyJsactionContainer._ejsa;\r\n        if (!earlyJsactionData) {\r\n            return;\r\n        }\r\n        // Replay the early contract events.\r\n        const earlyEventInfos = earlyJsactionData.q;\r\n        for (let idx = 0; idx < earlyEventInfos.length; idx++) {\r\n            const earlyEventInfo = earlyEventInfos[idx];\r\n            const eventTypes = this.getEventTypesForBrowserEventType(earlyEventInfo.eventType);\r\n            for (let i = 0; i < eventTypes.length; i++) {\r\n                const eventInfo = cloneEventInfo(earlyEventInfo);\r\n                // EventInfo eventType maps to JSAction's internal event type,\r\n                // rather than the browser event type.\r\n                setEventType(eventInfo, eventTypes[i]);\r\n                this.handleEventInfo(eventInfo);\r\n            }\r\n        }\r\n        // Clean up the early contract.\r\n        const earlyEventHandler = earlyJsactionData.h;\r\n        removeEventListeners(earlyJsactionData.c, earlyJsactionData.et, earlyEventHandler);\r\n        removeEventListeners(earlyJsactionData.c, earlyJsactionData.etc, earlyEventHandler, true);\r\n        delete earlyJsactionContainer._ejsa;\r\n    }\r\n    /**\r\n     * Returns all JSAction event types that have been registered for a given\r\n     * browser event type.\r\n     */\r\n    getEventTypesForBrowserEventType(browserEventType) {\r\n        const eventTypes = [];\r\n        if (this.eventHandlers[browserEventType]) {\r\n            eventTypes.push(browserEventType);\r\n        }\r\n        if (this.browserEventTypeToExtraEventTypes[browserEventType]) {\r\n            eventTypes.push(...this.browserEventTypeToExtraEventTypes[browserEventType]);\r\n        }\r\n        return eventTypes;\r\n    }\r\n    /**\r\n     * Returns the event handler function for a given event type.\r\n     */\r\n    handler(eventType) {\r\n        return this.eventHandlers[eventType];\r\n    }\r\n    /**\r\n     * Cleans up the event contract. This resets all of the `EventContract`'s\r\n     * internal state. Users are responsible for not using this `EventContract`\r\n     * after it has been cleaned up.\r\n     */\r\n    cleanUp() {\r\n        this.containerManager.cleanUp();\r\n        this.containerManager = null;\r\n        this.eventHandlers = {};\r\n        this.browserEventTypeToExtraEventTypes = {};\r\n        this.dispatcher = null;\r\n        this.queuedEventInfos = [];\r\n    }\r\n    /**\r\n     * Register a dispatcher function. Event info of each event mapped to\r\n     * a jsaction is passed for handling to this callback. The queued\r\n     * events are passed as well to the dispatcher for later replaying\r\n     * once the dispatcher is registered. Clears the event queue to null.\r\n     *\r\n     * @param dispatcher The dispatcher function.\r\n     * @param restriction\r\n     */\r\n    registerDispatcher(dispatcher, restriction) {\r\n        this.ecrd(dispatcher, restriction);\r\n    }\r\n    /**\r\n     * Unrenamed alias for registerDispatcher. Necessary for any codebases that\r\n     * split the `EventContract` and `Dispatcher` code into different compilation\r\n     * units.\r\n     */\r\n    ecrd(dispatcher, restriction) {\r\n        this.dispatcher = dispatcher;\r\n        if (this.queuedEventInfos?.length) {\r\n            for (let i = 0; i < this.queuedEventInfos.length; i++) {\r\n                this.handleEventInfo(this.queuedEventInfos[i]);\r\n            }\r\n            this.queuedEventInfos = null;\r\n        }\r\n    }\r\n    /**\r\n     * Adds a11y click support to the given `EventContract`. Meant to be called in\r\n     * the same compilation unit as the `EventContract`.\r\n     */\r\n    addA11yClickSupport() {\r\n        this.addA11yClickSupportImpl(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction);\r\n    }\r\n    /**\r\n     * Enables a11y click support to be deferred. Meant to be called in the same\r\n     * compilation unit as the `EventContract`.\r\n     */\r\n    exportAddA11yClickSupport() {\r\n        this.addA11yClickListener = true;\r\n        this.ecaacs = this.addA11yClickSupportImpl.bind(this);\r\n    }\r\n    /**\r\n     * Unrenamed function that loads a11yClickSupport.\r\n     */\r\n    addA11yClickSupportImpl(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction) {\r\n        this.addA11yClickListener = true;\r\n        if (this.useActionResolver) {\r\n            this.actionResolver.addA11yClickSupport(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction);\r\n        }\r\n    }\r\n}\r\nfunction removeEventListeners(container, eventTypes, earlyEventHandler, capture) {\r\n    for (let idx = 0; idx < eventTypes.length; idx++) {\r\n        container.removeEventListener(eventTypes[idx], earlyEventHandler, /* useCapture */ capture);\r\n    }\r\n}\r\n/**\r\n * Adds a11y click support to the given `EventContract`. Meant to be called\r\n * in a different compilation unit from the `EventContract`. The `EventContract`\r\n * must have called `exportAddA11yClickSupport` in its compilation unit for this\r\n * to have any effect.\r\n */\r\nfunction addDeferredA11yClickSupport(eventContract) {\r\n    eventContract.ecaacs?.(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction);\r\n}\r\n\r\n/**\r\n * EarlyEventContract intercepts events in the bubbling phase at the\r\n * boundary of the document body. This mapping will be passed to the\r\n * late-loaded EventContract.\r\n */\r\nclass EarlyEventContract {\r\n    constructor(replaySink = window, container = window.document.documentElement) {\r\n        this.replaySink = replaySink;\r\n        this.container = container;\r\n        replaySink._ejsa = {\r\n            c: container,\r\n            q: [],\r\n            et: [],\r\n            etc: [],\r\n            h: (event) => {\r\n                const eventInfo = createEventInfoFromParameters(event.type, event, event.target, container, Date.now());\r\n                replaySink._ejsa.q.push(eventInfo);\r\n            },\r\n        };\r\n    }\r\n    /**\r\n     * Installs a list of event types for container .\r\n     */\r\n    addEvents(types, capture) {\r\n        const replaySink = this.replaySink._ejsa;\r\n        for (let idx = 0; idx < types.length; idx++) {\r\n            const eventType = types[idx];\r\n            const eventTypes = capture ? replaySink.etc : replaySink.et;\r\n            eventTypes.push(eventType);\r\n            this.container.addEventListener(eventType, replaySink.h, capture);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Provides a factory function for bootstrapping an event contract on a\r\n * specified object (by default, exposed on the `window`).\r\n * @param field The property on the object that the event contract will be placed on.\r\n * @param container The container that listens to events\r\n * @param appId A given identifier for an application. If there are multiple apps on the page\r\n *              then this is how contracts can be initialized for each one.\r\n * @param eventTypes An array of event names that should be listened to.\r\n * @param captureEventTypes An array of event names that should be listened to with capture.\r\n * @param earlyJsactionTracker The object that should receive the event contract.\r\n */\r\nfunction bootstrapEarlyEventContract(field, container, appId, eventTypes, captureEventTypes, earlyJsactionTracker = window) {\r\n    if (!earlyJsactionTracker[field]) {\r\n        earlyJsactionTracker[field] = {};\r\n    }\r\n    earlyJsactionTracker[field][appId] = {};\r\n    const eventContract = new EarlyEventContract(earlyJsactionTracker[field][appId], container);\r\n    if (eventTypes)\r\n        eventContract.addEvents(eventTypes);\r\n    if (captureEventTypes)\r\n        eventContract.addEvents(captureEventTypes, true);\r\n}\r\n\r\nexport { EventContract, EventContractContainer, EventDispatcher, EventInfoWrapper, EventPhase, bootstrapEarlyEventContract, isCaptureEvent, isSupportedEvent, registerDispatcher };\r\n\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,UAAU,GAAG,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,IAAI,GAAG,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,GAAG,GAAG,KAAK;AACjB;AACA;AACA;AACA;AACA,MAAMC,GAAG,GAAG,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAG,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,OAAO,GAAG,SAAS;AACzB,MAAMC,SAAS,GAAG;EAAEC,QAAQ,EAAEP,UAAU;EAAEQ,EAAE,EAAEP,IAAI;EAAEC,GAAG;EAAEC,GAAG;EAAEC,UAAU;EAAEC;AAAQ,CAAC;AAEnF,MAAMI,IAAI,GAAG;EACT;AACJ;AACA;AACA;EACIC,0BAA0B,EAAE,GAAG;EAC/B;AACJ;AACA;AACA;EACIC,sBAAsB,EAAE,GAAG;EAC3B;AACJ;AACA;AACA;EACIC,YAAY,EAAE,GAAG;EACjB;AACJ;AACA;AACA;EACIC,uBAAuB,EAAE,GAAG;EAC5B;AACJ;AACA;AACA;EACIC,aAAa,EAAE;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,SAAS,GAAG;EACd;AACJ;AACA;AACA;EACIC,QAAQ,EAAE,UAAU;EACpB;AACJ;AACA;AACA;EACIC,MAAM,EAAE,QAAQ;EAChB;AACJ;AACA;AACA;AACA;AACA;EACIC,KAAK,EAAE,OAAO;EACd;AACJ;AACA;AACA;AACA;AACA;EACIC,QAAQ,EAAE,UAAU;EACpB;AACJ;AACA;AACA;AACA;EACIC,SAAS,EAAE,WAAW;EACtB;AACJ;AACA;EACIC,QAAQ,EAAE,UAAU;EACpB;AACJ;AACA;AACA;AACA;EACIC,KAAK,EAAE,OAAO;EACd;AACJ;AACA;AACA;AACA;EACIC,OAAO,EAAE,SAAS;EAClB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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}