{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Hamzah Alkhateeb/Desktop/Halal Eatz/HalalEats/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\r\n * @license Angular v18.0.1\r\n * (c) 2010-2024 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\n\nimport { ɵDeferBlockState, ɵtriggerResourceLoading, ɵrenderDeferBlockState, ɵCONTAINER_HEADER_OFFSET, ɵgetDeferBlocks, ɵDeferBlockBehavior, InjectionToken, inject as inject$1, ɵNoopNgZone, NgZone, ɵEffectScheduler, ApplicationRef, ɵPendingTasks, getDebugNode, RendererFactory2, ɵdetectChangesInViewIfRequired, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetAsyncClassMetadataFn, ɵgenerateStandaloneInDeclarationsError, ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT, ɵdepsTracker, ɵgetInjectableDef, resolveForwardRef, ɵNG_COMP_DEF, ɵisComponentDefPendingResolution, ɵresolveComponentResources, ɵRender3NgModuleRef, ApplicationInitStatus, LOCALE_ID, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIR_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵNG_MOD_DEF, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJ_DEF, ɵcompileNgModuleDefs, ɵclearResolutionOfComponentResourcesQueue, ɵrestoreComponentResolutionQueue, ɵinternalProvideZoneChangeDetection, ɵChangeDetectionScheduler, ɵChangeDetectionSchedulerImpl, Compiler, ɵDEFER_BLOCK_CONFIG, COMPILER_OPTIONS, Injector, ɵisEnvironmentProviders, ɵNgModuleFactory, ModuleWithComponentFactories, ɵconvertToBitFlags, InjectFlags, ɵsetAllowDuplicateNgModuleIdsForTest, ɵresetCompiledComponents, ɵsetUnknownElementStrictMode, ɵsetUnknownPropertyStrictMode, ɵgetUnknownElementStrictMode, ɵgetUnknownPropertyStrictMode, runInInjectionContext, EnvironmentInjector, ɵZONELESS_ENABLED, ɵflushModuleScopingQueueAsMuchAsPossible } from '@angular/core';\nexport { ɵDeferBlockBehavior as DeferBlockBehavior, ɵDeferBlockState as DeferBlockState } from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { first } from 'rxjs/operators';\nimport { ResourceLoader } from '@angular/compiler';\n\n/**\r\n * Wraps a test function in an asynchronous test zone. The test will automatically\r\n * complete when all asynchronous calls within this zone are done. Can be used\r\n * to wrap an {@link inject} call.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * it('...', waitForAsync(inject([AClass], (object) => {\r\n *   object.doSomething.then(() => {\r\n *     expect(...);\r\n *   })\r\n * })));\r\n * ```\r\n *\r\n * @publicApi\r\n */\nfunction waitForAsync(fn) {\n  const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n  if (!_Zone) {\n    return function () {\n      return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js');\n    };\n  }\n  const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  }\n  return function () {\n    return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/testing');\n  };\n}\n\n/**\r\n * Represents an individual defer block for testing purposes.\r\n *\r\n * @publicApi\r\n */\nclass DeferBlockFixture {\n  /** @nodoc */\n  constructor(block, componentFixture) {\n    this.block = block;\n    this.componentFixture = componentFixture;\n  }\n  /**\r\n   * Renders the specified state of the defer fixture.\r\n   * @param state the defer state to render\r\n   */\n  render(state) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!hasStateTemplate(state, _this.block)) {\n        const stateAsString = getDeferBlockStateNameFromEnum(state);\n        throw new Error(`Tried to render this defer block in the \\`${stateAsString}\\` state, ` + `but there was no @${stateAsString.toLowerCase()} block defined in a template.`);\n      }\n      if (state === ɵDeferBlockState.Complete) {\n        yield ɵtriggerResourceLoading(_this.block.tDetails, _this.block.lView, _this.block.tNode);\n      }\n      // If the `render` method is used explicitly - skip timer-based scheduling for\n      // `@placeholder` and `@loading` blocks and render them immediately.\n      const skipTimerScheduling = true;\n      ɵrenderDeferBlockState(state, _this.block.tNode, _this.block.lContainer, skipTimerScheduling);\n      _this.componentFixture.detectChanges();\n    })();\n  }\n  /**\r\n   * Retrieves all nested child defer block fixtures\r\n   * in a given defer block.\r\n   */\n  getDeferBlocks() {\n    const deferBlocks = [];\n    // An LContainer that represents a defer block has at most 1 view, which is\n    // located right after an LContainer header. Get a hold of that view and inspect\n    // it for nested defer blocks.\n    const deferBlockFixtures = [];\n    if (this.block.lContainer.length >= ɵCONTAINER_HEADER_OFFSET) {\n      const lView = this.block.lContainer[ɵCONTAINER_HEADER_OFFSET];\n      ɵgetDeferBlocks(lView, deferBlocks);\n      for (const block of deferBlocks) {\n        deferBlockFixtures.push(new DeferBlockFixture(block, this.componentFixture));\n      }\n    }\n    return Promise.resolve(deferBlockFixtures);\n  }\n}\nfunction hasStateTemplate(state, block) {\n  switch (state) {\n    case ɵDeferBlockState.Placeholder:\n      return block.tDetails.placeholderTmplIndex !== null;\n    case ɵDeferBlockState.Loading:\n      return block.tDetails.loadingTmplIndex !== null;\n    case ɵDeferBlockState.Error:\n      return block.tDetails.errorTmplIndex !== null;\n    case ɵDeferBlockState.Complete:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getDeferBlockStateNameFromEnum(state) {\n  switch (state) {\n    case ɵDeferBlockState.Placeholder:\n      return 'Placeholder';\n    case ɵDeferBlockState.Loading:\n      return 'Loading';\n    case ɵDeferBlockState.Error:\n      return 'Error';\n    default:\n      return 'Main';\n  }\n}\n\n/** Whether test modules should be torn down by default. */\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/** Whether unknown elements in templates should throw by default. */\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\n/** Whether unknown properties in templates should throw by default. */\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\n/** Whether defer blocks should use manual triggering or play through normally. */\nconst DEFER_BLOCK_DEFAULT_BEHAVIOR = ɵDeferBlockBehavior.Playthrough;\n/**\r\n * An abstract class for inserting the root test component element in a platform independent way.\r\n *\r\n * @publicApi\r\n */\nclass TestComponentRenderer {\n  insertRootElement(rootElementId) {}\n  removeAllRootElements() {}\n}\n/**\r\n * @publicApi\r\n */\nconst ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\n/**\r\n * @publicApi\r\n */\nconst ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\n\n/**\r\n * Fixture for debugging and testing a component.\r\n *\r\n * @publicApi\r\n */\nclass ComponentFixture {\n  /** @nodoc */\n  constructor(componentRef) {\n    this.componentRef = componentRef;\n    this._isDestroyed = false;\n    /** @internal */\n    this._noZoneOptionIsSet = inject$1(ComponentFixtureNoNgZone, {\n      optional: true\n    });\n    /** @internal */\n    this._ngZone = this._noZoneOptionIsSet ? new ɵNoopNgZone() : inject$1(NgZone);\n    /** @internal */\n    this._effectRunner = inject$1(ɵEffectScheduler);\n    // Inject ApplicationRef to ensure NgZone stableness causes after render hooks to run\n    // This will likely happen as a result of fixture.detectChanges because it calls ngZone.run\n    // This is a crazy way of doing things but hey, it's the world we live in.\n    // The zoneless scheduler should instead do this more imperatively by attaching\n    // the `ComponentRef` to `ApplicationRef` and calling `appRef.tick` as the `detectChanges`\n    // behavior.\n    /** @internal */\n    this._appRef = inject$1(ApplicationRef);\n    /** @internal */\n    this._testAppRef = this._appRef;\n    this.pendingTasks = inject$1(ɵPendingTasks);\n    // TODO(atscott): Remove this from public API\n    this.ngZone = this._noZoneOptionIsSet ? null : this._ngZone;\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n  }\n  /**\r\n   * Do a change detection run to make sure there were no changes.\r\n   */\n  checkNoChanges() {\n    this.changeDetectorRef.checkNoChanges();\n  }\n  /**\r\n   * Return whether the fixture is currently stable or has async tasks that have not been completed\r\n   * yet.\r\n   */\n  isStable() {\n    return !this.pendingTasks.hasPendingTasks.value;\n  }\n  /**\r\n   * Get a promise that resolves when the fixture is stable.\r\n   *\r\n   * This can be used to resume testing after events have triggered asynchronous activity or\r\n   * asynchronous change detection.\r\n   */\n  whenStable() {\n    if (this.isStable()) {\n      return Promise.resolve(false);\n    }\n    return this._appRef.isStable.pipe(first(stable => stable)).toPromise();\n  }\n  /**\r\n   * Retrieves all defer block fixtures in the component fixture.\r\n   */\n  getDeferBlocks() {\n    const deferBlocks = [];\n    const lView = this.componentRef.hostView['_lView'];\n    ɵgetDeferBlocks(lView, deferBlocks);\n    const deferBlockFixtures = [];\n    for (const block of deferBlocks) {\n      deferBlockFixtures.push(new DeferBlockFixture(block, this));\n    }\n    return Promise.resolve(deferBlockFixtures);\n  }\n  _getRenderer() {\n    if (this._renderer === undefined) {\n      this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n    }\n    return this._renderer;\n  }\n  /**\r\n   * Get a promise that resolves when the ui state is stable following animations.\r\n   */\n  whenRenderingDone() {\n    const renderer = this._getRenderer();\n    if (renderer && renderer.whenRenderingDone) {\n      return renderer.whenRenderingDone();\n    }\n    return this.whenStable();\n  }\n  /**\r\n   * Trigger component destruction.\r\n   */\n  destroy() {\n    if (!this._isDestroyed) {\n      this.componentRef.destroy();\n      this._isDestroyed = true;\n    }\n  }\n}\n/**\r\n * ComponentFixture behavior that actually attaches the component to the application to ensure\r\n * behaviors between fixture and application do not diverge. `detectChanges` is disabled by default\r\n * (instead, tests should wait for the scheduler to detect changes), `whenStable` is directly the\r\n * `ApplicationRef.isStable`, and `autoDetectChanges` cannot be disabled.\r\n */\nclass ScheduledComponentFixture extends ComponentFixture {\n  constructor() {\n    super(...arguments);\n    this._autoDetect = inject$1(ComponentFixtureAutoDetect, {\n      optional: true\n    }) ?? true;\n  }\n  initialize() {\n    if (this._autoDetect) {\n      this._appRef.attachView(this.componentRef.hostView);\n    }\n  }\n  detectChanges(checkNoChanges = true) {\n    if (!checkNoChanges) {\n      throw new Error('Cannot disable `checkNoChanges` in this configuration. ' + 'Use `fixture.componentRef.hostView.changeDetectorRef.detectChanges()` instead.');\n    }\n    this._effectRunner.flush();\n    this._appRef.tick();\n    this._effectRunner.flush();\n  }\n  autoDetectChanges(autoDetect = true) {\n    if (!autoDetect) {\n      throw new Error('Cannot disable autoDetect after it has been enabled when using the zoneless scheduler. ' + 'To disable autoDetect, add `{provide: ComponentFixtureAutoDetect, useValue: false}` to the TestBed providers.');\n    } else if (!this._autoDetect) {\n      this._autoDetect = autoDetect;\n      this._appRef.attachView(this.componentRef.hostView);\n    }\n    this.detectChanges();\n  }\n}\n/**\r\n * ComponentFixture behavior that attempts to act as a \"mini application\".\r\n */\nclass PseudoApplicationComponentFixture extends ComponentFixture {\n  constructor() {\n    super(...arguments);\n    this._subscriptions = new Subscription();\n    this._autoDetect = inject$1(ComponentFixtureAutoDetect, {\n      optional: true\n    }) ?? false;\n    this.afterTickSubscription = undefined;\n    this.beforeRenderSubscription = undefined;\n  }\n  initialize() {\n    if (this._autoDetect) {\n      this.subscribeToAppRefEvents();\n    }\n    this.componentRef.hostView.onDestroy(() => {\n      this.unsubscribeFromAppRefEvents();\n    });\n    // Create subscriptions outside the NgZone so that the callbacks run outside\n    // of NgZone.\n    this._ngZone.runOutsideAngular(() => {\n      this._subscriptions.add(this._ngZone.onError.subscribe({\n        next: error => {\n          throw error;\n        }\n      }));\n    });\n  }\n  detectChanges(checkNoChanges = true) {\n    this._effectRunner.flush();\n    // Run the change detection inside the NgZone so that any async tasks as part of the change\n    // detection are captured by the zone and can be waited for in isStable.\n    this._ngZone.run(() => {\n      this.changeDetectorRef.detectChanges();\n      if (checkNoChanges) {\n        this.checkNoChanges();\n      }\n    });\n    // Run any effects that were created/dirtied during change detection. Such effects might become\n    // dirty in response to input signals changing.\n    this._effectRunner.flush();\n  }\n  autoDetectChanges(autoDetect = true) {\n    if (this._noZoneOptionIsSet) {\n      throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.');\n    }\n    if (autoDetect !== this._autoDetect) {\n      if (autoDetect) {\n        this.subscribeToAppRefEvents();\n      } else {\n        this.unsubscribeFromAppRefEvents();\n      }\n    }\n    this._autoDetect = autoDetect;\n    this.detectChanges();\n  }\n  subscribeToAppRefEvents() {\n    this._ngZone.runOutsideAngular(() => {\n      this.afterTickSubscription = this._testAppRef.afterTick.subscribe(() => {\n        this.checkNoChanges();\n      });\n      this.beforeRenderSubscription = this._testAppRef.beforeRender.subscribe(isFirstPass => {\n        try {\n          ɵdetectChangesInViewIfRequired(this.componentRef.hostView._lView, this.componentRef.hostView.notifyErrorHandler, isFirstPass, false /** zoneless enabled */);\n        } catch (e) {\n          // If an error occurred during change detection, remove the test view from the application\n          // ref tracking. Note that this isn't exactly desirable but done this way because of how\n          // things used to work with `autoDetect` and uncaught errors. Ideally we would surface\n          // this error to the error handler instead and continue refreshing the view like\n          // what would happen in the application.\n          this.unsubscribeFromAppRefEvents();\n          throw e;\n        }\n      });\n      this._testAppRef.externalTestViews.add(this.componentRef.hostView);\n    });\n  }\n  unsubscribeFromAppRefEvents() {\n    this.afterTickSubscription?.unsubscribe();\n    this.beforeRenderSubscription?.unsubscribe();\n    this.afterTickSubscription = undefined;\n    this.beforeRenderSubscription = undefined;\n    this._testAppRef.externalTestViews.delete(this.componentRef.hostView);\n  }\n  destroy() {\n    this.unsubscribeFromAppRefEvents();\n    this._subscriptions.unsubscribe();\n    super.destroy();\n  }\n}\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`;\n/**\r\n * Clears out the shared fake async zone for a test.\r\n * To be called in a global `beforeEach`.\r\n *\r\n * @publicApi\r\n */\nfunction resetFakeAsyncZone() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.resetFakeAsyncZone();\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\nfunction resetFakeAsyncZoneIfExists() {\n  if (fakeAsyncTestModule) {\n    fakeAsyncTestModule.resetFakeAsyncZone();\n  }\n}\n/**\r\n * Wraps a function to be executed in the `fakeAsync` zone:\r\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\r\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\r\n *\r\n * If there are any pending timers at the end of the function, an exception is thrown.\r\n *\r\n * Can be used to wrap `inject()` calls.\r\n *\r\n * @param fn The function that you want to wrap in the `fakeAsync` zone.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/testing/ts/fake_async.ts region='basic'}\r\n *\r\n *\r\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\r\n * Any arguments passed when calling this returned function will be passed through to the `fn`\r\n * function in the parameters when it is called.\r\n *\r\n * @publicApi\r\n */\nfunction fakeAsync(fn) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.fakeAsync(fn);\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\r\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\r\n *\r\n * The microtasks queue is drained at the very start of this function and after any timer callback\r\n * has been executed.\r\n *\r\n * @param millis The number of milliseconds to advance the virtual timer.\r\n * @param tickOptions The options to pass to the `tick()` function.\r\n *\r\n * @usageNotes\r\n *\r\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\r\n * which determines whether or not to invoke new macroTasks.\r\n *\r\n * If you provide a `tickOptions` object, but do not specify a\r\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\r\n * then `processNewMacroTasksSynchronously` defaults to true.\r\n *\r\n * If you omit the `tickOptions` parameter (`tick(100))`), then\r\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\r\n *\r\n * ### Example\r\n *\r\n * {@example core/testing/ts/fake_async.ts region='basic'}\r\n *\r\n * The following example includes a nested timeout (new macroTask), and\r\n * the `tickOptions` parameter is allowed to default. In this case,\r\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\r\n * function is executed on each tick.\r\n *\r\n * ```\r\n * it ('test with nested setTimeout', fakeAsync(() => {\r\n *   let nestedTimeoutInvoked = false;\r\n *   function funcWithNestedTimeout() {\r\n *     setTimeout(() => {\r\n *       nestedTimeoutInvoked = true;\r\n *     });\r\n *   };\r\n *   setTimeout(funcWithNestedTimeout);\r\n *   tick();\r\n *   expect(nestedTimeoutInvoked).toBe(true);\r\n * }));\r\n * ```\r\n *\r\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\r\n * set to false, so the nested timeout function is not invoked.\r\n *\r\n * ```\r\n * it ('test with nested setTimeout', fakeAsync(() => {\r\n *   let nestedTimeoutInvoked = false;\r\n *   function funcWithNestedTimeout() {\r\n *     setTimeout(() => {\r\n *       nestedTimeoutInvoked = true;\r\n *     });\r\n *   };\r\n *   setTimeout(funcWithNestedTimeout);\r\n *   tick(0, {processNewMacroTasksSynchronously: false});\r\n *   expect(nestedTimeoutInvoked).toBe(false);\r\n * }));\r\n * ```\r\n *\r\n *\r\n * @publicApi\r\n */\nfunction tick(millis = 0, tickOptions = {\n  processNewMacroTasksSynchronously: true\n}) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.tick(millis, tickOptions);\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\r\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\r\n * the `fakeAsync` zone by\r\n * draining the macrotask queue until it is empty.\r\n *\r\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\r\n *     throwing an error.\r\n * @returns The simulated time elapsed, in milliseconds.\r\n *\r\n * @publicApi\r\n */\nfunction flush(maxTurns) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flush(maxTurns);\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\r\n * Discard all remaining periodic tasks.\r\n *\r\n * @publicApi\r\n */\nfunction discardPeriodicTasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.discardPeriodicTasks();\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\r\n * Flush any pending microtasks.\r\n *\r\n * @publicApi\r\n */\nfunction flushMicrotasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flushMicrotasks();\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n  constructor() {\n    this._references = new Map();\n  }\n  /**\r\n   * Creates a new instance for the given metadata class\r\n   * based on an old instance and overrides.\r\n   */\n  overrideMetadata(metadataClass, oldMetadata, override) {\n    const props = {};\n    if (oldMetadata) {\n      _valueProps(oldMetadata).forEach(prop => props[prop] = oldMetadata[prop]);\n    }\n    if (override.set) {\n      if (override.remove || override.add) {\n        throw new Error(`Cannot set and add/remove ${ɵstringify(metadataClass)} at the same time!`);\n      }\n      setMetadata(props, override.set);\n    }\n    if (override.remove) {\n      removeMetadata(props, override.remove, this._references);\n    }\n    if (override.add) {\n      addMetadata(props, override.add);\n    }\n    return new metadataClass(props);\n  }\n}\nfunction removeMetadata(metadata, remove, references) {\n  const removeObjects = new Set();\n  for (const prop in remove) {\n    const removeValue = remove[prop];\n    if (Array.isArray(removeValue)) {\n      removeValue.forEach(value => {\n        removeObjects.add(_propHashKey(prop, value, references));\n      });\n    } else {\n      removeObjects.add(_propHashKey(prop, removeValue, references));\n    }\n  }\n  for (const prop in metadata) {\n    const propValue = metadata[prop];\n    if (Array.isArray(propValue)) {\n      metadata[prop] = propValue.filter(value => !removeObjects.has(_propHashKey(prop, value, references)));\n    } else {\n      if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n        metadata[prop] = undefined;\n      }\n    }\n  }\n}\nfunction addMetadata(metadata, add) {\n  for (const prop in add) {\n    const addValue = add[prop];\n    const propValue = metadata[prop];\n    if (propValue != null && Array.isArray(propValue)) {\n      metadata[prop] = propValue.concat(addValue);\n    } else {\n      metadata[prop] = addValue;\n    }\n  }\n}\nfunction setMetadata(metadata, set) {\n  for (const prop in set) {\n    metadata[prop] = set[prop];\n  }\n}\nfunction _propHashKey(propName, propValue, references) {\n  let nextObjectId = 0;\n  const objectIds = new Map();\n  const replacer = (key, value) => {\n    if (value !== null && typeof value === 'object') {\n      if (objectIds.has(value)) {\n        return objectIds.get(value);\n      }\n      // Record an id for this object such that any later references use the object's id instead\n      // of the object itself, in order to break cyclic pointers in objects.\n      objectIds.set(value, `ɵobj#${nextObjectId++}`);\n      // The first time an object is seen the object itself is serialized.\n      return value;\n    } else if (typeof value === 'function') {\n      value = _serializeReference(value, references);\n    }\n    return value;\n  };\n  return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n  let id = references.get(ref);\n  if (!id) {\n    id = `${ɵstringify(ref)}${_nextReferenceId++}`;\n    references.set(ref, id);\n  }\n  return id;\n}\nfunction _valueProps(obj) {\n  const props = [];\n  // regular public props\n  Object.keys(obj).forEach(prop => {\n    if (!prop.startsWith('_')) {\n      props.push(prop);\n    }\n  });\n  // getters\n  let proto = obj;\n  while (proto = Object.getPrototypeOf(proto)) {\n    Object.keys(proto).forEach(protoProp => {\n      const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n      if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n        props.push(protoProp);\n      }\n    });\n  }\n  return props;\n}\nconst reflection = new ɵReflectionCapabilities();\n/**\r\n * Allows to override ivy metadata for tests (via the `TestBed`).\r\n */\nclass OverrideResolver {\n  constructor() {\n    this.overrides = new Map();\n    this.resolved = new Map();\n  }\n  addOverride(type, override) {\n    const overrides = this.overrides.get(type) || [];\n    overrides.push(override);\n    this.overrides.set(type, overrides);\n    this.resolved.delete(type);\n  }\n  setOverrides(overrides) {\n    this.overrides.clear();\n    overrides.forEach(([type, override]) => {\n      this.addOverride(type, override);\n    });\n  }\n  getAnnotation(type) {\n    const annotations = reflection.annotations(type);\n    // Try to find the nearest known Type annotation and make sure that this annotation is an\n    // instance of the type we are looking for, so we can use it for resolution. Note: there might\n    // be multiple known annotations found due to the fact that Components can extend Directives (so\n    // both Directive and Component annotations would be present), so we always check if the known\n    // annotation has the right type.\n    for (let i = annotations.length - 1; i >= 0; i--) {\n      const annotation = annotations[i];\n      const isKnownType = annotation instanceof Directive || annotation instanceof Component || annotation instanceof Pipe || annotation instanceof NgModule;\n      if (isKnownType) {\n        return annotation instanceof this.type ? annotation : null;\n      }\n    }\n    return null;\n  }\n  resolve(type) {\n    let resolved = this.resolved.get(type) || null;\n    if (!resolved) {\n      resolved = this.getAnnotation(type);\n      if (resolved) {\n        const overrides = this.overrides.get(type);\n        if (overrides) {\n          const overrider = new MetadataOverrider();\n          overrides.forEach(override => {\n            resolved = overrider.overrideMetadata(this.type, resolved, override);\n          });\n        }\n      }\n      this.resolved.set(type, resolved);\n    }\n    return resolved;\n  }\n}\nclass DirectiveResolver extends OverrideResolver {\n  get type() {\n    return Directive;\n  }\n}\nclass ComponentResolver extends OverrideResolver {\n  get type() {\n    return Component;\n  }\n}\nclass PipeResolver extends OverrideResolver {\n  get type() {\n    return Pipe;\n  }\n}\nclass NgModuleResolver extends OverrideResolver {\n  get type() {\n    return NgModule;\n  }\n}\nvar TestingModuleOverride;\n(function (TestingModuleOverride) {\n  TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n  TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\nfunction isTestingModuleOverride(value) {\n  return value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\nfunction assertNoStandaloneComponents(types, resolver, location) {\n  types.forEach(type => {\n    if (!ɵgetAsyncClassMetadataFn(type)) {\n      const component = resolver.resolve(type);\n      if (component && component.standalone) {\n        throw new Error(ɵgenerateStandaloneInDeclarationsError(type, location));\n      }\n    }\n  });\n}\nclass TestBedCompiler {\n  constructor(platform, additionalModuleTypes) {\n    this.platform = platform;\n    this.additionalModuleTypes = additionalModuleTypes;\n    this.originalComponentResolutionQueue = null;\n    // Testing module configuration\n    this.declarations = [];\n    this.imports = [];\n    this.providers = [];\n    this.schemas = [];\n    // Queues of components/directives/pipes that should be recompiled.\n    this.pendingComponents = new Set();\n    this.pendingDirectives = new Set();\n    this.pendingPipes = new Set();\n    // Set of components with async metadata, i.e. components with `@defer` blocks\n    // in their templates.\n    this.componentsWithAsyncMetadata = new Set();\n    // Keep track of all components and directives, so we can patch Providers onto defs later.\n    this.seenComponents = new Set();\n    this.seenDirectives = new Set();\n    // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n    this.overriddenModules = new Set();\n    // Store resolved styles for Components that have template overrides present and `styleUrls`\n    // defined at the same time.\n    this.existingComponentStyles = new Map();\n    this.resolvers = initResolvers();\n    // Map of component type to an NgModule that declares it.\n    //\n    // There are a couple special cases:\n    // - for standalone components, the module scope value is `null`\n    // - when a component is declared in `TestBed.configureTestingModule()` call or\n    //   a component's template is overridden via `TestBed.overrideTemplateUsingTestingModule()`.\n    //   we use a special value from the `TestingModuleOverride` enum.\n    this.componentToModuleScope = new Map();\n    // Map that keeps initial version of component/directive/pipe defs in case\n    // we compile a Type again, thus overriding respective static fields. This is\n    // required to make sure we restore defs to their initial states between test runs.\n    // Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of an\n    // NgModule), store all of them in a map.\n    this.initialNgDefs = new Map();\n    // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n    // defs in case TestBed makes changes to the originals.\n    this.defCleanupOps = [];\n    this._injector = null;\n    this.compilerProviders = null;\n    this.providerOverrides = [];\n    this.rootProviderOverrides = [];\n    // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n    // module's provider list.\n    this.providerOverridesByModule = new Map();\n    this.providerOverridesByToken = new Map();\n    this.scopesWithOverriddenProviders = new Set();\n    this.testModuleRef = null;\n    this.deferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    class DynamicTestModule {}\n    this.testModuleType = DynamicTestModule;\n  }\n  setCompilerProviders(providers) {\n    this.compilerProviders = providers;\n    this._injector = null;\n  }\n  configureTestingModule(moduleDef) {\n    // Enqueue any compilation tasks for the directly declared component.\n    if (moduleDef.declarations !== undefined) {\n      // Verify that there are no standalone components\n      assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n      this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n      this.declarations.push(...moduleDef.declarations);\n    }\n    // Enqueue any compilation tasks for imported modules.\n    if (moduleDef.imports !== undefined) {\n      this.queueTypesFromModulesArray(moduleDef.imports);\n      this.imports.push(...moduleDef.imports);\n    }\n    if (moduleDef.providers !== undefined) {\n      this.providers.push(...moduleDef.providers);\n    }\n    if (moduleDef.schemas !== undefined) {\n      this.schemas.push(...moduleDef.schemas);\n    }\n    this.deferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n  }\n  overrideModule(ngModule, override) {\n    if (ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n      ɵdepsTracker.clearScopeCacheFor(ngModule);\n    }\n    this.overriddenModules.add(ngModule);\n    // Compile the module right away.\n    this.resolvers.module.addOverride(ngModule, override);\n    const metadata = this.resolvers.module.resolve(ngModule);\n    if (metadata === null) {\n      throw invalidTypeError(ngModule.name, 'NgModule');\n    }\n    this.recompileNgModule(ngModule, metadata);\n    // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n    // new declarations or imported modules. Ingest any possible new types and add them to the\n    // current queue.\n    this.queueTypesFromModulesArray([ngModule]);\n  }\n  overrideComponent(component, override) {\n    this.verifyNoStandaloneFlagOverrides(component, override);\n    this.resolvers.component.addOverride(component, override);\n    this.pendingComponents.add(component);\n    // If this is a component with async metadata (i.e. a component with a `@defer` block\n    // in a template) - store it for future processing.\n    this.maybeRegisterComponentWithAsyncMetadata(component);\n  }\n  overrideDirective(directive, override) {\n    this.verifyNoStandaloneFlagOverrides(directive, override);\n    this.resolvers.directive.addOverride(directive, override);\n    this.pendingDirectives.add(directive);\n  }\n  overridePipe(pipe, override) {\n    this.verifyNoStandaloneFlagOverrides(pipe, override);\n    this.resolvers.pipe.addOverride(pipe, override);\n    this.pendingPipes.add(pipe);\n  }\n  verifyNoStandaloneFlagOverrides(type, override) {\n    if (override.add?.hasOwnProperty('standalone') || override.set?.hasOwnProperty('standalone') || override.remove?.hasOwnProperty('standalone')) {\n      throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` + `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\n    }\n  }\n  overrideProvider(token, provider) {\n    let providerDef;\n    if (provider.useFactory !== undefined) {\n      providerDef = {\n        provide: token,\n        useFactory: provider.useFactory,\n        deps: provider.deps || [],\n        multi: provider.multi\n      };\n    } else if (provider.useValue !== undefined) {\n      providerDef = {\n        provide: token,\n        useValue: provider.useValue,\n        multi: provider.multi\n      };\n    } else {\n      providerDef = {\n        provide: token\n      };\n    }\n    const injectableDef = typeof token !== 'string' ? ɵgetInjectableDef(token) : null;\n    const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n    const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n    overridesBucket.push(providerDef);\n    // Keep overrides grouped by token as well for fast lookups using token\n    this.providerOverridesByToken.set(token, providerDef);\n    if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n      const existingOverrides = this.providerOverridesByModule.get(providedIn);\n      if (existingOverrides !== undefined) {\n        existingOverrides.push(providerDef);\n      } else {\n        this.providerOverridesByModule.set(providedIn, [providerDef]);\n      }\n    }\n  }\n  overrideTemplateUsingTestingModule(type, template) {\n    const def = type[ɵNG_COMP_DEF];\n    const hasStyleUrls = () => {\n      const metadata = this.resolvers.component.resolve(type);\n      return !!metadata.styleUrl || !!metadata.styleUrls?.length;\n    };\n    const overrideStyleUrls = !!def && !ɵisComponentDefPendingResolution(type) && hasStyleUrls();\n    // In Ivy, compiling a component does not require knowing the module providing the\n    // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n    // overrideComponent. Important: overriding template requires full Component re-compilation,\n    // which may fail in case styleUrls are also present (thus Component is considered as required\n    // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n    // preserve current styles available on Component def and restore styles back once compilation\n    // is complete.\n    const override = overrideStyleUrls ? {\n      template,\n      styles: [],\n      styleUrls: [],\n      styleUrl: undefined\n    } : {\n      template\n    };\n    this.overrideComponent(type, {\n      set: override\n    });\n    if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n      this.existingComponentStyles.set(type, def.styles);\n    }\n    // Set the component's scope to be the testing module.\n    this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n  }\n  resolvePendingComponentsWithAsyncMetadata() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.componentsWithAsyncMetadata.size === 0) return;\n      const promises = [];\n      for (const component of _this2.componentsWithAsyncMetadata) {\n        const asyncMetadataFn = ɵgetAsyncClassMetadataFn(component);\n        if (asyncMetadataFn) {\n          promises.push(asyncMetadataFn());\n        }\n      }\n      _this2.componentsWithAsyncMetadata.clear();\n      const resolvedDeps = yield Promise.all(promises);\n      const flatResolvedDeps = resolvedDeps.flat(2);\n      _this2.queueTypesFromModulesArray(flatResolvedDeps);\n      // Loaded standalone components might contain imports of NgModules\n      // with providers, make sure we override providers there too.\n      for (const component of flatResolvedDeps) {\n        _this2.applyProviderOverridesInScope(component);\n      }\n    })();\n  }\n  compileComponents() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.clearComponentResolutionQueue();\n      // Wait for all async metadata for components that were\n      // overridden, we need resolved metadata to perform an override\n      // and re-compile a component.\n      yield _this3.resolvePendingComponentsWithAsyncMetadata();\n      // Verify that there were no standalone components present in the `declarations` field\n      // during the `TestBed.configureTestingModule` call. We perform this check here in addition\n      // to the logic in the `configureTestingModule` function, since at this point we have\n      // all async metadata resolved.\n      assertNoStandaloneComponents(_this3.declarations, _this3.resolvers.component, '\"TestBed.configureTestingModule\" call');\n      // Run compilers for all queued types.\n      let needsAsyncResources = _this3.compileTypesSync();\n      // compileComponents() should not be async unless it needs to be.\n      if (needsAsyncResources) {\n        let resourceLoader;\n        let resolver = url => {\n          if (!resourceLoader) {\n            resourceLoader = _this3.injector.get(ResourceLoader);\n          }\n          return Promise.resolve(resourceLoader.get(url));\n        };\n        yield ɵresolveComponentResources(resolver);\n      }\n    })();\n  }\n  finalize() {\n    // One last compile\n    this.compileTypesSync();\n    // Create the testing module itself.\n    this.compileTestModule();\n    this.applyTransitiveScopes();\n    this.applyProviderOverrides();\n    // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n    // Components have `styleUrls` fields defined and template override was requested.\n    this.patchComponentsWithExistingStyles();\n    // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n    // every component.\n    this.componentToModuleScope.clear();\n    const parentInjector = this.platform.injector;\n    this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector, []);\n    // ApplicationInitStatus.runInitializers() is marked @internal to core.\n    // Cast it to any before accessing it.\n    this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n    // Set locale ID after running app initializers, since locale information might be updated while\n    // running initializers. This is also consistent with the execution order while bootstrapping an\n    // app (see `packages/core/src/application_ref.ts` file).\n    const localeId = this.testModuleRef.injector.get(LOCALE_ID, ɵDEFAULT_LOCALE_ID);\n    ɵsetLocaleId(localeId);\n    return this.testModuleRef;\n  }\n  /**\r\n   * @internal\r\n   */\n  _compileNgModuleSync(moduleType) {\n    this.queueTypesFromModulesArray([moduleType]);\n    this.compileTypesSync();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesInScope(moduleType);\n    this.applyTransitiveScopes();\n  }\n  /**\r\n   * @internal\r\n   */\n  _compileNgModuleAsync(moduleType) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4.queueTypesFromModulesArray([moduleType]);\n      yield _this4.compileComponents();\n      _this4.applyProviderOverrides();\n      _this4.applyProviderOverridesInScope(moduleType);\n      _this4.applyTransitiveScopes();\n    })();\n  }\n  /**\r\n   * @internal\r\n   */\n  _getModuleResolver() {\n    return this.resolvers.module;\n  }\n  /**\r\n   * @internal\r\n   */\n  _getComponentFactories(moduleType) {\n    return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n      const componentDef = declaration.ɵcmp;\n      componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, this.testModuleRef));\n      return factories;\n    }, []);\n  }\n  compileTypesSync() {\n    // Compile all queued components, directives, pipes.\n    let needsAsyncResources = false;\n    this.pendingComponents.forEach(declaration => {\n      if (ɵgetAsyncClassMetadataFn(declaration)) {\n        throw new Error(`Component '${declaration.name}' has unresolved metadata. ` + `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n      }\n      needsAsyncResources = needsAsyncResources || ɵisComponentDefPendingResolution(declaration);\n      const metadata = this.resolvers.component.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Component');\n      }\n      this.maybeStoreNgDef(ɵNG_COMP_DEF, declaration);\n      if (ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n        ɵdepsTracker.clearScopeCacheFor(declaration);\n      }\n      ɵcompileComponent(declaration, metadata);\n    });\n    this.pendingComponents.clear();\n    this.pendingDirectives.forEach(declaration => {\n      const metadata = this.resolvers.directive.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Directive');\n      }\n      this.maybeStoreNgDef(ɵNG_DIR_DEF, declaration);\n      ɵcompileDirective(declaration, metadata);\n    });\n    this.pendingDirectives.clear();\n    this.pendingPipes.forEach(declaration => {\n      const metadata = this.resolvers.pipe.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Pipe');\n      }\n      this.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\n      ɵcompilePipe(declaration, metadata);\n    });\n    this.pendingPipes.clear();\n    return needsAsyncResources;\n  }\n  applyTransitiveScopes() {\n    if (this.overriddenModules.size > 0) {\n      // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n      // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n      // collect all affected modules and reset scopes to force their re-calculation.\n      const testingModuleDef = this.testModuleType[ɵNG_MOD_DEF];\n      const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n      if (affectedModules.size > 0) {\n        affectedModules.forEach(moduleType => {\n          if (!ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n            this.storeFieldOfDefOnType(moduleType, ɵNG_MOD_DEF, 'transitiveCompileScopes');\n            moduleType[ɵNG_MOD_DEF].transitiveCompileScopes = null;\n          } else {\n            ɵdepsTracker.clearScopeCacheFor(moduleType);\n          }\n        });\n      }\n    }\n    const moduleToScope = new Map();\n    const getScopeOfModule = moduleType => {\n      if (!moduleToScope.has(moduleType)) {\n        const isTestingModule = isTestingModuleOverride(moduleType);\n        const realType = isTestingModule ? this.testModuleType : moduleType;\n        moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\n      }\n      return moduleToScope.get(moduleType);\n    };\n    this.componentToModuleScope.forEach((moduleType, componentType) => {\n      if (moduleType !== null) {\n        const moduleScope = getScopeOfModule(moduleType);\n        this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'directiveDefs');\n        this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'pipeDefs');\n        ɵpatchComponentDefWithScope(getComponentDef(componentType), moduleScope);\n      }\n      // `tView` that is stored on component def contains information about directives and pipes\n      // that are in the scope of this component. Patching component scope will cause `tView` to be\n      // changed. Store original `tView` before patching scope, so the `tView` (including scope\n      // information) is restored back to its previous/original state before running next test.\n      // Resetting `tView` is also needed for cases when we apply provider overrides and those\n      // providers are defined on component's level, in which case they may end up included into\n      // `tView.blueprint`.\n      this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'tView');\n    });\n    this.componentToModuleScope.clear();\n  }\n  applyProviderOverrides() {\n    const maybeApplyOverrides = field => type => {\n      const resolver = field === ɵNG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n      const metadata = resolver.resolve(type);\n      if (this.hasProviderOverrides(metadata.providers)) {\n        this.patchDefWithProviderOverrides(type, field);\n      }\n    };\n    this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMP_DEF));\n    this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIR_DEF));\n    this.seenComponents.clear();\n    this.seenDirectives.clear();\n  }\n  /**\r\n   * Applies provider overrides to a given type (either an NgModule or a standalone component)\r\n   * and all imported NgModules and standalone components recursively.\r\n   */\n  applyProviderOverridesInScope(type) {\n    const hasScope = isStandaloneComponent(type) || isNgModule(type);\n    // The function can be re-entered recursively while inspecting dependencies\n    // of an NgModule or a standalone component. Exit early if we come across a\n    // type that can not have a scope (directive or pipe) or the type is already\n    // processed earlier.\n    if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n      return;\n    }\n    this.scopesWithOverriddenProviders.add(type);\n    // NOTE: the line below triggers JIT compilation of the module injector,\n    // which also invokes verification of the NgModule semantics, which produces\n    // detailed error messages. The fact that the code relies on this line being\n    // present here is suspicious and should be refactored in a way that the line\n    // below can be moved (for ex. after an early exit check below).\n    const injectorDef = type[ɵNG_INJ_DEF];\n    // No provider overrides, exit early.\n    if (this.providerOverridesByToken.size === 0) return;\n    if (isStandaloneComponent(type)) {\n      // Visit all component dependencies and override providers there.\n      const def = getComponentDef(type);\n      const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n      for (const dependency of dependencies) {\n        this.applyProviderOverridesInScope(dependency);\n      }\n    } else {\n      const providers = [...injectorDef.providers, ...(this.providerOverridesByModule.get(type) || [])];\n      if (this.hasProviderOverrides(providers)) {\n        this.maybeStoreNgDef(ɵNG_INJ_DEF, type);\n        this.storeFieldOfDefOnType(type, ɵNG_INJ_DEF, 'providers');\n        injectorDef.providers = this.getOverriddenProviders(providers);\n      }\n      // Apply provider overrides to imported modules recursively\n      const moduleDef = type[ɵNG_MOD_DEF];\n      const imports = maybeUnwrapFn(moduleDef.imports);\n      for (const importedModule of imports) {\n        this.applyProviderOverridesInScope(importedModule);\n      }\n      // Also override the providers on any ModuleWithProviders imports since those don't appear in\n      // the moduleDef.\n      for (const importedModule of flatten(injectorDef.imports)) {\n        if (isModuleWithProviders(importedModule)) {\n          this.defCleanupOps.push({\n            object: importedModule,\n            fieldName: 'providers',\n            originalValue: importedModule.providers\n          });\n          importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n        }\n      }\n    }\n  }\n  patchComponentsWithExistingStyles() {\n    this.existingComponentStyles.forEach((styles, type) => type[ɵNG_COMP_DEF].styles = styles);\n    this.existingComponentStyles.clear();\n  }\n  queueTypeArray(arr, moduleType) {\n    for (const value of arr) {\n      if (Array.isArray(value)) {\n        this.queueTypeArray(value, moduleType);\n      } else {\n        this.queueType(value, moduleType);\n      }\n    }\n  }\n  recompileNgModule(ngModule, metadata) {\n    // Cache the initial ngModuleDef as it will be overwritten.\n    this.maybeStoreNgDef(ɵNG_MOD_DEF, ngModule);\n    this.maybeStoreNgDef(ɵNG_INJ_DEF, ngModule);\n    ɵcompileNgModuleDefs(ngModule, metadata);\n  }\n  maybeRegisterComponentWithAsyncMetadata(type) {\n    const asyncMetadataFn = ɵgetAsyncClassMetadataFn(type);\n    if (asyncMetadataFn) {\n      this.componentsWithAsyncMetadata.add(type);\n    }\n  }\n  queueType(type, moduleType) {\n    // If this is a component with async metadata (i.e. a component with a `@defer` block\n    // in a template) - store it for future processing.\n    this.maybeRegisterComponentWithAsyncMetadata(type);\n    const component = this.resolvers.component.resolve(type);\n    if (component) {\n      // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n      // missing. That might happen in case a class without any Angular decorators extends another\n      // class where Component/Directive/Pipe decorator is defined.\n      if (ɵisComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMP_DEF)) {\n        this.pendingComponents.add(type);\n      }\n      this.seenComponents.add(type);\n      // Keep track of the module which declares this component, so later the component's scope\n      // can be set correctly. If the component has already been recorded here, then one of several\n      // cases is true:\n      // * the module containing the component was imported multiple times (common).\n      // * the component is declared in multiple modules (which is an error).\n      // * the component was in 'declarations' of the testing module, and also in an imported module\n      //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n      // * overrideTemplateUsingTestingModule was called for the component in which case the module\n      //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n      //\n      // If the component was previously in the testing module's 'declarations' (meaning the\n      // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n      // real module, which was imported. This pattern is understood to mean that the component\n      // should use its original scope, but that the testing module should also contain the\n      // component in its scope.\n      if (!this.componentToModuleScope.has(type) || this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n        this.componentToModuleScope.set(type, moduleType);\n      }\n      return;\n    }\n    const directive = this.resolvers.directive.resolve(type);\n    if (directive) {\n      if (!type.hasOwnProperty(ɵNG_DIR_DEF)) {\n        this.pendingDirectives.add(type);\n      }\n      this.seenDirectives.add(type);\n      return;\n    }\n    const pipe = this.resolvers.pipe.resolve(type);\n    if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\n      this.pendingPipes.add(type);\n      return;\n    }\n  }\n  queueTypesFromModulesArray(arr) {\n    // Because we may encounter the same NgModule or a standalone Component while processing\n    // the dependencies of an NgModule or a standalone Component, we cache them in this set so we\n    // can skip ones that have already been seen encountered. In some test setups, this caching\n    // resulted in 10X runtime improvement.\n    const processedDefs = new Set();\n    const queueTypesFromModulesArrayRecur = arr => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          queueTypesFromModulesArrayRecur(value);\n        } else if (hasNgModuleDef(value)) {\n          const def = value.ɵmod;\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          // Look through declarations, imports, and exports, and queue\n          // everything found there.\n          this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n        } else if (isModuleWithProviders(value)) {\n          queueTypesFromModulesArrayRecur([value.ngModule]);\n        } else if (isStandaloneComponent(value)) {\n          this.queueType(value, null);\n          const def = getComponentDef(value);\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n          dependencies.forEach(dependency => {\n            // Note: in AOT, the `dependencies` might also contain regular\n            // (NgModule-based) Component, Directive and Pipes, so we handle\n            // them separately and proceed with recursive process for standalone\n            // Components and NgModules only.\n            if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n              queueTypesFromModulesArrayRecur([dependency]);\n            } else {\n              this.queueType(dependency, null);\n            }\n          });\n        }\n      }\n    };\n    queueTypesFromModulesArrayRecur(arr);\n  }\n  // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n  // that import (even transitively) an overridden one. For all affected modules we need to\n  // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n  // of this function is to collect all affected modules in a set for further processing. Example:\n  // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n  // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n  // invalidated with the override.\n  collectModulesAffectedByOverrides(arr) {\n    const seenModules = new Set();\n    const affectedModules = new Set();\n    const calcAffectedModulesRecur = (arr, path) => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          // If the value is an array, just flatten it (by invoking this function recursively),\n          // keeping \"path\" the same.\n          calcAffectedModulesRecur(value, path);\n        } else if (hasNgModuleDef(value)) {\n          if (seenModules.has(value)) {\n            // If we've seen this module before and it's included into \"affected modules\" list, mark\n            // the whole path that leads to that module as affected, but do not descend into its\n            // imports, since we already examined them before.\n            if (affectedModules.has(value)) {\n              path.forEach(item => affectedModules.add(item));\n            }\n            continue;\n          }\n          seenModules.add(value);\n          if (this.overriddenModules.has(value)) {\n            path.forEach(item => affectedModules.add(item));\n          }\n          // Examine module imports recursively to look for overridden modules.\n          const moduleDef = value[ɵNG_MOD_DEF];\n          calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n        }\n      }\n    };\n    calcAffectedModulesRecur(arr, []);\n    return affectedModules;\n  }\n  /**\r\n   * Preserve an original def (such as ɵmod, ɵinj, etc) before applying an override.\r\n   * Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of\r\n   * an NgModule). If there is a def in a set already, don't override it, since\r\n   * an original one should be restored at the end of a test.\r\n   */\n  maybeStoreNgDef(prop, type) {\n    if (!this.initialNgDefs.has(type)) {\n      this.initialNgDefs.set(type, new Map());\n    }\n    const currentDefs = this.initialNgDefs.get(type);\n    if (!currentDefs.has(prop)) {\n      const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n      currentDefs.set(prop, currentDef);\n    }\n  }\n  storeFieldOfDefOnType(type, defField, fieldName) {\n    const def = type[defField];\n    const originalValue = def[fieldName];\n    this.defCleanupOps.push({\n      object: def,\n      fieldName,\n      originalValue\n    });\n  }\n  /**\r\n   * Clears current components resolution queue, but stores the state of the queue, so we can\r\n   * restore it later. Clearing the queue is required before we try to compile components (via\r\n   * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\r\n   */\n  clearComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue === null) {\n      this.originalComponentResolutionQueue = new Map();\n    }\n    ɵclearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n  }\n  /*\r\n   * Restores component resolution queue to the previously saved state. This operation is performed\r\n   * as a part of restoring the state after completion of the current set of tests (that might\r\n   * potentially mutate the state).\r\n   */\n  restoreComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue !== null) {\n      ɵrestoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n      this.originalComponentResolutionQueue = null;\n    }\n  }\n  restoreOriginalState() {\n    // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n    // case there were multiple overrides for the same field).\n    forEachRight(this.defCleanupOps, op => {\n      op.object[op.fieldName] = op.originalValue;\n    });\n    // Restore initial component/directive/pipe defs\n    this.initialNgDefs.forEach((defs, type) => {\n      if (ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n        ɵdepsTracker.clearScopeCacheFor(type);\n      }\n      defs.forEach((descriptor, prop) => {\n        if (!descriptor) {\n          // Delete operations are generally undesirable since they have performance\n          // implications on objects they were applied to. In this particular case, situations\n          // where this code is invoked should be quite rare to cause any noticeable impact,\n          // since it's applied only to some test cases (for example when class with no\n          // annotations extends some @Component) when we need to clear 'ɵcmp' field on a given\n          // class to restore its original state (before applying overrides and running tests).\n          delete type[prop];\n        } else {\n          Object.defineProperty(type, prop, descriptor);\n        }\n      });\n    });\n    this.initialNgDefs.clear();\n    this.scopesWithOverriddenProviders.clear();\n    this.restoreComponentResolutionQueue();\n    // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n    ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\n  }\n  compileTestModule() {\n    class RootScopeModule {}\n    ɵcompileNgModuleDefs(RootScopeModule, {\n      providers: [...this.rootProviderOverrides, ɵinternalProvideZoneChangeDetection({}), {\n        provide: ɵChangeDetectionScheduler,\n        useExisting: ɵChangeDetectionSchedulerImpl\n      }]\n    });\n    const providers = [{\n      provide: Compiler,\n      useFactory: () => new R3TestCompiler(this)\n    }, {\n      provide: ɵDEFER_BLOCK_CONFIG,\n      useValue: {\n        behavior: this.deferBlockBehavior\n      }\n    }, ...this.providers, ...this.providerOverrides];\n    const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n    ɵcompileNgModuleDefs(this.testModuleType, {\n      declarations: this.declarations,\n      imports,\n      schemas: this.schemas,\n      providers\n    }, /* allowDuplicateDeclarationsInRoot */true);\n    this.applyProviderOverridesInScope(this.testModuleType);\n  }\n  get injector() {\n    if (this._injector !== null) {\n      return this._injector;\n    }\n    const providers = [];\n    const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n    compilerOptions.forEach(opts => {\n      if (opts.providers) {\n        providers.push(opts.providers);\n      }\n    });\n    if (this.compilerProviders !== null) {\n      providers.push(...this.compilerProviders);\n    }\n    this._injector = Injector.create({\n      providers,\n      parent: this.platform.injector\n    });\n    return this._injector;\n  }\n  // get overrides for a specific provider (if any)\n  getSingleProviderOverrides(provider) {\n    const token = getProviderToken(provider);\n    return this.providerOverridesByToken.get(token) || null;\n  }\n  getProviderOverrides(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    // There are two flattening operations here. The inner flattenProviders() operates on the\n    // metadata's providers and applies a mapping function which retrieves overrides for each\n    // incoming provider. The outer flatten() then flattens the produced overrides array. If this is\n    // not done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n    // providers array and contaminate any error messages that might be generated.\n    return flatten(flattenProviders(providers, provider => this.getSingleProviderOverrides(provider) || []));\n  }\n  getOverriddenProviders(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    const flattenedProviders = flattenProviders(providers);\n    const overrides = this.getProviderOverrides(flattenedProviders);\n    const overriddenProviders = [...flattenedProviders, ...overrides];\n    const final = [];\n    const seenOverriddenProviders = new Set();\n    // We iterate through the list of providers in reverse order to make sure provider overrides\n    // take precedence over the values defined in provider list. We also filter out all providers\n    // that have overrides, keeping overridden values only. This is needed, since presence of a\n    // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n    forEachRight(overriddenProviders, provider => {\n      const token = getProviderToken(provider);\n      if (this.providerOverridesByToken.has(token)) {\n        if (!seenOverriddenProviders.has(token)) {\n          seenOverriddenProviders.add(token);\n          // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n          // make sure that provided override takes highest precedence and is not combined with\n          // other instances of the same multi provider.\n          final.unshift({\n            ...provider,\n            multi: false\n          });\n        }\n      } else {\n        final.unshift(provider);\n      }\n    });\n    return final;\n  }\n  hasProviderOverrides(providers) {\n    return this.getProviderOverrides(providers).length > 0;\n  }\n  patchDefWithProviderOverrides(declaration, field) {\n    const def = declaration[field];\n    if (def && def.providersResolver) {\n      this.maybeStoreNgDef(field, declaration);\n      const resolver = def.providersResolver;\n      const processProvidersFn = providers => this.getOverriddenProviders(providers);\n      this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n      def.providersResolver = ngDef => resolver(ngDef, processProvidersFn);\n    }\n  }\n}\nfunction initResolvers() {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver()\n  };\n}\nfunction isStandaloneComponent(value) {\n  const def = getComponentDef(value);\n  return !!def?.standalone;\n}\nfunction getComponentDef(value) {\n  return value.ɵcmp ?? null;\n}\nfunction hasNgModuleDef(value) {\n  return value.hasOwnProperty('ɵmod');\n}\nfunction isNgModule(value) {\n  return hasNgModuleDef(value);\n}\nfunction maybeUnwrapFn(maybeFn) {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values) {\n  const out = [];\n  values.forEach(value => {\n    if (Array.isArray(value)) {\n      out.push(...flatten(value));\n    } else {\n      out.push(value);\n    }\n  });\n  return out;\n}\nfunction identityFn(value) {\n  return value;\n}\nfunction flattenProviders(providers, mapFn = identityFn) {\n  const out = [];\n  for (let provider of providers) {\n    if (ɵisEnvironmentProviders(provider)) {\n      provider = provider.ɵproviders;\n    }\n    if (Array.isArray(provider)) {\n      out.push(...flattenProviders(provider, mapFn));\n    } else {\n      out.push(mapFn(provider));\n    }\n  }\n  return out;\n}\nfunction getProviderField(provider, field) {\n  return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n  return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n  for (let idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\nfunction invalidTypeError(name, expectedType) {\n  return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n  constructor(testBed) {\n    this.testBed = testBed;\n  }\n  compileModuleSync(moduleType) {\n    this.testBed._compileNgModuleSync(moduleType);\n    return new ɵNgModuleFactory(moduleType);\n  }\n  compileModuleAsync(moduleType) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      yield _this5.testBed._compileNgModuleAsync(moduleType);\n      return new ɵNgModuleFactory(moduleType);\n    })();\n  }\n  compileModuleAndAllComponentsSync(moduleType) {\n    const ngModuleFactory = this.compileModuleSync(moduleType);\n    const componentFactories = this.testBed._getComponentFactories(moduleType);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n  compileModuleAndAllComponentsAsync(moduleType) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const ngModuleFactory = yield _this6.compileModuleAsync(moduleType);\n      const componentFactories = _this6.testBed._getComponentFactories(moduleType);\n      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    })();\n  }\n  clearCache() {}\n  clearCacheFor(type) {}\n  getModuleId(moduleType) {\n    const meta = this.testBed._getModuleResolver().resolve(moduleType);\n    return meta && meta.id || undefined;\n  }\n}\n\n// The formatter and CI disagree on how this import statement should be formatted. Both try to keep\nlet _nextRootElementId = 0;\n/**\r\n * Returns a singleton of the `TestBed` class.\r\n *\r\n * @publicApi\r\n */\nfunction getTestBed() {\n  return TestBedImpl.INSTANCE;\n}\n/**\r\n * @description\r\n * Configures and initializes environment for unit testing and provides methods for\r\n * creating components and services in unit tests.\r\n *\r\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\r\n */\nclass TestBedImpl {\n  constructor() {\n    /**\r\n     * Defer block behavior option that specifies whether defer blocks will be triggered manually\r\n     * or set to play through.\r\n     */\n    this._instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    // Properties\n    this.platform = null;\n    this.ngModule = null;\n    this._compiler = null;\n    this._testModuleRef = null;\n    this._activeFixtures = [];\n    /**\r\n     * Internal-only flag to indicate whether a module\r\n     * scoping queue has been checked and flushed already.\r\n     * @nodoc\r\n     */\n    this.globalCompilationChecked = false;\n  }\n  static #_ = this._INSTANCE = null;\n  static get INSTANCE() {\n    return TestBedImpl._INSTANCE = TestBedImpl._INSTANCE || new TestBedImpl();\n  }\n  /**\r\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n   * angular module. These are common to every test in the suite.\r\n   *\r\n   * This may only be called once, to set up the common providers for the current test\r\n   * suite on the current platform. If you absolutely need to change the providers,\r\n   * first use `resetTestEnvironment`.\r\n   *\r\n   * Test modules and platforms for individual platforms are available from\r\n   * '@angular/<platform_name>/testing'.\r\n   *\r\n   * @publicApi\r\n   */\n  static initTestEnvironment(ngModule, platform, options) {\n    const testBed = TestBedImpl.INSTANCE;\n    testBed.initTestEnvironment(ngModule, platform, options);\n    return testBed;\n  }\n  /**\r\n   * Reset the providers for the test injector.\r\n   *\r\n   * @publicApi\r\n   */\n  static resetTestEnvironment() {\n    TestBedImpl.INSTANCE.resetTestEnvironment();\n  }\n  static configureCompiler(config) {\n    return TestBedImpl.INSTANCE.configureCompiler(config);\n  }\n  /**\r\n   * Allows overriding default providers, directives, pipes, modules of the test injector,\r\n   * which are defined in test_injector.js\r\n   */\n  static configureTestingModule(moduleDef) {\n    return TestBedImpl.INSTANCE.configureTestingModule(moduleDef);\n  }\n  /**\r\n   * Compile components with a `templateUrl` for the test's NgModule.\r\n   * It is necessary to call this function\r\n   * as fetching urls is asynchronous.\r\n   */\n  static compileComponents() {\n    return TestBedImpl.INSTANCE.compileComponents();\n  }\n  static overrideModule(ngModule, override) {\n    return TestBedImpl.INSTANCE.overrideModule(ngModule, override);\n  }\n  static overrideComponent(component, override) {\n    return TestBedImpl.INSTANCE.overrideComponent(component, override);\n  }\n  static overrideDirective(directive, override) {\n    return TestBedImpl.INSTANCE.overrideDirective(directive, override);\n  }\n  static overridePipe(pipe, override) {\n    return TestBedImpl.INSTANCE.overridePipe(pipe, override);\n  }\n  static overrideTemplate(component, template) {\n    return TestBedImpl.INSTANCE.overrideTemplate(component, template);\n  }\n  /**\r\n   * Overrides the template of the given component, compiling the template\r\n   * in the context of the TestingModule.\r\n   *\r\n   * Note: This works for JIT and AOTed components as well.\r\n   */\n  static overrideTemplateUsingTestingModule(component, template) {\n    return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component, template);\n  }\n  static overrideProvider(token, provider) {\n    return TestBedImpl.INSTANCE.overrideProvider(token, provider);\n  }\n  static inject(token, notFoundValue, flags) {\n    return TestBedImpl.INSTANCE.inject(token, notFoundValue, ɵconvertToBitFlags(flags));\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    return TestBedImpl.INSTANCE.inject(token, notFoundValue, flags);\n  }\n  /**\r\n   * Runs the given function in the `EnvironmentInjector` context of `TestBed`.\r\n   *\r\n   * @see {@link EnvironmentInjector#runInContext}\r\n   */\n  static runInInjectionContext(fn) {\n    return TestBedImpl.INSTANCE.runInInjectionContext(fn);\n  }\n  static createComponent(component) {\n    return TestBedImpl.INSTANCE.createComponent(component);\n  }\n  static resetTestingModule() {\n    return TestBedImpl.INSTANCE.resetTestingModule();\n  }\n  static execute(tokens, fn, context) {\n    return TestBedImpl.INSTANCE.execute(tokens, fn, context);\n  }\n  static get platform() {\n    return TestBedImpl.INSTANCE.platform;\n  }\n  static get ngModule() {\n    return TestBedImpl.INSTANCE.ngModule;\n  }\n  static flushEffects() {\n    return TestBedImpl.INSTANCE.flushEffects();\n  }\n  /**\r\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n   * angular module. These are common to every test in the suite.\r\n   *\r\n   * This may only be called once, to set up the common providers for the current test\r\n   * suite on the current platform. If you absolutely need to change the providers,\r\n   * first use `resetTestEnvironment`.\r\n   *\r\n   * Test modules and platforms for individual platforms are available from\r\n   * '@angular/<platform_name>/testing'.\r\n   *\r\n   * @publicApi\r\n   */\n  initTestEnvironment(ngModule, platform, options) {\n    if (this.platform || this.ngModule) {\n      throw new Error('Cannot set base providers because it has already been called');\n    }\n    TestBedImpl._environmentTeardownOptions = options?.teardown;\n    TestBedImpl._environmentErrorOnUnknownElementsOption = options?.errorOnUnknownElements;\n    TestBedImpl._environmentErrorOnUnknownPropertiesOption = options?.errorOnUnknownProperties;\n    this.platform = platform;\n    this.ngModule = ngModule;\n    this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n    // TestBed does not have an API which can reliably detect the start of a test, and thus could be\n    // used to track the state of the NgModule registry and reset it correctly. Instead, when we\n    // know we're in a testing scenario, we disable the check for duplicate NgModule registration\n    // completely.\n    ɵsetAllowDuplicateNgModuleIdsForTest(true);\n  }\n  /**\r\n   * Reset the providers for the test injector.\r\n   *\r\n   * @publicApi\r\n   */\n  resetTestEnvironment() {\n    this.resetTestingModule();\n    this._compiler = null;\n    this.platform = null;\n    this.ngModule = null;\n    TestBedImpl._environmentTeardownOptions = undefined;\n    ɵsetAllowDuplicateNgModuleIdsForTest(false);\n  }\n  resetTestingModule() {\n    this.checkGlobalCompilationFinished();\n    ɵresetCompiledComponents();\n    if (this._compiler !== null) {\n      this.compiler.restoreOriginalState();\n    }\n    this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n    // Restore the previous value of the \"error on unknown elements\" option\n    ɵsetUnknownElementStrictMode(this._previousErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n    // Restore the previous value of the \"error on unknown properties\" option\n    ɵsetUnknownPropertyStrictMode(this._previousErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n    // We have to chain a couple of try/finally blocks, because each step can\n    // throw errors and we don't want it to interrupt the next step and we also\n    // want an error to be thrown at the end.\n    try {\n      this.destroyActiveFixtures();\n    } finally {\n      try {\n        if (this.shouldTearDownTestingModule()) {\n          this.tearDownTestingModule();\n        }\n      } finally {\n        this._testModuleRef = null;\n        this._instanceTeardownOptions = undefined;\n        this._instanceErrorOnUnknownElementsOption = undefined;\n        this._instanceErrorOnUnknownPropertiesOption = undefined;\n        this._instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n      }\n    }\n    return this;\n  }\n  configureCompiler(config) {\n    if (config.useJit != null) {\n      throw new Error('JIT compiler is not configurable via TestBed APIs.');\n    }\n    if (config.providers !== undefined) {\n      this.compiler.setCompilerProviders(config.providers);\n    }\n    return this;\n  }\n  configureTestingModule(moduleDef) {\n    this.assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n    // Trigger module scoping queue flush before executing other TestBed operations in a test.\n    // This is needed for the first test invocation to ensure that globally declared modules have\n    // their components scoped properly. See the `checkGlobalCompilationFinished` function\n    // description for additional info.\n    this.checkGlobalCompilationFinished();\n    // Always re-assign the options, even if they're undefined.\n    // This ensures that we don't carry them between tests.\n    this._instanceTeardownOptions = moduleDef.teardown;\n    this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n    this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\n    this._instanceDeferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    // Store the current value of the strict mode option,\n    // so we can restore it later\n    this._previousErrorOnUnknownElementsOption = ɵgetUnknownElementStrictMode();\n    ɵsetUnknownElementStrictMode(this.shouldThrowErrorOnUnknownElements());\n    this._previousErrorOnUnknownPropertiesOption = ɵgetUnknownPropertyStrictMode();\n    ɵsetUnknownPropertyStrictMode(this.shouldThrowErrorOnUnknownProperties());\n    this.compiler.configureTestingModule(moduleDef);\n    return this;\n  }\n  compileComponents() {\n    return this.compiler.compileComponents();\n  }\n  inject(token, notFoundValue, flags) {\n    if (token === TestBed) {\n      return this;\n    }\n    const UNDEFINED = {};\n    const result = this.testModuleRef.injector.get(token, UNDEFINED, ɵconvertToBitFlags(flags));\n    return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) : result;\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    return this.inject(token, notFoundValue, flags);\n  }\n  runInInjectionContext(fn) {\n    return runInInjectionContext(this.inject(EnvironmentInjector), fn);\n  }\n  execute(tokens, fn, context) {\n    const params = tokens.map(t => this.inject(t));\n    return fn.apply(context, params);\n  }\n  overrideModule(ngModule, override) {\n    this.assertNotInstantiated('overrideModule', 'override module metadata');\n    this.compiler.overrideModule(ngModule, override);\n    return this;\n  }\n  overrideComponent(component, override) {\n    this.assertNotInstantiated('overrideComponent', 'override component metadata');\n    this.compiler.overrideComponent(component, override);\n    return this;\n  }\n  overrideTemplateUsingTestingModule(component, template) {\n    this.assertNotInstantiated('TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n    this.compiler.overrideTemplateUsingTestingModule(component, template);\n    return this;\n  }\n  overrideDirective(directive, override) {\n    this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n    this.compiler.overrideDirective(directive, override);\n    return this;\n  }\n  overridePipe(pipe, override) {\n    this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n    this.compiler.overridePipe(pipe, override);\n    return this;\n  }\n  /**\r\n   * Overwrites all providers for the given token with the given provider definition.\r\n   */\n  overrideProvider(token, provider) {\n    this.assertNotInstantiated('overrideProvider', 'override provider');\n    this.compiler.overrideProvider(token, provider);\n    return this;\n  }\n  overrideTemplate(component, template) {\n    return this.overrideComponent(component, {\n      set: {\n        template,\n        templateUrl: null\n      }\n    });\n  }\n  createComponent(type) {\n    const testComponentRenderer = this.inject(TestComponentRenderer);\n    const rootElId = `root${_nextRootElementId++}`;\n    testComponentRenderer.insertRootElement(rootElId);\n    if (ɵgetAsyncClassMetadataFn(type)) {\n      throw new Error(`Component '${type.name}' has unresolved metadata. ` + `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n    }\n    const componentDef = type.ɵcmp;\n    if (!componentDef) {\n      throw new Error(`It looks like '${ɵstringify(type)}' has not been compiled.`);\n    }\n    const componentFactory = new ɵRender3ComponentFactory(componentDef);\n    const initComponent = () => {\n      const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);\n      return this.runInInjectionContext(() => {\n        const isZoneless = this.inject(ɵZONELESS_ENABLED);\n        const fixture = isZoneless ? new ScheduledComponentFixture(componentRef) : new PseudoApplicationComponentFixture(componentRef);\n        fixture.initialize();\n        return fixture;\n      });\n    };\n    const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n    const ngZone = noNgZone ? null : this.inject(NgZone, null);\n    const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n    this._activeFixtures.push(fixture);\n    return fixture;\n  }\n  /**\r\n   * @internal strip this from published d.ts files due to\r\n   * https://github.com/microsoft/TypeScript/issues/36216\r\n   */\n  get compiler() {\n    if (this._compiler === null) {\n      throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n    }\n    return this._compiler;\n  }\n  /**\r\n   * @internal strip this from published d.ts files due to\r\n   * https://github.com/microsoft/TypeScript/issues/36216\r\n   */\n  get testModuleRef() {\n    if (this._testModuleRef === null) {\n      this._testModuleRef = this.compiler.finalize();\n    }\n    return this._testModuleRef;\n  }\n  assertNotInstantiated(methodName, methodDescription) {\n    if (this._testModuleRef !== null) {\n      throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` + `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n    }\n  }\n  /**\r\n   * Check whether the module scoping queue should be flushed, and flush it if needed.\r\n   *\r\n   * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\r\n   * in-progress module compilation. This creates a potential hazard - the very first time the\r\n   * TestBed is initialized (or if it's reset without being initialized), there may be pending\r\n   * compilations of modules declared in global scope. These compilations should be finished.\r\n   *\r\n   * To ensure that globally declared modules have their components scoped properly, this function\r\n   * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\r\n   * to any other operations, the scoping queue is flushed.\r\n   */\n  checkGlobalCompilationFinished() {\n    // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n    // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n    if (!this.globalCompilationChecked && this._testModuleRef === null) {\n      ɵflushModuleScopingQueueAsMuchAsPossible();\n    }\n    this.globalCompilationChecked = true;\n  }\n  destroyActiveFixtures() {\n    let errorCount = 0;\n    this._activeFixtures.forEach(fixture => {\n      try {\n        fixture.destroy();\n      } catch (e) {\n        errorCount++;\n        console.error('Error during cleanup of component', {\n          component: fixture.componentInstance,\n          stacktrace: e\n        });\n      }\n    });\n    this._activeFixtures = [];\n    if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n      throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` + `threw errors during cleanup`);\n    }\n  }\n  shouldRethrowTeardownErrors() {\n    const instanceOptions = this._instanceTeardownOptions;\n    const environmentOptions = TestBedImpl._environmentTeardownOptions;\n    // If the new teardown behavior hasn't been configured, preserve the old behavior.\n    if (!instanceOptions && !environmentOptions) {\n      return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n    // Otherwise use the configured behavior or default to rethrowing.\n    return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ?? this.shouldTearDownTestingModule();\n  }\n  shouldThrowErrorOnUnknownElements() {\n    // Check if a configuration has been provided to throw when an unknown element is found\n    return this._instanceErrorOnUnknownElementsOption ?? TestBedImpl._environmentErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT;\n  }\n  shouldThrowErrorOnUnknownProperties() {\n    // Check if a configuration has been provided to throw when an unknown property is found\n    return this._instanceErrorOnUnknownPropertiesOption ?? TestBedImpl._environmentErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT;\n  }\n  shouldTearDownTestingModule() {\n    return this._instanceTeardownOptions?.destroyAfterEach ?? TestBedImpl._environmentTeardownOptions?.destroyAfterEach ?? TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n  }\n  getDeferBlockBehavior() {\n    return this._instanceDeferBlockBehavior;\n  }\n  tearDownTestingModule() {\n    // If the module ref has already been destroyed, we won't be able to get a test renderer.\n    if (this._testModuleRef === null) {\n      return;\n    }\n    // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n    // last step, but the injector will be destroyed as a part of the module ref destruction.\n    const testRenderer = this.inject(TestComponentRenderer);\n    try {\n      this._testModuleRef.destroy();\n    } catch (e) {\n      if (this.shouldRethrowTeardownErrors()) {\n        throw e;\n      } else {\n        console.error('Error during cleanup of a testing module', {\n          component: this._testModuleRef.instance,\n          stacktrace: e\n        });\n      }\n    } finally {\n      testRenderer.removeAllRootElements?.();\n    }\n  }\n  /**\r\n   * Execute any pending effects.\r\n   *\r\n   * @developerPreview\r\n   */\n  flushEffects() {\n    this.inject(ɵEffectScheduler).flush();\n  }\n}\n/**\r\n * @description\r\n * Configures and initializes environment for unit testing and provides methods for\r\n * creating components and services in unit tests.\r\n *\r\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\r\n *\r\n * @publicApi\r\n */\nconst TestBed = TestBedImpl;\n/**\r\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\r\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\r\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\r\n * function from the `@angular/core` package instead.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\r\n *   // some code that uses `dep` and `object`\r\n *   // ...\r\n * }));\r\n *\r\n * it('...', inject([AClass], (object) => {\r\n *   object.doSomething();\r\n *   expect(...);\r\n * })\r\n * ```\r\n *\r\n * @publicApi\r\n */\nfunction inject(tokens, fn) {\n  const testBed = TestBedImpl.INSTANCE;\n  // Not using an arrow function to preserve context passed from call site\n  return function () {\n    return testBed.execute(tokens, fn, this);\n  };\n}\n/**\r\n * @publicApi\r\n */\nclass InjectSetupWrapper {\n  constructor(_moduleDef) {\n    this._moduleDef = _moduleDef;\n  }\n  _addModule() {\n    const moduleDef = this._moduleDef();\n    if (moduleDef) {\n      TestBedImpl.configureTestingModule(moduleDef);\n    }\n  }\n  inject(tokens, fn) {\n    const self = this;\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      self._addModule();\n      return inject(tokens, fn).call(this);\n    };\n  }\n}\nfunction withModule(moduleDef, fn) {\n  if (fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      const testBed = TestBedImpl.INSTANCE;\n      if (moduleDef) {\n        testBed.configureTestingModule(moduleDef);\n      }\n      return fn.apply(this);\n    };\n  }\n  return new InjectSetupWrapper(() => moduleDef);\n}\n\n/**\r\n * Public Test Library for unit testing Angular applications. Assumes that you are running\r\n * with Jasmine, Mocha, or a similar framework which exports a beforeEach function and\r\n * allows tests to be asynchronous by either returning a promise or using a 'done' parameter.\r\n */\n// Reset the test providers and the fake async zone before each test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// beforeEach is only defined when executing the tests\nglobalThis.beforeEach?.(getCleanupHook(false));\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// afterEach is only defined when executing the tests\nglobalThis.afterEach?.(getCleanupHook(true));\nfunction getCleanupHook(expectedTeardownValue) {\n  return () => {\n    const testBed = TestBedImpl.INSTANCE;\n    if (testBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n      testBed.resetTestingModule();\n      resetFakeAsyncZoneIfExists();\n    }\n  };\n}\n/**\r\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\r\n * investigation.\r\n *\r\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\r\n *\r\n * @codeGenApi\r\n */\n// TODO(iminar): Remove this code in a safe way.\nconst __core_private_testing_placeholder__ = '';\n\n/**\r\n * @module\r\n * @description\r\n * Entry point for all public APIs of the core/testing package.\r\n */\n\n/// <reference types=\"jasmine\" />\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, DeferBlockFixture, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, MetadataOverrider as ɵMetadataOverrider };","map":{"version":3,"names":["ɵDeferBlockState","ɵtriggerResourceLoading","ɵrenderDeferBlockState","ɵCONTAINER_HEADER_OFFSET","ɵgetDeferBlocks","ɵDeferBlockBehavior","InjectionToken","inject","inject$1","ɵNoopNgZone","NgZone","ɵEffectScheduler","ApplicationRef","ɵPendingTasks","getDebugNode","RendererFactory2","ɵdetectChangesInViewIfRequired","ɵstringify","ɵReflectionCapabilities","Directive","Component","Pipe","NgModule","ɵgetAsyncClassMetadataFn","ɵgenerateStandaloneInDeclarationsError","ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT","ɵdepsTracker","ɵgetInjectableDef","resolveForwardRef","ɵNG_COMP_DEF","ɵisComponentDefPendingResolution","ɵresolveComponentResources","ɵRender3NgModuleRef","ApplicationInitStatus","LOCALE_ID","ɵDEFAULT_LOCALE_ID","ɵsetLocaleId","ɵRender3ComponentFactory","ɵcompileComponent","ɵNG_DIR_DEF","ɵcompileDirective","ɵNG_PIPE_DEF","ɵcompilePipe","ɵNG_MOD_DEF","ɵtransitiveScopesFor","ɵpatchComponentDefWithScope","ɵNG_INJ_DEF","ɵcompileNgModuleDefs","ɵclearResolutionOfComponentResourcesQueue","ɵrestoreComponentResolutionQueue","ɵinternalProvideZoneChangeDetection","ɵChangeDetectionScheduler","ɵChangeDetectionSchedulerImpl","Compiler","ɵDEFER_BLOCK_CONFIG","COMPILER_OPTIONS","Injector","ɵisEnvironmentProviders","ɵNgModuleFactory","ModuleWithComponentFactories","ɵconvertToBitFlags","InjectFlags","ɵsetAllowDuplicateNgModuleIdsForTest","ɵresetCompiledComponents","ɵsetUnknownElementStrictMode","ɵsetUnknownPropertyStrictMode","ɵgetUnknownElementStrictMode","ɵgetUnknownPropertyStrictMode","runInInjectionContext","EnvironmentInjector","ɵZONELESS_ENABLED","ɵflushModuleScopingQueueAsMuchAsPossible","DeferBlockBehavior","DeferBlockState","Subscription","first","ResourceLoader","waitForAsync","fn","_Zone","Zone","Promise","reject","asyncTest","__symbol__","DeferBlockFixture","constructor","block","componentFixture","render","state","_this","_asyncToGenerator","hasStateTemplate","stateAsString","getDeferBlockStateNameFromEnum","Error","toLowerCase","Complete","tDetails","lView","tNode","skipTimerScheduling","lContainer","detectChanges","getDeferBlocks","deferBlocks","deferBlockFixtures","length","push","resolve","Placeholder","placeholderTmplIndex","Loading","loadingTmplIndex","errorTmplIndex","TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT","THROW_ON_UNKNOWN_ELEMENTS_DEFAULT","THROW_ON_UNKNOWN_PROPERTIES_DEFAULT","DEFER_BLOCK_DEFAULT_BEHAVIOR","Playthrough","TestComponentRenderer","insertRootElement","rootElementId","removeAllRootElements","ComponentFixtureAutoDetect","ComponentFixtureNoNgZone","ComponentFixture","componentRef","_isDestroyed","_noZoneOptionIsSet","optional","_ngZone","_effectRunner","_appRef","_testAppRef","pendingTasks","ngZone","changeDetectorRef","elementRef","location","debugElement","nativeElement","componentInstance","instance","checkNoChanges","isStable","hasPendingTasks","value","whenStable","pipe","stable","toPromise","hostView","_getRenderer","_renderer","undefined","injector","get","whenRenderingDone","renderer","destroy","ScheduledComponentFixture","arguments","_autoDetect","initialize","attachView","flush","tick","autoDetectChanges","autoDetect","PseudoApplicationComponentFixture","_subscriptions","afterTickSubscription","beforeRenderSubscription","subscribeToAppRefEvents","onDestroy","unsubscribeFromAppRefEvents","runOutsideAngular","add","onError","subscribe","next","error","run","afterTick","beforeRender","isFirstPass","_lView","notifyErrorHandler","e","externalTestViews","unsubscribe","delete","fakeAsyncTestModule","fakeAsyncTestModuleNotLoadedErrorMessage","resetFakeAsyncZone","resetFakeAsyncZoneIfExists","fakeAsync","millis","tickOptions","processNewMacroTasksSynchronously","maxTurns","discardPeriodicTasks","flushMicrotasks","_nextReferenceId","MetadataOverrider","_references","Map","overrideMetadata","metadataClass","oldMetadata","override","props","_valueProps","forEach","prop","set","remove","setMetadata","removeMetadata","addMetadata","metadata","references","removeObjects","Set","removeValue","Array","isArray","_propHashKey","propValue","filter","has","addValue","concat","propName","nextObjectId","objectIds","replacer","key","_serializeReference","JSON","stringify","ref","id","obj","Object","keys","startsWith","proto","getPrototypeOf","protoProp","desc","getOwnPropertyDescriptor","reflection","OverrideResolver","overrides","resolved","addOverride","type","setOverrides","clear","getAnnotation","annotations","i","annotation","isKnownType","overrider","DirectiveResolver","ComponentResolver","PipeResolver","NgModuleResolver","TestingModuleOverride","isTestingModuleOverride","DECLARATION","OVERRIDE_TEMPLATE","assertNoStandaloneComponents","types","resolver","component","standalone","TestBedCompiler","platform","additionalModuleTypes","originalComponentResolutionQueue","declarations","imports","providers","schemas","pendingComponents","pendingDirectives","pendingPipes","componentsWithAsyncMetadata","seenComponents","seenDirectives","overriddenModules","existingComponentStyles","resolvers","initResolvers","componentToModuleScope","initialNgDefs","defCleanupOps","_injector","compilerProviders","providerOverrides","rootProviderOverrides","providerOverridesByModule","providerOverridesByToken","scopesWithOverriddenProviders","testModuleRef","deferBlockBehavior","DynamicTestModule","testModuleType","setCompilerProviders","configureTestingModule","moduleDef","queueTypeArray","queueTypesFromModulesArray","overrideModule","ngModule","clearScopeCacheFor","module","invalidTypeError","name","recompileNgModule","overrideComponent","verifyNoStandaloneFlagOverrides","maybeRegisterComponentWithAsyncMetadata","overrideDirective","directive","overridePipe","hasOwnProperty","overrideProvider","token","provider","providerDef","useFactory","provide","deps","multi","useValue","injectableDef","providedIn","overridesBucket","existingOverrides","overrideTemplateUsingTestingModule","template","def","hasStyleUrls","styleUrl","styleUrls","overrideStyleUrls","styles","resolvePendingComponentsWithAsyncMetadata","_this2","size","promises","asyncMetadataFn","resolvedDeps","all","flatResolvedDeps","flat","applyProviderOverridesInScope","compileComponents","_this3","clearComponentResolutionQueue","needsAsyncResources","compileTypesSync","resourceLoader","url","finalize","compileTestModule","applyTransitiveScopes","applyProviderOverrides","patchComponentsWithExistingStyles","parentInjector","runInitializers","localeId","_compileNgModuleSync","moduleType","_compileNgModuleAsync","_this4","_getModuleResolver","_getComponentFactories","maybeUnwrapFn","ɵmod","reduce","factories","declaration","componentDef","ɵcmp","maybeStoreNgDef","testingModuleDef","affectedModules","collectModulesAffectedByOverrides","storeFieldOfDefOnType","transitiveCompileScopes","moduleToScope","getScopeOfModule","isTestingModule","realType","componentType","moduleScope","getComponentDef","maybeApplyOverrides","field","hasProviderOverrides","patchDefWithProviderOverrides","hasScope","isStandaloneComponent","isNgModule","injectorDef","dependencies","dependency","getOverriddenProviders","importedModule","flatten","isModuleWithProviders","object","fieldName","originalValue","arr","queueType","processedDefs","queueTypesFromModulesArrayRecur","hasNgModuleDef","exports","seenModules","calcAffectedModulesRecur","path","item","currentDefs","currentDef","defField","restoreComponentResolutionQueue","restoreOriginalState","forEachRight","op","defs","descriptor","defineProperty","RootScopeModule","useExisting","R3TestCompiler","behavior","compilerOptions","opts","create","parent","getSingleProviderOverrides","getProviderToken","getProviderOverrides","flattenProviders","flattenedProviders","overriddenProviders","final","seenOverriddenProviders","unshift","providersResolver","processProvidersFn","ngDef","maybeFn","Function","values","out","identityFn","mapFn","ɵproviders","getProviderField","idx","expectedType","testBed","compileModuleSync","compileModuleAsync","_this5","compileModuleAndAllComponentsSync","ngModuleFactory","componentFactories","compileModuleAndAllComponentsAsync","_this6","clearCache","clearCacheFor","getModuleId","meta","_nextRootElementId","getTestBed","TestBedImpl","INSTANCE","_instanceDeferBlockBehavior","_compiler","_testModuleRef","_activeFixtures","globalCompilationChecked","_","_INSTANCE","initTestEnvironment","options","resetTestEnvironment","configureCompiler","config","overrideTemplate","notFoundValue","flags","THROW_IF_NOT_FOUND","Default","createComponent","resetTestingModule","execute","tokens","context","flushEffects","_environmentTeardownOptions","teardown","_environmentErrorOnUnknownElementsOption","errorOnUnknownElements","_environmentErrorOnUnknownPropertiesOption","errorOnUnknownProperties","checkGlobalCompilationFinished","compiler","_previousErrorOnUnknownElementsOption","_previousErrorOnUnknownPropertiesOption","destroyActiveFixtures","shouldTearDownTestingModule","tearDownTestingModule","_instanceTeardownOptions","_instanceErrorOnUnknownElementsOption","_instanceErrorOnUnknownPropertiesOption","useJit","assertNotInstantiated","shouldThrowErrorOnUnknownElements","shouldThrowErrorOnUnknownProperties","TestBed","UNDEFINED","result","params","map","t","apply","templateUrl","testComponentRenderer","rootElId","componentFactory","initComponent","NULL","isZoneless","fixture","noNgZone","methodName","methodDescription","errorCount","console","stacktrace","shouldRethrowTeardownErrors","instanceOptions","environmentOptions","rethrowErrors","destroyAfterEach","getDeferBlockBehavior","testRenderer","InjectSetupWrapper","_moduleDef","_addModule","self","call","withModule","globalThis","beforeEach","getCleanupHook","afterEach","expectedTeardownValue","__core_private_testing_placeholder__","ɵMetadataOverrider"],"sources":["C:/Users/Hamzah Alkhateeb/Desktop/Halal Eatz/HalalEats/node_modules/@angular/core/fesm2022/testing.mjs"],"sourcesContent":["/**\r\n * @license Angular v18.0.1\r\n * (c) 2010-2024 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { ɵDeferBlockState, ɵtriggerResourceLoading, ɵrenderDeferBlockState, ɵCONTAINER_HEADER_OFFSET, ɵgetDeferBlocks, ɵDeferBlockBehavior, InjectionToken, inject as inject$1, ɵNoopNgZone, NgZone, ɵEffectScheduler, ApplicationRef, ɵPendingTasks, getDebugNode, RendererFactory2, ɵdetectChangesInViewIfRequired, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetAsyncClassMetadataFn, ɵgenerateStandaloneInDeclarationsError, ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT, ɵdepsTracker, ɵgetInjectableDef, resolveForwardRef, ɵNG_COMP_DEF, ɵisComponentDefPendingResolution, ɵresolveComponentResources, ɵRender3NgModuleRef, ApplicationInitStatus, LOCALE_ID, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIR_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵNG_MOD_DEF, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJ_DEF, ɵcompileNgModuleDefs, ɵclearResolutionOfComponentResourcesQueue, ɵrestoreComponentResolutionQueue, ɵinternalProvideZoneChangeDetection, ɵChangeDetectionScheduler, ɵChangeDetectionSchedulerImpl, Compiler, ɵDEFER_BLOCK_CONFIG, COMPILER_OPTIONS, Injector, ɵisEnvironmentProviders, ɵNgModuleFactory, ModuleWithComponentFactories, ɵconvertToBitFlags, InjectFlags, ɵsetAllowDuplicateNgModuleIdsForTest, ɵresetCompiledComponents, ɵsetUnknownElementStrictMode, ɵsetUnknownPropertyStrictMode, ɵgetUnknownElementStrictMode, ɵgetUnknownPropertyStrictMode, runInInjectionContext, EnvironmentInjector, ɵZONELESS_ENABLED, ɵflushModuleScopingQueueAsMuchAsPossible } from '@angular/core';\r\nexport { ɵDeferBlockBehavior as DeferBlockBehavior, ɵDeferBlockState as DeferBlockState } from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\nimport { first } from 'rxjs/operators';\r\nimport { ResourceLoader } from '@angular/compiler';\r\n\r\n/**\r\n * Wraps a test function in an asynchronous test zone. The test will automatically\r\n * complete when all asynchronous calls within this zone are done. Can be used\r\n * to wrap an {@link inject} call.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * it('...', waitForAsync(inject([AClass], (object) => {\r\n *   object.doSomething.then(() => {\r\n *     expect(...);\r\n *   })\r\n * })));\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nfunction waitForAsync(fn) {\r\n    const _Zone = typeof Zone !== 'undefined' ? Zone : null;\r\n    if (!_Zone) {\r\n        return function () {\r\n            return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' +\r\n                'Please make sure that your environment includes zone.js');\r\n        };\r\n    }\r\n    const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\r\n    if (typeof asyncTest === 'function') {\r\n        return asyncTest(fn);\r\n    }\r\n    return function () {\r\n        return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' +\r\n            'Please make sure that your environment includes zone.js/testing');\r\n    };\r\n}\r\n\r\n/**\r\n * Represents an individual defer block for testing purposes.\r\n *\r\n * @publicApi\r\n */\r\nclass DeferBlockFixture {\r\n    /** @nodoc */\r\n    constructor(block, componentFixture) {\r\n        this.block = block;\r\n        this.componentFixture = componentFixture;\r\n    }\r\n    /**\r\n     * Renders the specified state of the defer fixture.\r\n     * @param state the defer state to render\r\n     */\r\n    async render(state) {\r\n        if (!hasStateTemplate(state, this.block)) {\r\n            const stateAsString = getDeferBlockStateNameFromEnum(state);\r\n            throw new Error(`Tried to render this defer block in the \\`${stateAsString}\\` state, ` +\r\n                `but there was no @${stateAsString.toLowerCase()} block defined in a template.`);\r\n        }\r\n        if (state === ɵDeferBlockState.Complete) {\r\n            await ɵtriggerResourceLoading(this.block.tDetails, this.block.lView, this.block.tNode);\r\n        }\r\n        // If the `render` method is used explicitly - skip timer-based scheduling for\r\n        // `@placeholder` and `@loading` blocks and render them immediately.\r\n        const skipTimerScheduling = true;\r\n        ɵrenderDeferBlockState(state, this.block.tNode, this.block.lContainer, skipTimerScheduling);\r\n        this.componentFixture.detectChanges();\r\n    }\r\n    /**\r\n     * Retrieves all nested child defer block fixtures\r\n     * in a given defer block.\r\n     */\r\n    getDeferBlocks() {\r\n        const deferBlocks = [];\r\n        // An LContainer that represents a defer block has at most 1 view, which is\r\n        // located right after an LContainer header. Get a hold of that view and inspect\r\n        // it for nested defer blocks.\r\n        const deferBlockFixtures = [];\r\n        if (this.block.lContainer.length >= ɵCONTAINER_HEADER_OFFSET) {\r\n            const lView = this.block.lContainer[ɵCONTAINER_HEADER_OFFSET];\r\n            ɵgetDeferBlocks(lView, deferBlocks);\r\n            for (const block of deferBlocks) {\r\n                deferBlockFixtures.push(new DeferBlockFixture(block, this.componentFixture));\r\n            }\r\n        }\r\n        return Promise.resolve(deferBlockFixtures);\r\n    }\r\n}\r\nfunction hasStateTemplate(state, block) {\r\n    switch (state) {\r\n        case ɵDeferBlockState.Placeholder:\r\n            return block.tDetails.placeholderTmplIndex !== null;\r\n        case ɵDeferBlockState.Loading:\r\n            return block.tDetails.loadingTmplIndex !== null;\r\n        case ɵDeferBlockState.Error:\r\n            return block.tDetails.errorTmplIndex !== null;\r\n        case ɵDeferBlockState.Complete:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction getDeferBlockStateNameFromEnum(state) {\r\n    switch (state) {\r\n        case ɵDeferBlockState.Placeholder:\r\n            return 'Placeholder';\r\n        case ɵDeferBlockState.Loading:\r\n            return 'Loading';\r\n        case ɵDeferBlockState.Error:\r\n            return 'Error';\r\n        default:\r\n            return 'Main';\r\n    }\r\n}\r\n\r\n/** Whether test modules should be torn down by default. */\r\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\r\n/** Whether unknown elements in templates should throw by default. */\r\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\r\n/** Whether unknown properties in templates should throw by default. */\r\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\r\n/** Whether defer blocks should use manual triggering or play through normally. */\r\nconst DEFER_BLOCK_DEFAULT_BEHAVIOR = ɵDeferBlockBehavior.Playthrough;\r\n/**\r\n * An abstract class for inserting the root test component element in a platform independent way.\r\n *\r\n * @publicApi\r\n */\r\nclass TestComponentRenderer {\r\n    insertRootElement(rootElementId) { }\r\n    removeAllRootElements() { }\r\n}\r\n/**\r\n * @publicApi\r\n */\r\nconst ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\r\n/**\r\n * @publicApi\r\n */\r\nconst ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\r\n\r\n/**\r\n * Fixture for debugging and testing a component.\r\n *\r\n * @publicApi\r\n */\r\nclass ComponentFixture {\r\n    /** @nodoc */\r\n    constructor(componentRef) {\r\n        this.componentRef = componentRef;\r\n        this._isDestroyed = false;\r\n        /** @internal */\r\n        this._noZoneOptionIsSet = inject$1(ComponentFixtureNoNgZone, { optional: true });\r\n        /** @internal */\r\n        this._ngZone = this._noZoneOptionIsSet ? new ɵNoopNgZone() : inject$1(NgZone);\r\n        /** @internal */\r\n        this._effectRunner = inject$1(ɵEffectScheduler);\r\n        // Inject ApplicationRef to ensure NgZone stableness causes after render hooks to run\r\n        // This will likely happen as a result of fixture.detectChanges because it calls ngZone.run\r\n        // This is a crazy way of doing things but hey, it's the world we live in.\r\n        // The zoneless scheduler should instead do this more imperatively by attaching\r\n        // the `ComponentRef` to `ApplicationRef` and calling `appRef.tick` as the `detectChanges`\r\n        // behavior.\r\n        /** @internal */\r\n        this._appRef = inject$1(ApplicationRef);\r\n        /** @internal */\r\n        this._testAppRef = this._appRef;\r\n        this.pendingTasks = inject$1(ɵPendingTasks);\r\n        // TODO(atscott): Remove this from public API\r\n        this.ngZone = this._noZoneOptionIsSet ? null : this._ngZone;\r\n        this.changeDetectorRef = componentRef.changeDetectorRef;\r\n        this.elementRef = componentRef.location;\r\n        this.debugElement = getDebugNode(this.elementRef.nativeElement);\r\n        this.componentInstance = componentRef.instance;\r\n        this.nativeElement = this.elementRef.nativeElement;\r\n        this.componentRef = componentRef;\r\n    }\r\n    /**\r\n     * Do a change detection run to make sure there were no changes.\r\n     */\r\n    checkNoChanges() {\r\n        this.changeDetectorRef.checkNoChanges();\r\n    }\r\n    /**\r\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\r\n     * yet.\r\n     */\r\n    isStable() {\r\n        return !this.pendingTasks.hasPendingTasks.value;\r\n    }\r\n    /**\r\n     * Get a promise that resolves when the fixture is stable.\r\n     *\r\n     * This can be used to resume testing after events have triggered asynchronous activity or\r\n     * asynchronous change detection.\r\n     */\r\n    whenStable() {\r\n        if (this.isStable()) {\r\n            return Promise.resolve(false);\r\n        }\r\n        return this._appRef.isStable.pipe(first((stable) => stable)).toPromise();\r\n    }\r\n    /**\r\n     * Retrieves all defer block fixtures in the component fixture.\r\n     */\r\n    getDeferBlocks() {\r\n        const deferBlocks = [];\r\n        const lView = this.componentRef.hostView['_lView'];\r\n        ɵgetDeferBlocks(lView, deferBlocks);\r\n        const deferBlockFixtures = [];\r\n        for (const block of deferBlocks) {\r\n            deferBlockFixtures.push(new DeferBlockFixture(block, this));\r\n        }\r\n        return Promise.resolve(deferBlockFixtures);\r\n    }\r\n    _getRenderer() {\r\n        if (this._renderer === undefined) {\r\n            this._renderer = this.componentRef.injector.get(RendererFactory2, null);\r\n        }\r\n        return this._renderer;\r\n    }\r\n    /**\r\n     * Get a promise that resolves when the ui state is stable following animations.\r\n     */\r\n    whenRenderingDone() {\r\n        const renderer = this._getRenderer();\r\n        if (renderer && renderer.whenRenderingDone) {\r\n            return renderer.whenRenderingDone();\r\n        }\r\n        return this.whenStable();\r\n    }\r\n    /**\r\n     * Trigger component destruction.\r\n     */\r\n    destroy() {\r\n        if (!this._isDestroyed) {\r\n            this.componentRef.destroy();\r\n            this._isDestroyed = true;\r\n        }\r\n    }\r\n}\r\n/**\r\n * ComponentFixture behavior that actually attaches the component to the application to ensure\r\n * behaviors between fixture and application do not diverge. `detectChanges` is disabled by default\r\n * (instead, tests should wait for the scheduler to detect changes), `whenStable` is directly the\r\n * `ApplicationRef.isStable`, and `autoDetectChanges` cannot be disabled.\r\n */\r\nclass ScheduledComponentFixture extends ComponentFixture {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._autoDetect = inject$1(ComponentFixtureAutoDetect, { optional: true }) ?? true;\r\n    }\r\n    initialize() {\r\n        if (this._autoDetect) {\r\n            this._appRef.attachView(this.componentRef.hostView);\r\n        }\r\n    }\r\n    detectChanges(checkNoChanges = true) {\r\n        if (!checkNoChanges) {\r\n            throw new Error('Cannot disable `checkNoChanges` in this configuration. ' +\r\n                'Use `fixture.componentRef.hostView.changeDetectorRef.detectChanges()` instead.');\r\n        }\r\n        this._effectRunner.flush();\r\n        this._appRef.tick();\r\n        this._effectRunner.flush();\r\n    }\r\n    autoDetectChanges(autoDetect = true) {\r\n        if (!autoDetect) {\r\n            throw new Error('Cannot disable autoDetect after it has been enabled when using the zoneless scheduler. ' +\r\n                'To disable autoDetect, add `{provide: ComponentFixtureAutoDetect, useValue: false}` to the TestBed providers.');\r\n        }\r\n        else if (!this._autoDetect) {\r\n            this._autoDetect = autoDetect;\r\n            this._appRef.attachView(this.componentRef.hostView);\r\n        }\r\n        this.detectChanges();\r\n    }\r\n}\r\n/**\r\n * ComponentFixture behavior that attempts to act as a \"mini application\".\r\n */\r\nclass PseudoApplicationComponentFixture extends ComponentFixture {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._subscriptions = new Subscription();\r\n        this._autoDetect = inject$1(ComponentFixtureAutoDetect, { optional: true }) ?? false;\r\n        this.afterTickSubscription = undefined;\r\n        this.beforeRenderSubscription = undefined;\r\n    }\r\n    initialize() {\r\n        if (this._autoDetect) {\r\n            this.subscribeToAppRefEvents();\r\n        }\r\n        this.componentRef.hostView.onDestroy(() => {\r\n            this.unsubscribeFromAppRefEvents();\r\n        });\r\n        // Create subscriptions outside the NgZone so that the callbacks run outside\r\n        // of NgZone.\r\n        this._ngZone.runOutsideAngular(() => {\r\n            this._subscriptions.add(this._ngZone.onError.subscribe({\r\n                next: (error) => {\r\n                    throw error;\r\n                },\r\n            }));\r\n        });\r\n    }\r\n    detectChanges(checkNoChanges = true) {\r\n        this._effectRunner.flush();\r\n        // Run the change detection inside the NgZone so that any async tasks as part of the change\r\n        // detection are captured by the zone and can be waited for in isStable.\r\n        this._ngZone.run(() => {\r\n            this.changeDetectorRef.detectChanges();\r\n            if (checkNoChanges) {\r\n                this.checkNoChanges();\r\n            }\r\n        });\r\n        // Run any effects that were created/dirtied during change detection. Such effects might become\r\n        // dirty in response to input signals changing.\r\n        this._effectRunner.flush();\r\n    }\r\n    autoDetectChanges(autoDetect = true) {\r\n        if (this._noZoneOptionIsSet) {\r\n            throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.');\r\n        }\r\n        if (autoDetect !== this._autoDetect) {\r\n            if (autoDetect) {\r\n                this.subscribeToAppRefEvents();\r\n            }\r\n            else {\r\n                this.unsubscribeFromAppRefEvents();\r\n            }\r\n        }\r\n        this._autoDetect = autoDetect;\r\n        this.detectChanges();\r\n    }\r\n    subscribeToAppRefEvents() {\r\n        this._ngZone.runOutsideAngular(() => {\r\n            this.afterTickSubscription = this._testAppRef.afterTick.subscribe(() => {\r\n                this.checkNoChanges();\r\n            });\r\n            this.beforeRenderSubscription = this._testAppRef.beforeRender.subscribe((isFirstPass) => {\r\n                try {\r\n                    ɵdetectChangesInViewIfRequired(this.componentRef.hostView._lView, this.componentRef.hostView.notifyErrorHandler, isFirstPass, false /** zoneless enabled */);\r\n                }\r\n                catch (e) {\r\n                    // If an error occurred during change detection, remove the test view from the application\r\n                    // ref tracking. Note that this isn't exactly desirable but done this way because of how\r\n                    // things used to work with `autoDetect` and uncaught errors. Ideally we would surface\r\n                    // this error to the error handler instead and continue refreshing the view like\r\n                    // what would happen in the application.\r\n                    this.unsubscribeFromAppRefEvents();\r\n                    throw e;\r\n                }\r\n            });\r\n            this._testAppRef.externalTestViews.add(this.componentRef.hostView);\r\n        });\r\n    }\r\n    unsubscribeFromAppRefEvents() {\r\n        this.afterTickSubscription?.unsubscribe();\r\n        this.beforeRenderSubscription?.unsubscribe();\r\n        this.afterTickSubscription = undefined;\r\n        this.beforeRenderSubscription = undefined;\r\n        this._testAppRef.externalTestViews.delete(this.componentRef.hostView);\r\n    }\r\n    destroy() {\r\n        this.unsubscribeFromAppRefEvents();\r\n        this._subscriptions.unsubscribe();\r\n        super.destroy();\r\n    }\r\n}\r\n\r\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\r\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\r\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\r\n        Please make sure that your environment includes zone.js/testing`;\r\n/**\r\n * Clears out the shared fake async zone for a test.\r\n * To be called in a global `beforeEach`.\r\n *\r\n * @publicApi\r\n */\r\nfunction resetFakeAsyncZone() {\r\n    if (fakeAsyncTestModule) {\r\n        return fakeAsyncTestModule.resetFakeAsyncZone();\r\n    }\r\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\r\n}\r\nfunction resetFakeAsyncZoneIfExists() {\r\n    if (fakeAsyncTestModule) {\r\n        fakeAsyncTestModule.resetFakeAsyncZone();\r\n    }\r\n}\r\n/**\r\n * Wraps a function to be executed in the `fakeAsync` zone:\r\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\r\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\r\n *\r\n * If there are any pending timers at the end of the function, an exception is thrown.\r\n *\r\n * Can be used to wrap `inject()` calls.\r\n *\r\n * @param fn The function that you want to wrap in the `fakeAsync` zone.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/testing/ts/fake_async.ts region='basic'}\r\n *\r\n *\r\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\r\n * Any arguments passed when calling this returned function will be passed through to the `fn`\r\n * function in the parameters when it is called.\r\n *\r\n * @publicApi\r\n */\r\nfunction fakeAsync(fn) {\r\n    if (fakeAsyncTestModule) {\r\n        return fakeAsyncTestModule.fakeAsync(fn);\r\n    }\r\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\r\n}\r\n/**\r\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\r\n *\r\n * The microtasks queue is drained at the very start of this function and after any timer callback\r\n * has been executed.\r\n *\r\n * @param millis The number of milliseconds to advance the virtual timer.\r\n * @param tickOptions The options to pass to the `tick()` function.\r\n *\r\n * @usageNotes\r\n *\r\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\r\n * which determines whether or not to invoke new macroTasks.\r\n *\r\n * If you provide a `tickOptions` object, but do not specify a\r\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\r\n * then `processNewMacroTasksSynchronously` defaults to true.\r\n *\r\n * If you omit the `tickOptions` parameter (`tick(100))`), then\r\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\r\n *\r\n * ### Example\r\n *\r\n * {@example core/testing/ts/fake_async.ts region='basic'}\r\n *\r\n * The following example includes a nested timeout (new macroTask), and\r\n * the `tickOptions` parameter is allowed to default. In this case,\r\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\r\n * function is executed on each tick.\r\n *\r\n * ```\r\n * it ('test with nested setTimeout', fakeAsync(() => {\r\n *   let nestedTimeoutInvoked = false;\r\n *   function funcWithNestedTimeout() {\r\n *     setTimeout(() => {\r\n *       nestedTimeoutInvoked = true;\r\n *     });\r\n *   };\r\n *   setTimeout(funcWithNestedTimeout);\r\n *   tick();\r\n *   expect(nestedTimeoutInvoked).toBe(true);\r\n * }));\r\n * ```\r\n *\r\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\r\n * set to false, so the nested timeout function is not invoked.\r\n *\r\n * ```\r\n * it ('test with nested setTimeout', fakeAsync(() => {\r\n *   let nestedTimeoutInvoked = false;\r\n *   function funcWithNestedTimeout() {\r\n *     setTimeout(() => {\r\n *       nestedTimeoutInvoked = true;\r\n *     });\r\n *   };\r\n *   setTimeout(funcWithNestedTimeout);\r\n *   tick(0, {processNewMacroTasksSynchronously: false});\r\n *   expect(nestedTimeoutInvoked).toBe(false);\r\n * }));\r\n * ```\r\n *\r\n *\r\n * @publicApi\r\n */\r\nfunction tick(millis = 0, tickOptions = {\r\n    processNewMacroTasksSynchronously: true,\r\n}) {\r\n    if (fakeAsyncTestModule) {\r\n        return fakeAsyncTestModule.tick(millis, tickOptions);\r\n    }\r\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\r\n}\r\n/**\r\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\r\n * the `fakeAsync` zone by\r\n * draining the macrotask queue until it is empty.\r\n *\r\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\r\n *     throwing an error.\r\n * @returns The simulated time elapsed, in milliseconds.\r\n *\r\n * @publicApi\r\n */\r\nfunction flush(maxTurns) {\r\n    if (fakeAsyncTestModule) {\r\n        return fakeAsyncTestModule.flush(maxTurns);\r\n    }\r\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\r\n}\r\n/**\r\n * Discard all remaining periodic tasks.\r\n *\r\n * @publicApi\r\n */\r\nfunction discardPeriodicTasks() {\r\n    if (fakeAsyncTestModule) {\r\n        return fakeAsyncTestModule.discardPeriodicTasks();\r\n    }\r\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\r\n}\r\n/**\r\n * Flush any pending microtasks.\r\n *\r\n * @publicApi\r\n */\r\nfunction flushMicrotasks() {\r\n    if (fakeAsyncTestModule) {\r\n        return fakeAsyncTestModule.flushMicrotasks();\r\n    }\r\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\r\n}\r\n\r\nlet _nextReferenceId = 0;\r\nclass MetadataOverrider {\r\n    constructor() {\r\n        this._references = new Map();\r\n    }\r\n    /**\r\n     * Creates a new instance for the given metadata class\r\n     * based on an old instance and overrides.\r\n     */\r\n    overrideMetadata(metadataClass, oldMetadata, override) {\r\n        const props = {};\r\n        if (oldMetadata) {\r\n            _valueProps(oldMetadata).forEach((prop) => (props[prop] = oldMetadata[prop]));\r\n        }\r\n        if (override.set) {\r\n            if (override.remove || override.add) {\r\n                throw new Error(`Cannot set and add/remove ${ɵstringify(metadataClass)} at the same time!`);\r\n            }\r\n            setMetadata(props, override.set);\r\n        }\r\n        if (override.remove) {\r\n            removeMetadata(props, override.remove, this._references);\r\n        }\r\n        if (override.add) {\r\n            addMetadata(props, override.add);\r\n        }\r\n        return new metadataClass(props);\r\n    }\r\n}\r\nfunction removeMetadata(metadata, remove, references) {\r\n    const removeObjects = new Set();\r\n    for (const prop in remove) {\r\n        const removeValue = remove[prop];\r\n        if (Array.isArray(removeValue)) {\r\n            removeValue.forEach((value) => {\r\n                removeObjects.add(_propHashKey(prop, value, references));\r\n            });\r\n        }\r\n        else {\r\n            removeObjects.add(_propHashKey(prop, removeValue, references));\r\n        }\r\n    }\r\n    for (const prop in metadata) {\r\n        const propValue = metadata[prop];\r\n        if (Array.isArray(propValue)) {\r\n            metadata[prop] = propValue.filter((value) => !removeObjects.has(_propHashKey(prop, value, references)));\r\n        }\r\n        else {\r\n            if (removeObjects.has(_propHashKey(prop, propValue, references))) {\r\n                metadata[prop] = undefined;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction addMetadata(metadata, add) {\r\n    for (const prop in add) {\r\n        const addValue = add[prop];\r\n        const propValue = metadata[prop];\r\n        if (propValue != null && Array.isArray(propValue)) {\r\n            metadata[prop] = propValue.concat(addValue);\r\n        }\r\n        else {\r\n            metadata[prop] = addValue;\r\n        }\r\n    }\r\n}\r\nfunction setMetadata(metadata, set) {\r\n    for (const prop in set) {\r\n        metadata[prop] = set[prop];\r\n    }\r\n}\r\nfunction _propHashKey(propName, propValue, references) {\r\n    let nextObjectId = 0;\r\n    const objectIds = new Map();\r\n    const replacer = (key, value) => {\r\n        if (value !== null && typeof value === 'object') {\r\n            if (objectIds.has(value)) {\r\n                return objectIds.get(value);\r\n            }\r\n            // Record an id for this object such that any later references use the object's id instead\r\n            // of the object itself, in order to break cyclic pointers in objects.\r\n            objectIds.set(value, `ɵobj#${nextObjectId++}`);\r\n            // The first time an object is seen the object itself is serialized.\r\n            return value;\r\n        }\r\n        else if (typeof value === 'function') {\r\n            value = _serializeReference(value, references);\r\n        }\r\n        return value;\r\n    };\r\n    return `${propName}:${JSON.stringify(propValue, replacer)}`;\r\n}\r\nfunction _serializeReference(ref, references) {\r\n    let id = references.get(ref);\r\n    if (!id) {\r\n        id = `${ɵstringify(ref)}${_nextReferenceId++}`;\r\n        references.set(ref, id);\r\n    }\r\n    return id;\r\n}\r\nfunction _valueProps(obj) {\r\n    const props = [];\r\n    // regular public props\r\n    Object.keys(obj).forEach((prop) => {\r\n        if (!prop.startsWith('_')) {\r\n            props.push(prop);\r\n        }\r\n    });\r\n    // getters\r\n    let proto = obj;\r\n    while ((proto = Object.getPrototypeOf(proto))) {\r\n        Object.keys(proto).forEach((protoProp) => {\r\n            const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\r\n            if (!protoProp.startsWith('_') && desc && 'get' in desc) {\r\n                props.push(protoProp);\r\n            }\r\n        });\r\n    }\r\n    return props;\r\n}\r\n\r\nconst reflection = new ɵReflectionCapabilities();\r\n/**\r\n * Allows to override ivy metadata for tests (via the `TestBed`).\r\n */\r\nclass OverrideResolver {\r\n    constructor() {\r\n        this.overrides = new Map();\r\n        this.resolved = new Map();\r\n    }\r\n    addOverride(type, override) {\r\n        const overrides = this.overrides.get(type) || [];\r\n        overrides.push(override);\r\n        this.overrides.set(type, overrides);\r\n        this.resolved.delete(type);\r\n    }\r\n    setOverrides(overrides) {\r\n        this.overrides.clear();\r\n        overrides.forEach(([type, override]) => {\r\n            this.addOverride(type, override);\r\n        });\r\n    }\r\n    getAnnotation(type) {\r\n        const annotations = reflection.annotations(type);\r\n        // Try to find the nearest known Type annotation and make sure that this annotation is an\r\n        // instance of the type we are looking for, so we can use it for resolution. Note: there might\r\n        // be multiple known annotations found due to the fact that Components can extend Directives (so\r\n        // both Directive and Component annotations would be present), so we always check if the known\r\n        // annotation has the right type.\r\n        for (let i = annotations.length - 1; i >= 0; i--) {\r\n            const annotation = annotations[i];\r\n            const isKnownType = annotation instanceof Directive ||\r\n                annotation instanceof Component ||\r\n                annotation instanceof Pipe ||\r\n                annotation instanceof NgModule;\r\n            if (isKnownType) {\r\n                return annotation instanceof this.type ? annotation : null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    resolve(type) {\r\n        let resolved = this.resolved.get(type) || null;\r\n        if (!resolved) {\r\n            resolved = this.getAnnotation(type);\r\n            if (resolved) {\r\n                const overrides = this.overrides.get(type);\r\n                if (overrides) {\r\n                    const overrider = new MetadataOverrider();\r\n                    overrides.forEach((override) => {\r\n                        resolved = overrider.overrideMetadata(this.type, resolved, override);\r\n                    });\r\n                }\r\n            }\r\n            this.resolved.set(type, resolved);\r\n        }\r\n        return resolved;\r\n    }\r\n}\r\nclass DirectiveResolver extends OverrideResolver {\r\n    get type() {\r\n        return Directive;\r\n    }\r\n}\r\nclass ComponentResolver extends OverrideResolver {\r\n    get type() {\r\n        return Component;\r\n    }\r\n}\r\nclass PipeResolver extends OverrideResolver {\r\n    get type() {\r\n        return Pipe;\r\n    }\r\n}\r\nclass NgModuleResolver extends OverrideResolver {\r\n    get type() {\r\n        return NgModule;\r\n    }\r\n}\r\n\r\nvar TestingModuleOverride;\r\n(function (TestingModuleOverride) {\r\n    TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\r\n    TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\r\n})(TestingModuleOverride || (TestingModuleOverride = {}));\r\nfunction isTestingModuleOverride(value) {\r\n    return (value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE);\r\n}\r\nfunction assertNoStandaloneComponents(types, resolver, location) {\r\n    types.forEach((type) => {\r\n        if (!ɵgetAsyncClassMetadataFn(type)) {\r\n            const component = resolver.resolve(type);\r\n            if (component && component.standalone) {\r\n                throw new Error(ɵgenerateStandaloneInDeclarationsError(type, location));\r\n            }\r\n        }\r\n    });\r\n}\r\nclass TestBedCompiler {\r\n    constructor(platform, additionalModuleTypes) {\r\n        this.platform = platform;\r\n        this.additionalModuleTypes = additionalModuleTypes;\r\n        this.originalComponentResolutionQueue = null;\r\n        // Testing module configuration\r\n        this.declarations = [];\r\n        this.imports = [];\r\n        this.providers = [];\r\n        this.schemas = [];\r\n        // Queues of components/directives/pipes that should be recompiled.\r\n        this.pendingComponents = new Set();\r\n        this.pendingDirectives = new Set();\r\n        this.pendingPipes = new Set();\r\n        // Set of components with async metadata, i.e. components with `@defer` blocks\r\n        // in their templates.\r\n        this.componentsWithAsyncMetadata = new Set();\r\n        // Keep track of all components and directives, so we can patch Providers onto defs later.\r\n        this.seenComponents = new Set();\r\n        this.seenDirectives = new Set();\r\n        // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\r\n        this.overriddenModules = new Set();\r\n        // Store resolved styles for Components that have template overrides present and `styleUrls`\r\n        // defined at the same time.\r\n        this.existingComponentStyles = new Map();\r\n        this.resolvers = initResolvers();\r\n        // Map of component type to an NgModule that declares it.\r\n        //\r\n        // There are a couple special cases:\r\n        // - for standalone components, the module scope value is `null`\r\n        // - when a component is declared in `TestBed.configureTestingModule()` call or\r\n        //   a component's template is overridden via `TestBed.overrideTemplateUsingTestingModule()`.\r\n        //   we use a special value from the `TestingModuleOverride` enum.\r\n        this.componentToModuleScope = new Map();\r\n        // Map that keeps initial version of component/directive/pipe defs in case\r\n        // we compile a Type again, thus overriding respective static fields. This is\r\n        // required to make sure we restore defs to their initial states between test runs.\r\n        // Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of an\r\n        // NgModule), store all of them in a map.\r\n        this.initialNgDefs = new Map();\r\n        // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\r\n        // defs in case TestBed makes changes to the originals.\r\n        this.defCleanupOps = [];\r\n        this._injector = null;\r\n        this.compilerProviders = null;\r\n        this.providerOverrides = [];\r\n        this.rootProviderOverrides = [];\r\n        // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\r\n        // module's provider list.\r\n        this.providerOverridesByModule = new Map();\r\n        this.providerOverridesByToken = new Map();\r\n        this.scopesWithOverriddenProviders = new Set();\r\n        this.testModuleRef = null;\r\n        this.deferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\r\n        class DynamicTestModule {\r\n        }\r\n        this.testModuleType = DynamicTestModule;\r\n    }\r\n    setCompilerProviders(providers) {\r\n        this.compilerProviders = providers;\r\n        this._injector = null;\r\n    }\r\n    configureTestingModule(moduleDef) {\r\n        // Enqueue any compilation tasks for the directly declared component.\r\n        if (moduleDef.declarations !== undefined) {\r\n            // Verify that there are no standalone components\r\n            assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\r\n            this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\r\n            this.declarations.push(...moduleDef.declarations);\r\n        }\r\n        // Enqueue any compilation tasks for imported modules.\r\n        if (moduleDef.imports !== undefined) {\r\n            this.queueTypesFromModulesArray(moduleDef.imports);\r\n            this.imports.push(...moduleDef.imports);\r\n        }\r\n        if (moduleDef.providers !== undefined) {\r\n            this.providers.push(...moduleDef.providers);\r\n        }\r\n        if (moduleDef.schemas !== undefined) {\r\n            this.schemas.push(...moduleDef.schemas);\r\n        }\r\n        this.deferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\r\n    }\r\n    overrideModule(ngModule, override) {\r\n        if (ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\r\n            ɵdepsTracker.clearScopeCacheFor(ngModule);\r\n        }\r\n        this.overriddenModules.add(ngModule);\r\n        // Compile the module right away.\r\n        this.resolvers.module.addOverride(ngModule, override);\r\n        const metadata = this.resolvers.module.resolve(ngModule);\r\n        if (metadata === null) {\r\n            throw invalidTypeError(ngModule.name, 'NgModule');\r\n        }\r\n        this.recompileNgModule(ngModule, metadata);\r\n        // At this point, the module has a valid module def (ɵmod), but the override may have introduced\r\n        // new declarations or imported modules. Ingest any possible new types and add them to the\r\n        // current queue.\r\n        this.queueTypesFromModulesArray([ngModule]);\r\n    }\r\n    overrideComponent(component, override) {\r\n        this.verifyNoStandaloneFlagOverrides(component, override);\r\n        this.resolvers.component.addOverride(component, override);\r\n        this.pendingComponents.add(component);\r\n        // If this is a component with async metadata (i.e. a component with a `@defer` block\r\n        // in a template) - store it for future processing.\r\n        this.maybeRegisterComponentWithAsyncMetadata(component);\r\n    }\r\n    overrideDirective(directive, override) {\r\n        this.verifyNoStandaloneFlagOverrides(directive, override);\r\n        this.resolvers.directive.addOverride(directive, override);\r\n        this.pendingDirectives.add(directive);\r\n    }\r\n    overridePipe(pipe, override) {\r\n        this.verifyNoStandaloneFlagOverrides(pipe, override);\r\n        this.resolvers.pipe.addOverride(pipe, override);\r\n        this.pendingPipes.add(pipe);\r\n    }\r\n    verifyNoStandaloneFlagOverrides(type, override) {\r\n        if (override.add?.hasOwnProperty('standalone') ||\r\n            override.set?.hasOwnProperty('standalone') ||\r\n            override.remove?.hasOwnProperty('standalone')) {\r\n            throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` +\r\n                `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\r\n        }\r\n    }\r\n    overrideProvider(token, provider) {\r\n        let providerDef;\r\n        if (provider.useFactory !== undefined) {\r\n            providerDef = {\r\n                provide: token,\r\n                useFactory: provider.useFactory,\r\n                deps: provider.deps || [],\r\n                multi: provider.multi,\r\n            };\r\n        }\r\n        else if (provider.useValue !== undefined) {\r\n            providerDef = { provide: token, useValue: provider.useValue, multi: provider.multi };\r\n        }\r\n        else {\r\n            providerDef = { provide: token };\r\n        }\r\n        const injectableDef = typeof token !== 'string' ? ɵgetInjectableDef(token) : null;\r\n        const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\r\n        const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\r\n        overridesBucket.push(providerDef);\r\n        // Keep overrides grouped by token as well for fast lookups using token\r\n        this.providerOverridesByToken.set(token, providerDef);\r\n        if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\r\n            const existingOverrides = this.providerOverridesByModule.get(providedIn);\r\n            if (existingOverrides !== undefined) {\r\n                existingOverrides.push(providerDef);\r\n            }\r\n            else {\r\n                this.providerOverridesByModule.set(providedIn, [providerDef]);\r\n            }\r\n        }\r\n    }\r\n    overrideTemplateUsingTestingModule(type, template) {\r\n        const def = type[ɵNG_COMP_DEF];\r\n        const hasStyleUrls = () => {\r\n            const metadata = this.resolvers.component.resolve(type);\r\n            return !!metadata.styleUrl || !!metadata.styleUrls?.length;\r\n        };\r\n        const overrideStyleUrls = !!def && !ɵisComponentDefPendingResolution(type) && hasStyleUrls();\r\n        // In Ivy, compiling a component does not require knowing the module providing the\r\n        // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\r\n        // overrideComponent. Important: overriding template requires full Component re-compilation,\r\n        // which may fail in case styleUrls are also present (thus Component is considered as required\r\n        // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\r\n        // preserve current styles available on Component def and restore styles back once compilation\r\n        // is complete.\r\n        const override = overrideStyleUrls\r\n            ? { template, styles: [], styleUrls: [], styleUrl: undefined }\r\n            : { template };\r\n        this.overrideComponent(type, { set: override });\r\n        if (overrideStyleUrls && def.styles && def.styles.length > 0) {\r\n            this.existingComponentStyles.set(type, def.styles);\r\n        }\r\n        // Set the component's scope to be the testing module.\r\n        this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\r\n    }\r\n    async resolvePendingComponentsWithAsyncMetadata() {\r\n        if (this.componentsWithAsyncMetadata.size === 0)\r\n            return;\r\n        const promises = [];\r\n        for (const component of this.componentsWithAsyncMetadata) {\r\n            const asyncMetadataFn = ɵgetAsyncClassMetadataFn(component);\r\n            if (asyncMetadataFn) {\r\n                promises.push(asyncMetadataFn());\r\n            }\r\n        }\r\n        this.componentsWithAsyncMetadata.clear();\r\n        const resolvedDeps = await Promise.all(promises);\r\n        const flatResolvedDeps = resolvedDeps.flat(2);\r\n        this.queueTypesFromModulesArray(flatResolvedDeps);\r\n        // Loaded standalone components might contain imports of NgModules\r\n        // with providers, make sure we override providers there too.\r\n        for (const component of flatResolvedDeps) {\r\n            this.applyProviderOverridesInScope(component);\r\n        }\r\n    }\r\n    async compileComponents() {\r\n        this.clearComponentResolutionQueue();\r\n        // Wait for all async metadata for components that were\r\n        // overridden, we need resolved metadata to perform an override\r\n        // and re-compile a component.\r\n        await this.resolvePendingComponentsWithAsyncMetadata();\r\n        // Verify that there were no standalone components present in the `declarations` field\r\n        // during the `TestBed.configureTestingModule` call. We perform this check here in addition\r\n        // to the logic in the `configureTestingModule` function, since at this point we have\r\n        // all async metadata resolved.\r\n        assertNoStandaloneComponents(this.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\r\n        // Run compilers for all queued types.\r\n        let needsAsyncResources = this.compileTypesSync();\r\n        // compileComponents() should not be async unless it needs to be.\r\n        if (needsAsyncResources) {\r\n            let resourceLoader;\r\n            let resolver = (url) => {\r\n                if (!resourceLoader) {\r\n                    resourceLoader = this.injector.get(ResourceLoader);\r\n                }\r\n                return Promise.resolve(resourceLoader.get(url));\r\n            };\r\n            await ɵresolveComponentResources(resolver);\r\n        }\r\n    }\r\n    finalize() {\r\n        // One last compile\r\n        this.compileTypesSync();\r\n        // Create the testing module itself.\r\n        this.compileTestModule();\r\n        this.applyTransitiveScopes();\r\n        this.applyProviderOverrides();\r\n        // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\r\n        // Components have `styleUrls` fields defined and template override was requested.\r\n        this.patchComponentsWithExistingStyles();\r\n        // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\r\n        // every component.\r\n        this.componentToModuleScope.clear();\r\n        const parentInjector = this.platform.injector;\r\n        this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector, []);\r\n        // ApplicationInitStatus.runInitializers() is marked @internal to core.\r\n        // Cast it to any before accessing it.\r\n        this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\r\n        // Set locale ID after running app initializers, since locale information might be updated while\r\n        // running initializers. This is also consistent with the execution order while bootstrapping an\r\n        // app (see `packages/core/src/application_ref.ts` file).\r\n        const localeId = this.testModuleRef.injector.get(LOCALE_ID, ɵDEFAULT_LOCALE_ID);\r\n        ɵsetLocaleId(localeId);\r\n        return this.testModuleRef;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _compileNgModuleSync(moduleType) {\r\n        this.queueTypesFromModulesArray([moduleType]);\r\n        this.compileTypesSync();\r\n        this.applyProviderOverrides();\r\n        this.applyProviderOverridesInScope(moduleType);\r\n        this.applyTransitiveScopes();\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    async _compileNgModuleAsync(moduleType) {\r\n        this.queueTypesFromModulesArray([moduleType]);\r\n        await this.compileComponents();\r\n        this.applyProviderOverrides();\r\n        this.applyProviderOverridesInScope(moduleType);\r\n        this.applyTransitiveScopes();\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _getModuleResolver() {\r\n        return this.resolvers.module;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _getComponentFactories(moduleType) {\r\n        return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\r\n            const componentDef = declaration.ɵcmp;\r\n            componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, this.testModuleRef));\r\n            return factories;\r\n        }, []);\r\n    }\r\n    compileTypesSync() {\r\n        // Compile all queued components, directives, pipes.\r\n        let needsAsyncResources = false;\r\n        this.pendingComponents.forEach((declaration) => {\r\n            if (ɵgetAsyncClassMetadataFn(declaration)) {\r\n                throw new Error(`Component '${declaration.name}' has unresolved metadata. ` +\r\n                    `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\r\n            }\r\n            needsAsyncResources = needsAsyncResources || ɵisComponentDefPendingResolution(declaration);\r\n            const metadata = this.resolvers.component.resolve(declaration);\r\n            if (metadata === null) {\r\n                throw invalidTypeError(declaration.name, 'Component');\r\n            }\r\n            this.maybeStoreNgDef(ɵNG_COMP_DEF, declaration);\r\n            if (ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\r\n                ɵdepsTracker.clearScopeCacheFor(declaration);\r\n            }\r\n            ɵcompileComponent(declaration, metadata);\r\n        });\r\n        this.pendingComponents.clear();\r\n        this.pendingDirectives.forEach((declaration) => {\r\n            const metadata = this.resolvers.directive.resolve(declaration);\r\n            if (metadata === null) {\r\n                throw invalidTypeError(declaration.name, 'Directive');\r\n            }\r\n            this.maybeStoreNgDef(ɵNG_DIR_DEF, declaration);\r\n            ɵcompileDirective(declaration, metadata);\r\n        });\r\n        this.pendingDirectives.clear();\r\n        this.pendingPipes.forEach((declaration) => {\r\n            const metadata = this.resolvers.pipe.resolve(declaration);\r\n            if (metadata === null) {\r\n                throw invalidTypeError(declaration.name, 'Pipe');\r\n            }\r\n            this.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\r\n            ɵcompilePipe(declaration, metadata);\r\n        });\r\n        this.pendingPipes.clear();\r\n        return needsAsyncResources;\r\n    }\r\n    applyTransitiveScopes() {\r\n        if (this.overriddenModules.size > 0) {\r\n            // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\r\n            // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\r\n            // collect all affected modules and reset scopes to force their re-calculation.\r\n            const testingModuleDef = this.testModuleType[ɵNG_MOD_DEF];\r\n            const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\r\n            if (affectedModules.size > 0) {\r\n                affectedModules.forEach((moduleType) => {\r\n                    if (!ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\r\n                        this.storeFieldOfDefOnType(moduleType, ɵNG_MOD_DEF, 'transitiveCompileScopes');\r\n                        moduleType[ɵNG_MOD_DEF].transitiveCompileScopes = null;\r\n                    }\r\n                    else {\r\n                        ɵdepsTracker.clearScopeCacheFor(moduleType);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        const moduleToScope = new Map();\r\n        const getScopeOfModule = (moduleType) => {\r\n            if (!moduleToScope.has(moduleType)) {\r\n                const isTestingModule = isTestingModuleOverride(moduleType);\r\n                const realType = isTestingModule ? this.testModuleType : moduleType;\r\n                moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\r\n            }\r\n            return moduleToScope.get(moduleType);\r\n        };\r\n        this.componentToModuleScope.forEach((moduleType, componentType) => {\r\n            if (moduleType !== null) {\r\n                const moduleScope = getScopeOfModule(moduleType);\r\n                this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'directiveDefs');\r\n                this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'pipeDefs');\r\n                ɵpatchComponentDefWithScope(getComponentDef(componentType), moduleScope);\r\n            }\r\n            // `tView` that is stored on component def contains information about directives and pipes\r\n            // that are in the scope of this component. Patching component scope will cause `tView` to be\r\n            // changed. Store original `tView` before patching scope, so the `tView` (including scope\r\n            // information) is restored back to its previous/original state before running next test.\r\n            // Resetting `tView` is also needed for cases when we apply provider overrides and those\r\n            // providers are defined on component's level, in which case they may end up included into\r\n            // `tView.blueprint`.\r\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'tView');\r\n        });\r\n        this.componentToModuleScope.clear();\r\n    }\r\n    applyProviderOverrides() {\r\n        const maybeApplyOverrides = (field) => (type) => {\r\n            const resolver = field === ɵNG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\r\n            const metadata = resolver.resolve(type);\r\n            if (this.hasProviderOverrides(metadata.providers)) {\r\n                this.patchDefWithProviderOverrides(type, field);\r\n            }\r\n        };\r\n        this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMP_DEF));\r\n        this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIR_DEF));\r\n        this.seenComponents.clear();\r\n        this.seenDirectives.clear();\r\n    }\r\n    /**\r\n     * Applies provider overrides to a given type (either an NgModule or a standalone component)\r\n     * and all imported NgModules and standalone components recursively.\r\n     */\r\n    applyProviderOverridesInScope(type) {\r\n        const hasScope = isStandaloneComponent(type) || isNgModule(type);\r\n        // The function can be re-entered recursively while inspecting dependencies\r\n        // of an NgModule or a standalone component. Exit early if we come across a\r\n        // type that can not have a scope (directive or pipe) or the type is already\r\n        // processed earlier.\r\n        if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\r\n            return;\r\n        }\r\n        this.scopesWithOverriddenProviders.add(type);\r\n        // NOTE: the line below triggers JIT compilation of the module injector,\r\n        // which also invokes verification of the NgModule semantics, which produces\r\n        // detailed error messages. The fact that the code relies on this line being\r\n        // present here is suspicious and should be refactored in a way that the line\r\n        // below can be moved (for ex. after an early exit check below).\r\n        const injectorDef = type[ɵNG_INJ_DEF];\r\n        // No provider overrides, exit early.\r\n        if (this.providerOverridesByToken.size === 0)\r\n            return;\r\n        if (isStandaloneComponent(type)) {\r\n            // Visit all component dependencies and override providers there.\r\n            const def = getComponentDef(type);\r\n            const dependencies = maybeUnwrapFn(def.dependencies ?? []);\r\n            for (const dependency of dependencies) {\r\n                this.applyProviderOverridesInScope(dependency);\r\n            }\r\n        }\r\n        else {\r\n            const providers = [\r\n                ...injectorDef.providers,\r\n                ...(this.providerOverridesByModule.get(type) || []),\r\n            ];\r\n            if (this.hasProviderOverrides(providers)) {\r\n                this.maybeStoreNgDef(ɵNG_INJ_DEF, type);\r\n                this.storeFieldOfDefOnType(type, ɵNG_INJ_DEF, 'providers');\r\n                injectorDef.providers = this.getOverriddenProviders(providers);\r\n            }\r\n            // Apply provider overrides to imported modules recursively\r\n            const moduleDef = type[ɵNG_MOD_DEF];\r\n            const imports = maybeUnwrapFn(moduleDef.imports);\r\n            for (const importedModule of imports) {\r\n                this.applyProviderOverridesInScope(importedModule);\r\n            }\r\n            // Also override the providers on any ModuleWithProviders imports since those don't appear in\r\n            // the moduleDef.\r\n            for (const importedModule of flatten(injectorDef.imports)) {\r\n                if (isModuleWithProviders(importedModule)) {\r\n                    this.defCleanupOps.push({\r\n                        object: importedModule,\r\n                        fieldName: 'providers',\r\n                        originalValue: importedModule.providers,\r\n                    });\r\n                    importedModule.providers = this.getOverriddenProviders(importedModule.providers);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    patchComponentsWithExistingStyles() {\r\n        this.existingComponentStyles.forEach((styles, type) => (type[ɵNG_COMP_DEF].styles = styles));\r\n        this.existingComponentStyles.clear();\r\n    }\r\n    queueTypeArray(arr, moduleType) {\r\n        for (const value of arr) {\r\n            if (Array.isArray(value)) {\r\n                this.queueTypeArray(value, moduleType);\r\n            }\r\n            else {\r\n                this.queueType(value, moduleType);\r\n            }\r\n        }\r\n    }\r\n    recompileNgModule(ngModule, metadata) {\r\n        // Cache the initial ngModuleDef as it will be overwritten.\r\n        this.maybeStoreNgDef(ɵNG_MOD_DEF, ngModule);\r\n        this.maybeStoreNgDef(ɵNG_INJ_DEF, ngModule);\r\n        ɵcompileNgModuleDefs(ngModule, metadata);\r\n    }\r\n    maybeRegisterComponentWithAsyncMetadata(type) {\r\n        const asyncMetadataFn = ɵgetAsyncClassMetadataFn(type);\r\n        if (asyncMetadataFn) {\r\n            this.componentsWithAsyncMetadata.add(type);\r\n        }\r\n    }\r\n    queueType(type, moduleType) {\r\n        // If this is a component with async metadata (i.e. a component with a `@defer` block\r\n        // in a template) - store it for future processing.\r\n        this.maybeRegisterComponentWithAsyncMetadata(type);\r\n        const component = this.resolvers.component.resolve(type);\r\n        if (component) {\r\n            // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\r\n            // missing. That might happen in case a class without any Angular decorators extends another\r\n            // class where Component/Directive/Pipe decorator is defined.\r\n            if (ɵisComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMP_DEF)) {\r\n                this.pendingComponents.add(type);\r\n            }\r\n            this.seenComponents.add(type);\r\n            // Keep track of the module which declares this component, so later the component's scope\r\n            // can be set correctly. If the component has already been recorded here, then one of several\r\n            // cases is true:\r\n            // * the module containing the component was imported multiple times (common).\r\n            // * the component is declared in multiple modules (which is an error).\r\n            // * the component was in 'declarations' of the testing module, and also in an imported module\r\n            //   in which case the module scope will be TestingModuleOverride.DECLARATION.\r\n            // * overrideTemplateUsingTestingModule was called for the component in which case the module\r\n            //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\r\n            //\r\n            // If the component was previously in the testing module's 'declarations' (meaning the\r\n            // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\r\n            // real module, which was imported. This pattern is understood to mean that the component\r\n            // should use its original scope, but that the testing module should also contain the\r\n            // component in its scope.\r\n            if (!this.componentToModuleScope.has(type) ||\r\n                this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\r\n                this.componentToModuleScope.set(type, moduleType);\r\n            }\r\n            return;\r\n        }\r\n        const directive = this.resolvers.directive.resolve(type);\r\n        if (directive) {\r\n            if (!type.hasOwnProperty(ɵNG_DIR_DEF)) {\r\n                this.pendingDirectives.add(type);\r\n            }\r\n            this.seenDirectives.add(type);\r\n            return;\r\n        }\r\n        const pipe = this.resolvers.pipe.resolve(type);\r\n        if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\r\n            this.pendingPipes.add(type);\r\n            return;\r\n        }\r\n    }\r\n    queueTypesFromModulesArray(arr) {\r\n        // Because we may encounter the same NgModule or a standalone Component while processing\r\n        // the dependencies of an NgModule or a standalone Component, we cache them in this set so we\r\n        // can skip ones that have already been seen encountered. In some test setups, this caching\r\n        // resulted in 10X runtime improvement.\r\n        const processedDefs = new Set();\r\n        const queueTypesFromModulesArrayRecur = (arr) => {\r\n            for (const value of arr) {\r\n                if (Array.isArray(value)) {\r\n                    queueTypesFromModulesArrayRecur(value);\r\n                }\r\n                else if (hasNgModuleDef(value)) {\r\n                    const def = value.ɵmod;\r\n                    if (processedDefs.has(def)) {\r\n                        continue;\r\n                    }\r\n                    processedDefs.add(def);\r\n                    // Look through declarations, imports, and exports, and queue\r\n                    // everything found there.\r\n                    this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\r\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\r\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\r\n                }\r\n                else if (isModuleWithProviders(value)) {\r\n                    queueTypesFromModulesArrayRecur([value.ngModule]);\r\n                }\r\n                else if (isStandaloneComponent(value)) {\r\n                    this.queueType(value, null);\r\n                    const def = getComponentDef(value);\r\n                    if (processedDefs.has(def)) {\r\n                        continue;\r\n                    }\r\n                    processedDefs.add(def);\r\n                    const dependencies = maybeUnwrapFn(def.dependencies ?? []);\r\n                    dependencies.forEach((dependency) => {\r\n                        // Note: in AOT, the `dependencies` might also contain regular\r\n                        // (NgModule-based) Component, Directive and Pipes, so we handle\r\n                        // them separately and proceed with recursive process for standalone\r\n                        // Components and NgModules only.\r\n                        if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\r\n                            queueTypesFromModulesArrayRecur([dependency]);\r\n                        }\r\n                        else {\r\n                            this.queueType(dependency, null);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n        queueTypesFromModulesArrayRecur(arr);\r\n    }\r\n    // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\r\n    // that import (even transitively) an overridden one. For all affected modules we need to\r\n    // recalculate their scopes for a given test run and restore original scopes at the end. The goal\r\n    // of this function is to collect all affected modules in a set for further processing. Example:\r\n    // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\r\n    // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\r\n    // invalidated with the override.\r\n    collectModulesAffectedByOverrides(arr) {\r\n        const seenModules = new Set();\r\n        const affectedModules = new Set();\r\n        const calcAffectedModulesRecur = (arr, path) => {\r\n            for (const value of arr) {\r\n                if (Array.isArray(value)) {\r\n                    // If the value is an array, just flatten it (by invoking this function recursively),\r\n                    // keeping \"path\" the same.\r\n                    calcAffectedModulesRecur(value, path);\r\n                }\r\n                else if (hasNgModuleDef(value)) {\r\n                    if (seenModules.has(value)) {\r\n                        // If we've seen this module before and it's included into \"affected modules\" list, mark\r\n                        // the whole path that leads to that module as affected, but do not descend into its\r\n                        // imports, since we already examined them before.\r\n                        if (affectedModules.has(value)) {\r\n                            path.forEach((item) => affectedModules.add(item));\r\n                        }\r\n                        continue;\r\n                    }\r\n                    seenModules.add(value);\r\n                    if (this.overriddenModules.has(value)) {\r\n                        path.forEach((item) => affectedModules.add(item));\r\n                    }\r\n                    // Examine module imports recursively to look for overridden modules.\r\n                    const moduleDef = value[ɵNG_MOD_DEF];\r\n                    calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\r\n                }\r\n            }\r\n        };\r\n        calcAffectedModulesRecur(arr, []);\r\n        return affectedModules;\r\n    }\r\n    /**\r\n     * Preserve an original def (such as ɵmod, ɵinj, etc) before applying an override.\r\n     * Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of\r\n     * an NgModule). If there is a def in a set already, don't override it, since\r\n     * an original one should be restored at the end of a test.\r\n     */\r\n    maybeStoreNgDef(prop, type) {\r\n        if (!this.initialNgDefs.has(type)) {\r\n            this.initialNgDefs.set(type, new Map());\r\n        }\r\n        const currentDefs = this.initialNgDefs.get(type);\r\n        if (!currentDefs.has(prop)) {\r\n            const currentDef = Object.getOwnPropertyDescriptor(type, prop);\r\n            currentDefs.set(prop, currentDef);\r\n        }\r\n    }\r\n    storeFieldOfDefOnType(type, defField, fieldName) {\r\n        const def = type[defField];\r\n        const originalValue = def[fieldName];\r\n        this.defCleanupOps.push({ object: def, fieldName, originalValue });\r\n    }\r\n    /**\r\n     * Clears current components resolution queue, but stores the state of the queue, so we can\r\n     * restore it later. Clearing the queue is required before we try to compile components (via\r\n     * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\r\n     */\r\n    clearComponentResolutionQueue() {\r\n        if (this.originalComponentResolutionQueue === null) {\r\n            this.originalComponentResolutionQueue = new Map();\r\n        }\r\n        ɵclearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\r\n    }\r\n    /*\r\n     * Restores component resolution queue to the previously saved state. This operation is performed\r\n     * as a part of restoring the state after completion of the current set of tests (that might\r\n     * potentially mutate the state).\r\n     */\r\n    restoreComponentResolutionQueue() {\r\n        if (this.originalComponentResolutionQueue !== null) {\r\n            ɵrestoreComponentResolutionQueue(this.originalComponentResolutionQueue);\r\n            this.originalComponentResolutionQueue = null;\r\n        }\r\n    }\r\n    restoreOriginalState() {\r\n        // Process cleanup ops in reverse order so the field's original value is restored correctly (in\r\n        // case there were multiple overrides for the same field).\r\n        forEachRight(this.defCleanupOps, (op) => {\r\n            op.object[op.fieldName] = op.originalValue;\r\n        });\r\n        // Restore initial component/directive/pipe defs\r\n        this.initialNgDefs.forEach((defs, type) => {\r\n            if (ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\r\n                ɵdepsTracker.clearScopeCacheFor(type);\r\n            }\r\n            defs.forEach((descriptor, prop) => {\r\n                if (!descriptor) {\r\n                    // Delete operations are generally undesirable since they have performance\r\n                    // implications on objects they were applied to. In this particular case, situations\r\n                    // where this code is invoked should be quite rare to cause any noticeable impact,\r\n                    // since it's applied only to some test cases (for example when class with no\r\n                    // annotations extends some @Component) when we need to clear 'ɵcmp' field on a given\r\n                    // class to restore its original state (before applying overrides and running tests).\r\n                    delete type[prop];\r\n                }\r\n                else {\r\n                    Object.defineProperty(type, prop, descriptor);\r\n                }\r\n            });\r\n        });\r\n        this.initialNgDefs.clear();\r\n        this.scopesWithOverriddenProviders.clear();\r\n        this.restoreComponentResolutionQueue();\r\n        // Restore the locale ID to the default value, this shouldn't be necessary but we never know\r\n        ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\r\n    }\r\n    compileTestModule() {\r\n        class RootScopeModule {\r\n        }\r\n        ɵcompileNgModuleDefs(RootScopeModule, {\r\n            providers: [\r\n                ...this.rootProviderOverrides,\r\n                ɵinternalProvideZoneChangeDetection({}),\r\n                { provide: ɵChangeDetectionScheduler, useExisting: ɵChangeDetectionSchedulerImpl },\r\n            ],\r\n        });\r\n        const providers = [\r\n            { provide: Compiler, useFactory: () => new R3TestCompiler(this) },\r\n            { provide: ɵDEFER_BLOCK_CONFIG, useValue: { behavior: this.deferBlockBehavior } },\r\n            ...this.providers,\r\n            ...this.providerOverrides,\r\n        ];\r\n        const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\r\n        ɵcompileNgModuleDefs(this.testModuleType, {\r\n            declarations: this.declarations,\r\n            imports,\r\n            schemas: this.schemas,\r\n            providers,\r\n        }, \r\n        /* allowDuplicateDeclarationsInRoot */ true);\r\n        this.applyProviderOverridesInScope(this.testModuleType);\r\n    }\r\n    get injector() {\r\n        if (this._injector !== null) {\r\n            return this._injector;\r\n        }\r\n        const providers = [];\r\n        const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\r\n        compilerOptions.forEach((opts) => {\r\n            if (opts.providers) {\r\n                providers.push(opts.providers);\r\n            }\r\n        });\r\n        if (this.compilerProviders !== null) {\r\n            providers.push(...this.compilerProviders);\r\n        }\r\n        this._injector = Injector.create({ providers, parent: this.platform.injector });\r\n        return this._injector;\r\n    }\r\n    // get overrides for a specific provider (if any)\r\n    getSingleProviderOverrides(provider) {\r\n        const token = getProviderToken(provider);\r\n        return this.providerOverridesByToken.get(token) || null;\r\n    }\r\n    getProviderOverrides(providers) {\r\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\r\n            return [];\r\n        // There are two flattening operations here. The inner flattenProviders() operates on the\r\n        // metadata's providers and applies a mapping function which retrieves overrides for each\r\n        // incoming provider. The outer flatten() then flattens the produced overrides array. If this is\r\n        // not done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\r\n        // providers array and contaminate any error messages that might be generated.\r\n        return flatten(flattenProviders(providers, (provider) => this.getSingleProviderOverrides(provider) || []));\r\n    }\r\n    getOverriddenProviders(providers) {\r\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\r\n            return [];\r\n        const flattenedProviders = flattenProviders(providers);\r\n        const overrides = this.getProviderOverrides(flattenedProviders);\r\n        const overriddenProviders = [...flattenedProviders, ...overrides];\r\n        const final = [];\r\n        const seenOverriddenProviders = new Set();\r\n        // We iterate through the list of providers in reverse order to make sure provider overrides\r\n        // take precedence over the values defined in provider list. We also filter out all providers\r\n        // that have overrides, keeping overridden values only. This is needed, since presence of a\r\n        // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\r\n        forEachRight(overriddenProviders, (provider) => {\r\n            const token = getProviderToken(provider);\r\n            if (this.providerOverridesByToken.has(token)) {\r\n                if (!seenOverriddenProviders.has(token)) {\r\n                    seenOverriddenProviders.add(token);\r\n                    // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\r\n                    // make sure that provided override takes highest precedence and is not combined with\r\n                    // other instances of the same multi provider.\r\n                    final.unshift({ ...provider, multi: false });\r\n                }\r\n            }\r\n            else {\r\n                final.unshift(provider);\r\n            }\r\n        });\r\n        return final;\r\n    }\r\n    hasProviderOverrides(providers) {\r\n        return this.getProviderOverrides(providers).length > 0;\r\n    }\r\n    patchDefWithProviderOverrides(declaration, field) {\r\n        const def = declaration[field];\r\n        if (def && def.providersResolver) {\r\n            this.maybeStoreNgDef(field, declaration);\r\n            const resolver = def.providersResolver;\r\n            const processProvidersFn = (providers) => this.getOverriddenProviders(providers);\r\n            this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\r\n            def.providersResolver = (ngDef) => resolver(ngDef, processProvidersFn);\r\n        }\r\n    }\r\n}\r\nfunction initResolvers() {\r\n    return {\r\n        module: new NgModuleResolver(),\r\n        component: new ComponentResolver(),\r\n        directive: new DirectiveResolver(),\r\n        pipe: new PipeResolver(),\r\n    };\r\n}\r\nfunction isStandaloneComponent(value) {\r\n    const def = getComponentDef(value);\r\n    return !!def?.standalone;\r\n}\r\nfunction getComponentDef(value) {\r\n    return value.ɵcmp ?? null;\r\n}\r\nfunction hasNgModuleDef(value) {\r\n    return value.hasOwnProperty('ɵmod');\r\n}\r\nfunction isNgModule(value) {\r\n    return hasNgModuleDef(value);\r\n}\r\nfunction maybeUnwrapFn(maybeFn) {\r\n    return maybeFn instanceof Function ? maybeFn() : maybeFn;\r\n}\r\nfunction flatten(values) {\r\n    const out = [];\r\n    values.forEach((value) => {\r\n        if (Array.isArray(value)) {\r\n            out.push(...flatten(value));\r\n        }\r\n        else {\r\n            out.push(value);\r\n        }\r\n    });\r\n    return out;\r\n}\r\nfunction identityFn(value) {\r\n    return value;\r\n}\r\nfunction flattenProviders(providers, mapFn = identityFn) {\r\n    const out = [];\r\n    for (let provider of providers) {\r\n        if (ɵisEnvironmentProviders(provider)) {\r\n            provider = provider.ɵproviders;\r\n        }\r\n        if (Array.isArray(provider)) {\r\n            out.push(...flattenProviders(provider, mapFn));\r\n        }\r\n        else {\r\n            out.push(mapFn(provider));\r\n        }\r\n    }\r\n    return out;\r\n}\r\nfunction getProviderField(provider, field) {\r\n    return provider && typeof provider === 'object' && provider[field];\r\n}\r\nfunction getProviderToken(provider) {\r\n    return getProviderField(provider, 'provide') || provider;\r\n}\r\nfunction isModuleWithProviders(value) {\r\n    return value.hasOwnProperty('ngModule');\r\n}\r\nfunction forEachRight(values, fn) {\r\n    for (let idx = values.length - 1; idx >= 0; idx--) {\r\n        fn(values[idx], idx);\r\n    }\r\n}\r\nfunction invalidTypeError(name, expectedType) {\r\n    return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\r\n}\r\nclass R3TestCompiler {\r\n    constructor(testBed) {\r\n        this.testBed = testBed;\r\n    }\r\n    compileModuleSync(moduleType) {\r\n        this.testBed._compileNgModuleSync(moduleType);\r\n        return new ɵNgModuleFactory(moduleType);\r\n    }\r\n    async compileModuleAsync(moduleType) {\r\n        await this.testBed._compileNgModuleAsync(moduleType);\r\n        return new ɵNgModuleFactory(moduleType);\r\n    }\r\n    compileModuleAndAllComponentsSync(moduleType) {\r\n        const ngModuleFactory = this.compileModuleSync(moduleType);\r\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\r\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\r\n    }\r\n    async compileModuleAndAllComponentsAsync(moduleType) {\r\n        const ngModuleFactory = await this.compileModuleAsync(moduleType);\r\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\r\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\r\n    }\r\n    clearCache() { }\r\n    clearCacheFor(type) { }\r\n    getModuleId(moduleType) {\r\n        const meta = this.testBed._getModuleResolver().resolve(moduleType);\r\n        return (meta && meta.id) || undefined;\r\n    }\r\n}\r\n\r\n// The formatter and CI disagree on how this import statement should be formatted. Both try to keep\r\nlet _nextRootElementId = 0;\r\n/**\r\n * Returns a singleton of the `TestBed` class.\r\n *\r\n * @publicApi\r\n */\r\nfunction getTestBed() {\r\n    return TestBedImpl.INSTANCE;\r\n}\r\n/**\r\n * @description\r\n * Configures and initializes environment for unit testing and provides methods for\r\n * creating components and services in unit tests.\r\n *\r\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\r\n */\r\nclass TestBedImpl {\r\n    constructor() {\r\n        /**\r\n         * Defer block behavior option that specifies whether defer blocks will be triggered manually\r\n         * or set to play through.\r\n         */\r\n        this._instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\r\n        // Properties\r\n        this.platform = null;\r\n        this.ngModule = null;\r\n        this._compiler = null;\r\n        this._testModuleRef = null;\r\n        this._activeFixtures = [];\r\n        /**\r\n         * Internal-only flag to indicate whether a module\r\n         * scoping queue has been checked and flushed already.\r\n         * @nodoc\r\n         */\r\n        this.globalCompilationChecked = false;\r\n    }\r\n    static { this._INSTANCE = null; }\r\n    static get INSTANCE() {\r\n        return (TestBedImpl._INSTANCE = TestBedImpl._INSTANCE || new TestBedImpl());\r\n    }\r\n    /**\r\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n     * angular module. These are common to every test in the suite.\r\n     *\r\n     * This may only be called once, to set up the common providers for the current test\r\n     * suite on the current platform. If you absolutely need to change the providers,\r\n     * first use `resetTestEnvironment`.\r\n     *\r\n     * Test modules and platforms for individual platforms are available from\r\n     * '@angular/<platform_name>/testing'.\r\n     *\r\n     * @publicApi\r\n     */\r\n    static initTestEnvironment(ngModule, platform, options) {\r\n        const testBed = TestBedImpl.INSTANCE;\r\n        testBed.initTestEnvironment(ngModule, platform, options);\r\n        return testBed;\r\n    }\r\n    /**\r\n     * Reset the providers for the test injector.\r\n     *\r\n     * @publicApi\r\n     */\r\n    static resetTestEnvironment() {\r\n        TestBedImpl.INSTANCE.resetTestEnvironment();\r\n    }\r\n    static configureCompiler(config) {\r\n        return TestBedImpl.INSTANCE.configureCompiler(config);\r\n    }\r\n    /**\r\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\r\n     * which are defined in test_injector.js\r\n     */\r\n    static configureTestingModule(moduleDef) {\r\n        return TestBedImpl.INSTANCE.configureTestingModule(moduleDef);\r\n    }\r\n    /**\r\n     * Compile components with a `templateUrl` for the test's NgModule.\r\n     * It is necessary to call this function\r\n     * as fetching urls is asynchronous.\r\n     */\r\n    static compileComponents() {\r\n        return TestBedImpl.INSTANCE.compileComponents();\r\n    }\r\n    static overrideModule(ngModule, override) {\r\n        return TestBedImpl.INSTANCE.overrideModule(ngModule, override);\r\n    }\r\n    static overrideComponent(component, override) {\r\n        return TestBedImpl.INSTANCE.overrideComponent(component, override);\r\n    }\r\n    static overrideDirective(directive, override) {\r\n        return TestBedImpl.INSTANCE.overrideDirective(directive, override);\r\n    }\r\n    static overridePipe(pipe, override) {\r\n        return TestBedImpl.INSTANCE.overridePipe(pipe, override);\r\n    }\r\n    static overrideTemplate(component, template) {\r\n        return TestBedImpl.INSTANCE.overrideTemplate(component, template);\r\n    }\r\n    /**\r\n     * Overrides the template of the given component, compiling the template\r\n     * in the context of the TestingModule.\r\n     *\r\n     * Note: This works for JIT and AOTed components as well.\r\n     */\r\n    static overrideTemplateUsingTestingModule(component, template) {\r\n        return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component, template);\r\n    }\r\n    static overrideProvider(token, provider) {\r\n        return TestBedImpl.INSTANCE.overrideProvider(token, provider);\r\n    }\r\n    static inject(token, notFoundValue, flags) {\r\n        return TestBedImpl.INSTANCE.inject(token, notFoundValue, ɵconvertToBitFlags(flags));\r\n    }\r\n    /** @deprecated from v9.0.0 use TestBed.inject */\r\n    static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\r\n        return TestBedImpl.INSTANCE.inject(token, notFoundValue, flags);\r\n    }\r\n    /**\r\n     * Runs the given function in the `EnvironmentInjector` context of `TestBed`.\r\n     *\r\n     * @see {@link EnvironmentInjector#runInContext}\r\n     */\r\n    static runInInjectionContext(fn) {\r\n        return TestBedImpl.INSTANCE.runInInjectionContext(fn);\r\n    }\r\n    static createComponent(component) {\r\n        return TestBedImpl.INSTANCE.createComponent(component);\r\n    }\r\n    static resetTestingModule() {\r\n        return TestBedImpl.INSTANCE.resetTestingModule();\r\n    }\r\n    static execute(tokens, fn, context) {\r\n        return TestBedImpl.INSTANCE.execute(tokens, fn, context);\r\n    }\r\n    static get platform() {\r\n        return TestBedImpl.INSTANCE.platform;\r\n    }\r\n    static get ngModule() {\r\n        return TestBedImpl.INSTANCE.ngModule;\r\n    }\r\n    static flushEffects() {\r\n        return TestBedImpl.INSTANCE.flushEffects();\r\n    }\r\n    /**\r\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\r\n     * angular module. These are common to every test in the suite.\r\n     *\r\n     * This may only be called once, to set up the common providers for the current test\r\n     * suite on the current platform. If you absolutely need to change the providers,\r\n     * first use `resetTestEnvironment`.\r\n     *\r\n     * Test modules and platforms for individual platforms are available from\r\n     * '@angular/<platform_name>/testing'.\r\n     *\r\n     * @publicApi\r\n     */\r\n    initTestEnvironment(ngModule, platform, options) {\r\n        if (this.platform || this.ngModule) {\r\n            throw new Error('Cannot set base providers because it has already been called');\r\n        }\r\n        TestBedImpl._environmentTeardownOptions = options?.teardown;\r\n        TestBedImpl._environmentErrorOnUnknownElementsOption = options?.errorOnUnknownElements;\r\n        TestBedImpl._environmentErrorOnUnknownPropertiesOption = options?.errorOnUnknownProperties;\r\n        this.platform = platform;\r\n        this.ngModule = ngModule;\r\n        this._compiler = new TestBedCompiler(this.platform, this.ngModule);\r\n        // TestBed does not have an API which can reliably detect the start of a test, and thus could be\r\n        // used to track the state of the NgModule registry and reset it correctly. Instead, when we\r\n        // know we're in a testing scenario, we disable the check for duplicate NgModule registration\r\n        // completely.\r\n        ɵsetAllowDuplicateNgModuleIdsForTest(true);\r\n    }\r\n    /**\r\n     * Reset the providers for the test injector.\r\n     *\r\n     * @publicApi\r\n     */\r\n    resetTestEnvironment() {\r\n        this.resetTestingModule();\r\n        this._compiler = null;\r\n        this.platform = null;\r\n        this.ngModule = null;\r\n        TestBedImpl._environmentTeardownOptions = undefined;\r\n        ɵsetAllowDuplicateNgModuleIdsForTest(false);\r\n    }\r\n    resetTestingModule() {\r\n        this.checkGlobalCompilationFinished();\r\n        ɵresetCompiledComponents();\r\n        if (this._compiler !== null) {\r\n            this.compiler.restoreOriginalState();\r\n        }\r\n        this._compiler = new TestBedCompiler(this.platform, this.ngModule);\r\n        // Restore the previous value of the \"error on unknown elements\" option\r\n        ɵsetUnknownElementStrictMode(this._previousErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\r\n        // Restore the previous value of the \"error on unknown properties\" option\r\n        ɵsetUnknownPropertyStrictMode(this._previousErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\r\n        // We have to chain a couple of try/finally blocks, because each step can\r\n        // throw errors and we don't want it to interrupt the next step and we also\r\n        // want an error to be thrown at the end.\r\n        try {\r\n            this.destroyActiveFixtures();\r\n        }\r\n        finally {\r\n            try {\r\n                if (this.shouldTearDownTestingModule()) {\r\n                    this.tearDownTestingModule();\r\n                }\r\n            }\r\n            finally {\r\n                this._testModuleRef = null;\r\n                this._instanceTeardownOptions = undefined;\r\n                this._instanceErrorOnUnknownElementsOption = undefined;\r\n                this._instanceErrorOnUnknownPropertiesOption = undefined;\r\n                this._instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    configureCompiler(config) {\r\n        if (config.useJit != null) {\r\n            throw new Error('JIT compiler is not configurable via TestBed APIs.');\r\n        }\r\n        if (config.providers !== undefined) {\r\n            this.compiler.setCompilerProviders(config.providers);\r\n        }\r\n        return this;\r\n    }\r\n    configureTestingModule(moduleDef) {\r\n        this.assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\r\n        // Trigger module scoping queue flush before executing other TestBed operations in a test.\r\n        // This is needed for the first test invocation to ensure that globally declared modules have\r\n        // their components scoped properly. See the `checkGlobalCompilationFinished` function\r\n        // description for additional info.\r\n        this.checkGlobalCompilationFinished();\r\n        // Always re-assign the options, even if they're undefined.\r\n        // This ensures that we don't carry them between tests.\r\n        this._instanceTeardownOptions = moduleDef.teardown;\r\n        this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\r\n        this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\r\n        this._instanceDeferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\r\n        // Store the current value of the strict mode option,\r\n        // so we can restore it later\r\n        this._previousErrorOnUnknownElementsOption = ɵgetUnknownElementStrictMode();\r\n        ɵsetUnknownElementStrictMode(this.shouldThrowErrorOnUnknownElements());\r\n        this._previousErrorOnUnknownPropertiesOption = ɵgetUnknownPropertyStrictMode();\r\n        ɵsetUnknownPropertyStrictMode(this.shouldThrowErrorOnUnknownProperties());\r\n        this.compiler.configureTestingModule(moduleDef);\r\n        return this;\r\n    }\r\n    compileComponents() {\r\n        return this.compiler.compileComponents();\r\n    }\r\n    inject(token, notFoundValue, flags) {\r\n        if (token === TestBed) {\r\n            return this;\r\n        }\r\n        const UNDEFINED = {};\r\n        const result = this.testModuleRef.injector.get(token, UNDEFINED, ɵconvertToBitFlags(flags));\r\n        return result === UNDEFINED\r\n            ? this.compiler.injector.get(token, notFoundValue, flags)\r\n            : result;\r\n    }\r\n    /** @deprecated from v9.0.0 use TestBed.inject */\r\n    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\r\n        return this.inject(token, notFoundValue, flags);\r\n    }\r\n    runInInjectionContext(fn) {\r\n        return runInInjectionContext(this.inject(EnvironmentInjector), fn);\r\n    }\r\n    execute(tokens, fn, context) {\r\n        const params = tokens.map((t) => this.inject(t));\r\n        return fn.apply(context, params);\r\n    }\r\n    overrideModule(ngModule, override) {\r\n        this.assertNotInstantiated('overrideModule', 'override module metadata');\r\n        this.compiler.overrideModule(ngModule, override);\r\n        return this;\r\n    }\r\n    overrideComponent(component, override) {\r\n        this.assertNotInstantiated('overrideComponent', 'override component metadata');\r\n        this.compiler.overrideComponent(component, override);\r\n        return this;\r\n    }\r\n    overrideTemplateUsingTestingModule(component, template) {\r\n        this.assertNotInstantiated('TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\r\n        this.compiler.overrideTemplateUsingTestingModule(component, template);\r\n        return this;\r\n    }\r\n    overrideDirective(directive, override) {\r\n        this.assertNotInstantiated('overrideDirective', 'override directive metadata');\r\n        this.compiler.overrideDirective(directive, override);\r\n        return this;\r\n    }\r\n    overridePipe(pipe, override) {\r\n        this.assertNotInstantiated('overridePipe', 'override pipe metadata');\r\n        this.compiler.overridePipe(pipe, override);\r\n        return this;\r\n    }\r\n    /**\r\n     * Overwrites all providers for the given token with the given provider definition.\r\n     */\r\n    overrideProvider(token, provider) {\r\n        this.assertNotInstantiated('overrideProvider', 'override provider');\r\n        this.compiler.overrideProvider(token, provider);\r\n        return this;\r\n    }\r\n    overrideTemplate(component, template) {\r\n        return this.overrideComponent(component, { set: { template, templateUrl: null } });\r\n    }\r\n    createComponent(type) {\r\n        const testComponentRenderer = this.inject(TestComponentRenderer);\r\n        const rootElId = `root${_nextRootElementId++}`;\r\n        testComponentRenderer.insertRootElement(rootElId);\r\n        if (ɵgetAsyncClassMetadataFn(type)) {\r\n            throw new Error(`Component '${type.name}' has unresolved metadata. ` +\r\n                `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\r\n        }\r\n        const componentDef = type.ɵcmp;\r\n        if (!componentDef) {\r\n            throw new Error(`It looks like '${ɵstringify(type)}' has not been compiled.`);\r\n        }\r\n        const componentFactory = new ɵRender3ComponentFactory(componentDef);\r\n        const initComponent = () => {\r\n            const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);\r\n            return this.runInInjectionContext(() => {\r\n                const isZoneless = this.inject(ɵZONELESS_ENABLED);\r\n                const fixture = isZoneless\r\n                    ? new ScheduledComponentFixture(componentRef)\r\n                    : new PseudoApplicationComponentFixture(componentRef);\r\n                fixture.initialize();\r\n                return fixture;\r\n            });\r\n        };\r\n        const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\r\n        const ngZone = noNgZone ? null : this.inject(NgZone, null);\r\n        const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\r\n        this._activeFixtures.push(fixture);\r\n        return fixture;\r\n    }\r\n    /**\r\n     * @internal strip this from published d.ts files due to\r\n     * https://github.com/microsoft/TypeScript/issues/36216\r\n     */\r\n    get compiler() {\r\n        if (this._compiler === null) {\r\n            throw new Error(`Need to call TestBed.initTestEnvironment() first`);\r\n        }\r\n        return this._compiler;\r\n    }\r\n    /**\r\n     * @internal strip this from published d.ts files due to\r\n     * https://github.com/microsoft/TypeScript/issues/36216\r\n     */\r\n    get testModuleRef() {\r\n        if (this._testModuleRef === null) {\r\n            this._testModuleRef = this.compiler.finalize();\r\n        }\r\n        return this._testModuleRef;\r\n    }\r\n    assertNotInstantiated(methodName, methodDescription) {\r\n        if (this._testModuleRef !== null) {\r\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\r\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\r\n        }\r\n    }\r\n    /**\r\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\r\n     *\r\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\r\n     * in-progress module compilation. This creates a potential hazard - the very first time the\r\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\r\n     * compilations of modules declared in global scope. These compilations should be finished.\r\n     *\r\n     * To ensure that globally declared modules have their components scoped properly, this function\r\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\r\n     * to any other operations, the scoping queue is flushed.\r\n     */\r\n    checkGlobalCompilationFinished() {\r\n        // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\r\n        // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\r\n        if (!this.globalCompilationChecked && this._testModuleRef === null) {\r\n            ɵflushModuleScopingQueueAsMuchAsPossible();\r\n        }\r\n        this.globalCompilationChecked = true;\r\n    }\r\n    destroyActiveFixtures() {\r\n        let errorCount = 0;\r\n        this._activeFixtures.forEach((fixture) => {\r\n            try {\r\n                fixture.destroy();\r\n            }\r\n            catch (e) {\r\n                errorCount++;\r\n                console.error('Error during cleanup of component', {\r\n                    component: fixture.componentInstance,\r\n                    stacktrace: e,\r\n                });\r\n            }\r\n        });\r\n        this._activeFixtures = [];\r\n        if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\r\n            throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` +\r\n                `threw errors during cleanup`);\r\n        }\r\n    }\r\n    shouldRethrowTeardownErrors() {\r\n        const instanceOptions = this._instanceTeardownOptions;\r\n        const environmentOptions = TestBedImpl._environmentTeardownOptions;\r\n        // If the new teardown behavior hasn't been configured, preserve the old behavior.\r\n        if (!instanceOptions && !environmentOptions) {\r\n            return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\r\n        }\r\n        // Otherwise use the configured behavior or default to rethrowing.\r\n        return (instanceOptions?.rethrowErrors ??\r\n            environmentOptions?.rethrowErrors ??\r\n            this.shouldTearDownTestingModule());\r\n    }\r\n    shouldThrowErrorOnUnknownElements() {\r\n        // Check if a configuration has been provided to throw when an unknown element is found\r\n        return (this._instanceErrorOnUnknownElementsOption ??\r\n            TestBedImpl._environmentErrorOnUnknownElementsOption ??\r\n            THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\r\n    }\r\n    shouldThrowErrorOnUnknownProperties() {\r\n        // Check if a configuration has been provided to throw when an unknown property is found\r\n        return (this._instanceErrorOnUnknownPropertiesOption ??\r\n            TestBedImpl._environmentErrorOnUnknownPropertiesOption ??\r\n            THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\r\n    }\r\n    shouldTearDownTestingModule() {\r\n        return (this._instanceTeardownOptions?.destroyAfterEach ??\r\n            TestBedImpl._environmentTeardownOptions?.destroyAfterEach ??\r\n            TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT);\r\n    }\r\n    getDeferBlockBehavior() {\r\n        return this._instanceDeferBlockBehavior;\r\n    }\r\n    tearDownTestingModule() {\r\n        // If the module ref has already been destroyed, we won't be able to get a test renderer.\r\n        if (this._testModuleRef === null) {\r\n            return;\r\n        }\r\n        // Resolve the renderer ahead of time, because we want to remove the root elements as the very\r\n        // last step, but the injector will be destroyed as a part of the module ref destruction.\r\n        const testRenderer = this.inject(TestComponentRenderer);\r\n        try {\r\n            this._testModuleRef.destroy();\r\n        }\r\n        catch (e) {\r\n            if (this.shouldRethrowTeardownErrors()) {\r\n                throw e;\r\n            }\r\n            else {\r\n                console.error('Error during cleanup of a testing module', {\r\n                    component: this._testModuleRef.instance,\r\n                    stacktrace: e,\r\n                });\r\n            }\r\n        }\r\n        finally {\r\n            testRenderer.removeAllRootElements?.();\r\n        }\r\n    }\r\n    /**\r\n     * Execute any pending effects.\r\n     *\r\n     * @developerPreview\r\n     */\r\n    flushEffects() {\r\n        this.inject(ɵEffectScheduler).flush();\r\n    }\r\n}\r\n/**\r\n * @description\r\n * Configures and initializes environment for unit testing and provides methods for\r\n * creating components and services in unit tests.\r\n *\r\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\r\n *\r\n * @publicApi\r\n */\r\nconst TestBed = TestBedImpl;\r\n/**\r\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\r\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\r\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\r\n * function from the `@angular/core` package instead.\r\n *\r\n * Example:\r\n *\r\n * ```\r\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\r\n *   // some code that uses `dep` and `object`\r\n *   // ...\r\n * }));\r\n *\r\n * it('...', inject([AClass], (object) => {\r\n *   object.doSomething();\r\n *   expect(...);\r\n * })\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nfunction inject(tokens, fn) {\r\n    const testBed = TestBedImpl.INSTANCE;\r\n    // Not using an arrow function to preserve context passed from call site\r\n    return function () {\r\n        return testBed.execute(tokens, fn, this);\r\n    };\r\n}\r\n/**\r\n * @publicApi\r\n */\r\nclass InjectSetupWrapper {\r\n    constructor(_moduleDef) {\r\n        this._moduleDef = _moduleDef;\r\n    }\r\n    _addModule() {\r\n        const moduleDef = this._moduleDef();\r\n        if (moduleDef) {\r\n            TestBedImpl.configureTestingModule(moduleDef);\r\n        }\r\n    }\r\n    inject(tokens, fn) {\r\n        const self = this;\r\n        // Not using an arrow function to preserve context passed from call site\r\n        return function () {\r\n            self._addModule();\r\n            return inject(tokens, fn).call(this);\r\n        };\r\n    }\r\n}\r\nfunction withModule(moduleDef, fn) {\r\n    if (fn) {\r\n        // Not using an arrow function to preserve context passed from call site\r\n        return function () {\r\n            const testBed = TestBedImpl.INSTANCE;\r\n            if (moduleDef) {\r\n                testBed.configureTestingModule(moduleDef);\r\n            }\r\n            return fn.apply(this);\r\n        };\r\n    }\r\n    return new InjectSetupWrapper(() => moduleDef);\r\n}\r\n\r\n/**\r\n * Public Test Library for unit testing Angular applications. Assumes that you are running\r\n * with Jasmine, Mocha, or a similar framework which exports a beforeEach function and\r\n * allows tests to be asynchronous by either returning a promise or using a 'done' parameter.\r\n */\r\n// Reset the test providers and the fake async zone before each test.\r\n// We keep a guard because somehow this file can make it into a bundle and be executed\r\n// beforeEach is only defined when executing the tests\r\nglobalThis.beforeEach?.(getCleanupHook(false));\r\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\r\n// tearing down the module is supposed to run after the test so that we can associate\r\n// teardown errors with the correct test.\r\n// We keep a guard because somehow this file can make it into a bundle and be executed\r\n// afterEach is only defined when executing the tests\r\nglobalThis.afterEach?.(getCleanupHook(true));\r\nfunction getCleanupHook(expectedTeardownValue) {\r\n    return () => {\r\n        const testBed = TestBedImpl.INSTANCE;\r\n        if (testBed.shouldTearDownTestingModule() === expectedTeardownValue) {\r\n            testBed.resetTestingModule();\r\n            resetFakeAsyncZoneIfExists();\r\n        }\r\n    };\r\n}\r\n/**\r\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\r\n * investigation.\r\n *\r\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\r\n *\r\n * @codeGenApi\r\n */\r\n// TODO(iminar): Remove this code in a safe way.\r\nconst __core_private_testing_placeholder__ = '';\r\n\r\n/**\r\n * @module\r\n * @description\r\n * Entry point for all public APIs of the core/testing package.\r\n */\r\n\r\n/// <reference types=\"jasmine\" />\r\n// This file only reexports content of the `src` folder. Keep it that way.\r\n\r\n// This file is not used to build this module. It is only used during editing\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, DeferBlockFixture, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, MetadataOverrider as ɵMetadataOverrider };\r\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}